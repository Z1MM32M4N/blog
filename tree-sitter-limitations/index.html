<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-05-30 04:43:46 -0400">
<meta name="description" content="TODO">
<title>Is tree-sitter good enough? – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  




</head>
<body>
  




  <header>
    <h1 class="title">Is tree-sitter good enough?</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2022-05-30 04:43:46 -0400">May 30, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#appendix-sorbet">Appendix: Sorbet</a></li>
  </ul>
</nav>

<main>
<p>My answer: mostly no, or at the very least not for all cases, though I really wish it were good enough for the use cases I have, because then I would have less work to do.</p>
<!-- more -->
<p>I’m guessing you already know what tree-sitter is because you clicked on the title. If you clicked because you were hoping to find out: <a href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a> is a relatively<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Is it still new? The GitHub repo has commits dating back to 2013, though I only first heard about it in 2017. It still has a feeling of newness about it, but I digress.<br />
<br />
</span></span> new project which aims to make writing fast, error-tolerant parsers take less work. To do that, it provides both pre-built parsers for common programming languages and a toolkit for building new parsers. It’s known for use in various GitHub features by way of their <a href="https://github.com/github/semantic">semantic</a> tool, which powers the code navigation tooltips that you sometimes see on GitHub.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">The semantic repo actually has a <a href="https://github.com/github/semantic/blob/master/docs/why-tree-sitter.md">short overview</a> of why they chose tree-sitter, along with some drawbacks.<br />
<br />
</span></span></p>
<p>I see a lot of talk about tree-sitter these days. And for a lot of projects, it’s really nice! This is especially true for projects that want to be able to parse a super wide variety of languages with an otherwise uniform API with the least amount of manual work. Things like writing a syntax highlighter in an editor, or building something like <a href="https://www.emacswiki.org/emacs/ParEdit">ParEdit</a> for arbitrary languages, or providing best-effort jump-to-definition results.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Another neat use case, from work: every time a commit is pushed to an approved PR, the approval is dismissed, unless (using tree-sitter) the CI system detects that the parse tree hasn’t changed. This spares comment and formatting changes the toil of a re-review.<br />
<br />
</span></span></p>
<p>When those goals are flipped—it has to work for exactly one language, and “best-effort” isn’t enough—tree-sitter becomes less attractive. As someone who works on language tooling <a href="https://jez.io/#work">professionally</a> and is lazy, it’s kind of disappointing. As much as tree-sitter enthusiasts sell it as a magical solution that can free me from having to think about parsers, it’s just not been that silver bullet in my experience.</p>
<p>There are two questions I would pose to anyone curious about using tree-sitter for their parser:</p>
<ol type="1">
<li>Is serving autocompletion requests going to be one of your use cases?</li>
<li>How much do you care about custom messages for syntax errors?</li>
</ol>
<p>If either or both of these are important, I’d probably recommend rolling your own parser, either using a parser generator or using recursive descent by hand. The longer lived your project is, the more these constraints are going to be hard to accomplish in tree-sitter.</p>
<p>At this point, I should caveat this by saying that I’ve come to these conclusions having spent far less time with tree-sitter than I have with other parsing techniques, so maybe I only think they’re harder than they actually are because I lack a depth of tree-sitter experience.</p>
<p>When investigating tree-sitter as a replacement for an existing parser, it’s been too easy to find parses from tree-sitter that don’t look like what I’d expect out of a parser that is meant to handle the kinds of errors programmers write in the real world.</p>
<p>It’s entirely possible that I’ve just been <em>really</em> unlucky, and that the problems I’ve found are all fixable with a few bug reports and a little elbow grease. But it just seems to me that if I’m going to have to spend time fixing bugs anyways, it may as well be in a parser I’ve written myself.</p>
<p>Let me show what I mean. Here are some snippets of code that I hope you’ll agree represents code someone might write mid-edit, for which you want to both (1) provide autocompletion results for and (2) provide a human-friendly error message for. Following the code snippet is the parse result produced by the corresponding tree-sitter grammar for that language. You can follow along on the <a href="https://tree-sitter.github.io/tree-sitter/playground">tree-sitter online playground</a>.</p>
<p><br />
</p>
<p>Let’s start with a Ruby program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f <span class="kw">=</span> <span class="kw">-&gt;</span>(x) <span class="kw">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  x<span class="kw">.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource numberLines hl-8 hl-9"><code class="sourceCode"><span id="cb2-1"><a href="#cb2-1"></a>program [0, 0] - [3, 0]</span>
<span id="cb2-2"><a href="#cb2-2"></a>  assignment [0, 0] - [2, 1]</span>
<span id="cb2-3"><a href="#cb2-3"></a>    left: identifier [0, 0] - [0, 1]</span>
<span id="cb2-4"><a href="#cb2-4"></a>    right: lambda [0, 4] - [2, 1]</span>
<span id="cb2-5"><a href="#cb2-5"></a>      parameters: lambda_parameters [0, 6] - [0, 9]</span>
<span id="cb2-6"><a href="#cb2-6"></a>        identifier [0, 7] - [0, 8]</span>
<span id="cb2-7"><a href="#cb2-7"></a>      body: block [0, 10] - [2, 1]</span>
<span id="cb2-8"><a href="#cb2-8"></a>        identifier [1, 2] - [1, 3]</span>
<span id="cb2-9"><a href="#cb2-9"></a>        ERROR [1, 3] - [1, 4]</span></code></pre></div>
<p>By way of comparison, here’s what a valid parse looks like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>f <span class="kw">=</span> <span class="kw">-&gt;</span>(x) <span class="kw">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  x<span class="at">.foo</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource numberLines hl-8 hl-9 hl-10"><code class="sourceCode"><span id="cb4-1"><a href="#cb4-1"></a>program [0, 0] - [3, 0]</span>
<span id="cb4-2"><a href="#cb4-2"></a>  assignment [0, 0] - [2, 1]</span>
<span id="cb4-3"><a href="#cb4-3"></a>    left: identifier [0, 0] - [0, 1]</span>
<span id="cb4-4"><a href="#cb4-4"></a>    right: lambda [0, 4] - [2, 1]</span>
<span id="cb4-5"><a href="#cb4-5"></a>      parameters: lambda_parameters [0, 6] - [0, 9]</span>
<span id="cb4-6"><a href="#cb4-6"></a>        identifier [0, 7] - [0, 8]</span>
<span id="cb4-7"><a href="#cb4-7"></a>      body: block [0, 10] - [2, 1]</span>
<span id="cb4-8"><a href="#cb4-8"></a>        call [1, 2] - [1, 7]</span>
<span id="cb4-9"><a href="#cb4-9"></a>          receiver: identifier [1, 2] - [1, 3]</span>
<span id="cb4-10"><a href="#cb4-10"></a>          method: identifier [1, 4] - [1, 7]</span></code></pre></div>
<p>In the good parse, tree-sitter produces a <code>call</code> node. In the bad parse, it just produces a <code>block</code> that has a list containing two elements. Ideally, what we’d see here is something like this:</p>
<pre><code>call
  receiver: identifier
  method: ERROR</code></pre>
<p>Which tells us (1) that there was a method call, (2) what the receiver of the method call was so we know where to start looking for methods to autocomplete, (3) that the syntax error was localized to the method call.</p>
<p>There’s a similar problem with constants accesses:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>f <span class="kw">=</span> <span class="kw">-&gt;</span>(x) <span class="kw">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  A<span class="kw">::</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>g <span class="kw">=</span> <span class="kw">-&gt;</span>(x) <span class="kw">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  A<span class="kw">::</span><span class="cn">B</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>program [0, 0] - [6, 0]</span>
<span id="cb7-2"><a href="#cb7-2"></a>  # ...</span>
<span id="cb7-3"><a href="#cb7-3"></a>      body: block [0, 10] - [2, 1]</span>
<span id="cb7-4"><a href="#cb7-4"></a>        constant [1, 2] - [1, 3]</span>
<span id="cb7-5"><a href="#cb7-5"></a>        ERROR [1, 3] - [1, 5]</span>
<span id="cb7-6"><a href="#cb7-6"></a>  # ...</span>
<span id="cb7-7"><a href="#cb7-7"></a>      body: block [3, 10] - [5, 1]</span>
<span id="cb7-8"><a href="#cb7-8"></a>        scope_resolution [4, 2] - [4, 6]</span>
<span id="cb7-9"><a href="#cb7-9"></a>          scope: constant [4, 2] - [4, 3]</span>
<span id="cb7-10"><a href="#cb7-10"></a>          name: constant [4, 5] - [4, 6]</span></code></pre></div>
<p><br />
</p>
<p>Maybe this example was a little contrived, because a comparable program written in JavaScript actually parses the way I’d hoped the Ruby one did. Okay, maybe it’s just a bug in the Ruby grammar?</p>
<p>This next snippet reproduces in both Ruby and JavaScript:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foo</span>() {</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">bar</span>() {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<pre><code>program [0, 0] - [6, 0]
  class_declaration [0, 0] - [5, 1]
    name: identifier [0, 6] - [0, 7]
    body: class_body [0, 8] - [5, 1]
      member: method_definition [1, 2] - [4, 3]
        name: property_identifier [1, 2] - [1, 5]
        parameters: formal_parameters [1, 5] - [1, 7]
        body: statement_block [1, 8] - [4, 3]
          expression_statement [3, 2] - [3, 9]
            call_expression [3, 2] - [3, 7]
              function: identifier [3, 2] - [3, 5]
              arguments: arguments [3, 5] - [3, 7]
            ERROR [3, 8] - [3, 9]</code></pre>
<p>It’s hard to see what’s going on here without matching up the line numbers in the parse tree. Here’s essentially what the snippet above looks like to tree-sitter:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foo</span>() {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">bar</span>() {</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Some points:</p>
<ul>
<li>Even though <code>bar() { ... }</code> is valid method syntax, that’s gone. The parser thinks that there was a call to a method named <code>bar</code> on an implicit receiver (i.e., <code>this</code>).</li>
<li>The syntax error shows up after the imagined call to <code>bar</code>, not associated with the <code>foo</code> method.</li>
</ul>
<p>It gets even worse if the snippet changes so that <code>bar</code> actually has parameters and code in the method body.<span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">The parameters become call-site arguments, and the code acts as though it was written inside <code>foo</code> not <code>bar</code>.<br />
<br />
</span></span> With a parse that drops the <code>bar</code> method definition entirely, the user no longer receives autocompletion results inside <code>bar</code> until they fix the error in <code>foo</code>.</p>
<p>The best error message here would be to point out to the author that their curly braces are mismatched,<span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">Indeed, that’s <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=872bd946a8789aba9d49e07aef614819">exactly the error</a> on a comparable Rust example. (Rust’s parser is hand-written.)<br />
<br />
</span></span> and then ideally use that information to recover when parsing.</p>
<p><br />
</p>
<p>I could turn this into a post full of weird code snippets and poor parse results, but that’s not useful. What I’m trying to show is that when the demands are “the one specific language I care about has lots of idiosyncratic parse errors that are super common when in an editor,” then you’re still going to be limited by the quality of the particular tree-sitter grammar you’re working with. Fixing bugs in that grammar requires working within the constraints tree-sitter imposes to be able to power all the grammar-agnostic features (best-effort error recovery, uniform API, etc.) that it provides.</p>
<p>On the other hand, if you control the whole parser, you can bend it however you want. You arguably do more work, but you at least have the option of doing more work (with the reward of better results).</p>
<p>Don’t get me wrong, I still think tree-sitter is a great project with a neat new idea, and it’s done more to make parsing more accessible than any recent effort. But too many people tout it as something with no tradeoffs, and I just don’t think that’s fair.</p>
<p>If you think I’m overlooking something, please let me know and I’ll happily update this post, and maybe even start using tree-sitter in my projects.</p>
<p><br />
</p>
<h1 id="appendix-sorbet">Appendix: Sorbet</h1>
<p>This is the part where I get to gleefully show off Sorbet’s parser, which I’m quite proud of.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># typed: true</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> A</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> foo</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">puts</span>(<span class="vs">&#39;inside foo&#39;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">puts</span>(<span class="vs">&#39;after (outside) foo&#39;</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> bar(x)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    x<span class="kw">.</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The parse tree:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>s(<span class="wa">:class</span>,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  s(<span class="wa">:const</span>, <span class="dv">nil</span>, <span class="wa">:A</span>), <span class="dv">nil</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  s(<span class="wa">:begin</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    s(<span class="wa">:def</span>, <span class="wa">:foo</span>, <span class="dv">nil</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      s(<span class="wa">:begin</span>,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        s(<span class="wa">:send</span>, <span class="dv">nil</span>, <span class="wa">:puts</span>,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>          s(<span class="wa">:str</span>, <span class="st">&quot;inside foo&quot;</span>)))),</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    s(<span class="wa">:send</span>, <span class="dv">nil</span>, <span class="wa">:puts</span>,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>      s(<span class="wa">:str</span>, <span class="st">&quot;after (outside) foo&quot;</span>)),</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    s(<span class="wa">:def</span>, <span class="wa">:bar</span>,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>      s(<span class="wa">:args</span>,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        s(<span class="wa">:arg</span>, <span class="wa">:x</span>)),</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>      s(<span class="wa">:send</span>,</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        s(<span class="wa">:lvar</span>, <span class="wa">:x</span>), :<span class="kw">&lt;</span>method<span class="kw">-</span>name<span class="kw">-</span>missing<span class="kw">&gt;</span>))))</span></code></pre></div>
<p>The errors:</p>
<pre><code>editor.rb:10: unexpected token &quot;end&quot; https://srb.help/2001
    10 |  end
          ^^^

editor.rb:11: unexpected token &quot;end of file&quot; https://srb.help/2001
    11 |end
    12 |

editor.rb:3: Hint: this &quot;def&quot; token might not be properly closed https://srb.help/2003
     3 |  def foo
          ^^^
    editor.rb:11: Matching `end` found here but is not indented as far
    11 |end
        ^^^
Errors: 3</code></pre>
<p>If you use Sorbet and ever come across a file where you either didn’t get the autocompletion results that you wanted or you thought a syntax error was particularly confusing, feel free to <a href="https://sorbet.run/?arg=--print=parse-tree-whitequark#%23%20typed%3A%20true%0A%23%20Share%20your%20example%20with%20%22Examples%20%3E%20Create%20issue%20with%20example%22%0A">craft a bug report here</a> and I’d be happy to take a look.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#parsing">parsing</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#tree-sitter">tree-sitter</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

