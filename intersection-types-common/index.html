
<!DOCTYPE html>

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Intersection Types in Sorbet are Surprisingly Common - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="Conventional knowledge is that union types are common and intersection types are rare. But actually that's not the case—intersection types show up in &hellip;">

<meta name="keywords" content="sorbet ruby types ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->

  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://blog.jez.io/touch-icon.png">
  <meta name="twitter:title" content="Intersection Types in Sorbet are Surprisingly Common">
  <meta name="twitter:description" content="Conventional knowledge is that union types are common and intersection types are rare. But actually that's not the case—intersection types show up in &hellip;">
  <meta name="twitter:creator" content="@jez_io">


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/intersection-types-common">
<meta property="og:title" content="Intersection Types in Sorbet are Surprisingly Common">
<meta property="og:description" content="Conventional knowledge is that union types are common and intersection types are rare. But actually that's not the case—intersection types show up in &hellip;">
<meta property="og:image" content="https://blog.jez.io/touch-icon.png">
<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/intersection-types-common">
<link href="/touch-icon.png" rel="apple-touch-icon-precomposed">
<link href="/favicon@2x.png" rel="icon" sizes="32x32">
<link href="/favicon.png" rel="icon" sizes="16x16">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">




</head>

<body id="post" class="strong-keywords">

<nav class="Navigation">
  <ul class="Tags">
    
      <li class="Tag">
        
          <a href="/">Home</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="/categories/">Categories</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="https://jez.io">About</a>
        
      </li>
    
  </ul>
</nav>





<div class="EntryHeader">
  <h1 class="EntryHeader-title">Intersection Types in Sorbet are Surprisingly Common</h1>
  <h2 class="EntryHeader-subtitle">January 4, 2020</h2>

  <ul class="Tags">
    
  </ul>
</div>



<div id="main" role="main">
  <article class="Post-content">
    <p>Conventional knowledge is that union types are common and intersection
types are rare. But actually that&rsquo;s not the case—intersection types
show up in nearly every program Sorbet type checks thanks to control
flow.</p>

<p><a href="https://sorbet.org/docs/union-types">Union types</a> in Sorbet are incredibly common, which should be no
surprise. In Sorbet, <code>T.nilable(...)</code> is sugar for <code>T.any(NilClass,
...)</code>. <code>T.nilable</code> shows up all over the place and probably catches more
bugs than any other feature in Sorbet.</p>

<p>Sorbet also has <a href="https://sorbet.org/docs/intersection-types">intersection types</a>. While union types mean &ldquo;either
this or that,&rdquo; intersection types mean &ldquo;both this and that.&rdquo; On first
glance, intersection types seem like some super niche feature which only
benefits a handful of programs. In Stripe&rsquo;s Ruby monorepo, the strings
<code>T.any</code> and <code>T.nilable</code> occur nearly 300 times more than <code>T.all</code> does.</p>

<p>But those numbers hide something critical: intersection types power
Sorbet&rsquo;s <a href="https://sorbet.org/docs/flow-sensitive">control flow-sensitive typing</a>. They&rsquo;re actually present in
every Ruby program, but just a little hard to spot. Let&rsquo;s look at how
pervasive they are with a few examples:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># typed: strict</span>
</span><span class='line'><span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Parent</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Child</span> <span class="o">&lt;</span> <span class="no">Parent</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">Parent</span><span class="p">).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">Child</span>
</span><span class='line'>    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># Revealed type: `Child`</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>Here <code>x</code> starts out having type <code>Parent</code>, but inside the <code>case</code>
statement Sorbet treats <code>x</code> as having the more specific type <code>Child</code>.
There&rsquo;s no <code>T.all</code> in sight, but that&rsquo;s because it&rsquo;s hiding. Sorbet
doesn&rsquo;t just throw away the fact that it knew <code>x &lt;: Parent</code>. Instead, it
uses <code>T.all</code> to update its type for <code>x</code> to <code>T.all(Parent, Child)</code>.</p>

<p><code>T.all(Parent, Child)</code> is equivalent to <code>Child</code> because <code>Child</code> is a
subtype of <code>Parent</code>. If types represent sets of values, then the set of
values represented by <code>Child</code> is a subset of the set of values
represented by <code>Parent</code>, so the intersection of those two sets would
just leave <code>Child</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Sorbet attempts to simplify a large type to a smaller, equivalent type
when it can for two reasons:</p>

<ul>
<li><p><strong>Usability</strong> – Most users don&rsquo;t know that <code>T.all</code> means &ldquo;intersection
type&rdquo; or even what intersection types are. (And even those who do
still end up drawing Venn diagrams from time to time!) It only gets
more complicated when <code>T.all</code>s and <code>T.any</code>s nest inside each other.</p>

<p>Meanwhile, <code>Child</code> is a super easy type to understand, and leads to
nice, short error messages.</p></li>
<li><p><strong>Performance</strong> – Checking whether one type is a subtype of another is
a super common operation, so it has to be fast. By collapsing
<code>T.all(Parent, Child)</code> to <code>Child</code>, Sorbet does at least half as much
work when checking subtyping (probably more, because of some common
path optimizations).</p>

<p>When this simplification happens, Sorbet even skips an allocation
entirely. Cnstructing <code>T.all(Parent, Child)</code> in Sorbet short
circuits and returns a reference to the already allocated <code>Child</code> type
that was passed as an argument (with ownership tracked via
<code>std::shared_ptr</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>).</p></li>
</ul>


<p>Let&rsquo;s look at another example of control flow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># typed: strict</span>
</span><span class='line'><span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">a_or_b: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="p">)).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example2</span><span class="p">(</span><span class="n">a_or_b</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">a_or_b</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">A</span>
</span><span class='line'>    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">a_or_b</span><span class="p">)</span> <span class="c1"># Revealed type: `A`</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>This example method accepts either <code>A</code> or <code>B</code> (<code>T.any(A, B)</code>) and then
branches on whether <code>a_or_b</code> is an instance of <code>A</code>. Again: Sorbet
doesn&rsquo;t throw away that it knows <code>a_or_b &lt;: T.any(A, B)</code>. Instead it
updates its knowledge of the type of <code>a_or_b</code> using <code>T.all</code> to get
<code>T.all(T.any(A, B), A)</code>. Realizing that this is equivalent to <code>A</code> is a
bit trickier:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="p">),</span> <span class="no">A</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Distribute</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">B</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># T.all(A, A) is just A (idempotence)</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">A</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">B</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># A and B are classes (not mixins) and neither inherits the other.</span>
</span><span class='line'><span class="c1"># It's impossible to have a value of that type, so it's bottom:</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">A</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">noreturn</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># bottom is the identity of union</span>
</span><span class='line'><span class="no">A</span></span></code></pre></td></tr></table></div></figure>


<p>You can start to see how usability and performance and might get a
little out of hand if Sorbet didn&rsquo;t keep attempting to simplify things!
The cumulative effect of all the control flow in a program would result
in huge, unweidly types.</p>

<p>Until now you could claim that I&rsquo;ve been hyping up intersection types as
the solution to problems that were self-imposed. That if we just
invented some other method for modeling control flow, it would have been
naturally usable or naturally performant, and we wouldn&rsquo;t have had
problems in the first place. So next let&rsquo;s look at some examples to see
why intersection types really are the most natural solution:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">I1</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo1</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">module</span> <span class="nn">I2</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo2</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">I1</span><span class="p">).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="nf">foo1</span>  <span class="c1"># Works outside</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">I2</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="nf">foo1</span>  <span class="c1"># Should (and does) still work inside</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="nf">foo2</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A">→ View on sorbet.run</a></p>

<p>Unlike in the other examples, this is the first example where had we
tried to implement control-flow-sensitive typing by throwing away the
old type and using the new type instead it wouldn&rsquo;t have worked. The key
thing to notice: this example uses modules. Outside the <code>case</code> of course
calling <code>x.method_from_1</code> works because <code>x</code> starts out at type <code>I1</code>. But
if we treated <code>x</code> as only <code>I2</code> inside the <code>when I2</code>, we&rsquo;d start
reporting an error for calling <code>x.method_from_1</code> because it doesn&rsquo;t
exist on <code>I2</code>.</p>

<p>Unlike intersecting unrelated classes (our <code>T.all(B, A)</code> example from
earlier), intersecting unrelated modules does&rsquo;t collapse to
<code>T.noreturn</code>. There&rsquo;s nothing stopping some class from including both
<code>I1</code> and <code>I2</code>. Instances of that class would be values of type
<code>T.any(I1, I2)</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">SomeClass</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">I1</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">I2</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># This type assertion is okay:</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">(</span><span class="no">SomeClass</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">I1</span><span class="p">,</span> <span class="no">I2</span><span class="p">))</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))">→ View on sorbet.run</a></p>

<p>So at least for implementing certain cases of flow sensitive typing,
we&rsquo;ll <em>need</em> intersection types anyways. Then for these certain cases
we&rsquo;d incur the usability and performance problems we discovered earlier
and have to solve them.</p>

<p>But more than that, intersection types are fundamentally easier to work
with compared to some ad hoc approach to flow sensitive typing. Type
system bugs are weird. It&rsquo;s frquently harder to figure out whether the
current behavior is buggy in the first place than it is to find the
cause!</p>

<p>In that light, intersection types present an elegant, robust model for
arriving at what the correct behavior <em>should</em> be, independent of what
Sorbet&rsquo;s existing behavior is. It&rsquo;s clear how intersection types
interact with union types, and with subtyping, and with generics, and
with variance, etc.</p>

<p>By repurposing intersection types to model control flow sensitivity,
when things go wrong there&rsquo;s a framework for discovering what&rsquo;s right.</p>

<p>(Speaking of repurposing, intersection types also play an important role
in how Sorbet <a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend">suggests potential method signatures</a>! That&rsquo;s three birds
with one stone.)</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you&rsquo;re not convinced, consider: with <code>T.all(Parent, Child)</code> we should be able to call all the methods on <code>Parent</code> and all the methods on <code>Child</code>. But <code>Child</code> inherits <code>Parent</code>&rsquo;s methods, so any method <code>Parent</code> has will already be on <code>Child</code>. So <code>Child</code> is equivalently good as <code>T.all(Parent, Child)</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you&rsquo;re looking for a good intro to modern C++ things like <code>shared_ptr</code>, I can&rsquo;t recommend <a href="https://berthub.eu/articles/posts/cpp-intro/">this blog post series</a> enough.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>


    <footer class="entry-meta">
      <span class="entry-tags">
        <ul class="Tags">
          
            <li class="Tag">
              <a href="/categories/#sorbet" title="Pages tagged sorbet">sorbet</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#ruby" title="Pages tagged ruby">ruby</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#types" title="Pages tagged types">types</a>
            </li>
          
        </ul>
      </span>
      <span class="entry-date date published updated"><time datetime="2020-01-04T19:50:32-06:00">January 4, 2020</time></span>
      
    </footer>
  </div>
  
  <div class="read-more">
    
      <div class="read-more-header">
        <a href="/union-types-checked-exceptions/" class="Button">Read More</a>
      </div><!-- /.read-more-header -->
      <div class="read-more-content">
        <h3><a href="/union-types-checked-exceptions/" title="Sorbet Does Not Have Checked Exceptions">Sorbet Does Not Have Checked Exceptions</a></h3>
      <p>Sorbet does not support checked exceptions, and I don&#8217;t think it ever should. <a href="/union-types-checked-exceptions/"> Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/clangd-ruby/" title="Exploring Ruby with clangd">Exploring Ruby with clangd</a></h4>
            <span>Published on July 21, 2020</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/linkers-ruby-c-exts/" title="Linkers & Ruby C Extensions">Linkers & Ruby C Extensions</a></h4>
            <span>Published on June 7, 2020</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
  </div><!-- /.read-more -->


</div>

<div class="footer-wrapper">
  Blog source on <a href="https://github.com/jez/blog">GitHub</a>.

</div>

</body>
</html>
