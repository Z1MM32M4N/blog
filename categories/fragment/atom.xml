<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fragment | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/fragment/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-09-02T03:03:07-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prefer .then() over .catch()]]></title>
    <link href="https://blog.jez.io/prefer-then-over-catch/"/>
    <updated>2018-05-31T15:58:52-07:00</updated>
    <id>https://blog.jez.io/prefer-then-over-catch</id>
    <content type="html"><![CDATA[<p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<pre><code class="js Bad code; don't do this">// "Success" and "failure" types (definitions omitted)
import type {OkResult, ErrResult} from 'src/types';

const doSomething = (): Promise&lt;OkResult&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve(...) when it worked, but
    // cal reject(...) when it failed.
  });
};

doSomething
  .then((res) =&gt; ...)
  .catch((err) =&gt; ...)
</code></pre>

<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<pre><code class="js">type ErrResult = string;
</code></pre>

<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<pre><code class="js">// number, not a string!
reject(42);
</code></pre>

<p>nor from doing this:</p>

<pre><code class="js">// boolean, not a string!
.catch((err: boolean) =&gt; ...);
</code></pre>

<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<pre><code class="js Better code than before">// Helper function for exhaustiveness.
// See here: https://blog.jez.io/flow-exhaustiveness/
import {absurd} from 'src/absurd';

import type {OkResult, ErrResult} from 'src/types';

// Use a union type to mean "success OR failure"
type Result =
  | {|tag: 'ok', val: OkResult|}
  | {|tag: 'err', val: ErrResult|};

//     Use our new union type ‚îÄ‚îÄ‚îê
const doSomething = (): Promise&lt;Result&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve({tag: 'ok',  val: ...}) when it worked, and
    // call resolve({tag: 'err', val: ...}) when it failed
  });
};

doSomething
  // Use a switch statement in the result:
  .then((res) =&gt; {
    switch (res.tag) {
      case 'ok':
        // ...
        break;
      case 'err':
        // ...
        break;
      default:
        // Guarantees we covered all cases.
        absurd(res);
        break;
    }
  })
</code></pre>

<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<pre><code class="js">// If I know that throwNumber will always call `reject` with a
// number, I can stop the loose types from propagating further
// with an explicit annotation:
throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ explicit annotation
  .catch((n: number) =&gt; handleWhenRejected(n))
</code></pre>

<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<pre><code class="js">throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ defensive annotation
  .catch((n: mixed) =&gt; {
    if (typeof n === 'number') {
      handleWhenRejected(n);
    } else {
      // Reports misbehavior to an imaginary observability service
      tracker.increment('throwNumber.unexpected_input');
    }
  });
</code></pre>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lenses & Composition]]></title>
    <link href="https://blog.jez.io/lens-composition/"/>
    <updated>2018-02-05T23:07:37-08:00</updated>
    <id>https://blog.jez.io/lens-composition</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>A lens is really just a function <code>a -&gt; b</code> that we represent
backwards<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and with an extra <code>Functor f</code> parameter lying
around:</p>

<pre><code>type Lens' a b = Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
</code></pre>

<p><strong>What does this mean for function composition?</strong></p>

<!-- more -->


<p>Normal function composition looks like this:</p>

<pre><code class="haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)

f :: a -&gt; b
g :: b -&gt; c

g . f :: (a -&gt; c)
</code></pre>

<p>We often have to read code that looks like this:</p>

<pre><code class="haskell">g . f $ x
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then run <code>f</code> on it, and run <code>g</code> after that.&rdquo;
This sentence reads opposite from how the code reads!</p>

<p>What about for lenses? Here we have <code>f'</code> and <code>g'</code> which behave similarly
in some sense to <code>f</code> and <code>g</code> from before:</p>

<pre><code class="haskell">f' :: Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
--  ‚âà a -&gt; b
g' :: Functor f =&gt; (c -&gt; f c) -&gt; (b -&gt; f b)
--  ‚âà b -&gt; c

f' . g' :: Functor f =&gt; (c -&gt; f c) -&gt; (a -&gt; f a)
--       ‚âà a -&gt; c
</code></pre>

<p>In the lens world, <code>^.</code> behaves kind of like a flipped <code>$</code> that turns
lenses into getters, which lets us write code like this:</p>

<pre><code class="haskell">x ^. f' . g'
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then get <code>f'</code> from it, then get <code>g'</code> after
that.&rdquo; The sentence reads just like the code!</p>

<p>This is pretty cool, because it means that lenses (which are
&ldquo;functional&rdquo; getters) read almost exactly like property access (which
are &ldquo;imperative&rdquo; getters). Same concise syntax, but with an elegant
semantics.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m exaggerating a bit here üòÖ To see what I <em>really</em> mean, see <a href="/lens-intuition">this post</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABTs in Haskell]]></title>
    <link href="https://blog.jez.io/abts-in-haskell/"/>
    <updated>2017-11-11T22:31:41-08:00</updated>
    <id>https://blog.jez.io/abts-in-haskell</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning and using Haskell on-and-off for the past couple
of years. One of my early complaints was that I couldn&rsquo;t find a good
library for working with variables and binding that used locally
nameless terms. Recently though, I found <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which
checks all my previously unfilled boxes.</p>

<p>Abstract binding trees (or ABTs) are abstract syntax trees (ASTs)
augmented with the ability to capture the binding structure of a
program. ABTs are one of the first topics we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles
of Programming Languages</a> because variables show up in every
interesting feature of a programming language.</p>

<p>I recently wrote at length about the various strategies for dealing with
<a href="/variables-and-binding/">variables and binding</a> and their implementations. While it&rsquo;s a good
exercise<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to implement ABTs from scratch, in most cases I&rsquo;d
rather just use a library. In school we used <a href="https://github.com/robsimmons/abbot"><code>abbot</code></a>, which is an ABT
library for Standard ML. For tinkering with Haskell, I recently found
<a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which provides a similar API.</p>

<p>I gave it a test drive while learning how to implement type inference
for the simply-typed lambda calculus (STLC) and was rather pleased. The
source code for my STLC inference program is <a href="https://github.com/jez/stlc-infer">on GitHub</a> if
you&rsquo;re looking for an example of <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a> in action.</p>

<p>To pluck a few snippets out, here&rsquo;s the definition of STLC terms:</p>

<pre><code class="haskell">data Term
  = Tvar Tvar
  | Tlam (Bind Tvar Term)
  | Tapp Term Term
  | Tlet Term (Bind Tvar Term)
  | Tz
  | Ts Term
  | Tifz Term Term (Bind Tvar Term)
  | Tbool Bool
  | Tif Term Term Term
  deriving (Show, Generic, Typeable)
</code></pre>

<p><code>Bind</code> is the abstract type for locally nameless terms that bind a
variable. It&rsquo;s cool in Haskell (compared to SML) because the compiler
can automatically derive the locally nameless representation from this
data type definition (with help from the <code>unbound-generics</code> library).</p>

<p>Here&rsquo;s what it looks like in use:</p>

<pre><code class="haskell">-- (This is a snippet from the type inference code)
constraintsWithCon ctx (Tlam bnd) = do
  -- 'out' the ABT to get a fresh variable
  -- (x used to be "locally nameless", but now has a globally unique name)
  (x, e) &lt;- unbind bnd
  -- Generate fresh type variable to put into the context
  t1 &lt;- Cvar &lt;$&gt; fresh (string2name "t1_")
  let ctx' = Map.insert x t1 ctx
  t2 &lt;- constraintsWithCon ctx' e
  return $ Carrow t1 t2
</code></pre>

<p>Apart from <code>out</code> being called <code>unbind</code> and <code>into</code> being called <code>bind</code>,
the API is pretty similar. Also, unlike <code>abbot</code>, which required a
standalone build step to generate SML code, <code>unbound-generics</code> uses the
Haskell&rsquo;s <code>derive Generic</code> to bake the code generation for capture
avoiding substitution and alpha equivalence right into the compiler. All
in all, <code>unbound-generics</code> is really pleasant to use!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In fact, it&rsquo;s hw1 for 15-312! If you&rsquo;re curious, check out the <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/hws/assn1.pdf">handout</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tests, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/tests-types-correctness/"/>
    <updated>2017-09-10T16:50:36-07:00</updated>
    <id>https://blog.jez.io/tests-types-correctness</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Monitoring tools</strong> prove that incorrect behavior hasn&rsquo;t occurred
<em>yet</em>, or provide us with a concrete counter example when it
happens.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! The fourth might seem not helpful, but is often
better than nothing, and in many situations can be leveraged into making
powerful claims. None of the above are as universally applicable as the
last: doing the proof ourself, but it&rsquo;s also usually the most error prone.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, tests are rarely (if
ever) exhaustive, and frequently allow bugs to pass through to
production. This is why testing, types, and monitoring are
complementary&mdash;one is not a substitute for another.</p>

<p>The hardest part of writing high-quality software is ensuring that it
runs without bugs. The more tools we have in our arsenal to combat
incorrectness, the easier it is to write code for the long term.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Recall that raising an exception is logically the same as throwing a value to a continuation and carrying out a <a href="/continuations-notes/">proof by contradiction</a>!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If, Else, & Purity]]></title>
    <link href="https://blog.jez.io/if-else-purity/"/>
    <updated>2017-08-31T22:38:43-07:00</updated>
    <id>https://blog.jez.io/if-else-purity</id>
    <content type="html"><![CDATA[<p>I prefer to let the language I&rsquo;m using think on my behalf as much as
possible. Ideally, the language is rich enough that the proof of
correctness is inherent in the code I&rsquo;ve written. Even when I use
looser languages, these principled languages inform the structure of my
code. To make this a bit more let&rsquo;s turn our focus to <code>if</code>, <code>else</code>, and
purity.</p>

<!-- more -->


<p>A cool way to understand purity is using what&rsquo;s known as a &ldquo;modal
separation.&rdquo; This is a really fancy way to say that we have
<strong>expressions</strong> which are pure and always evaluate to a value, alongside
<strong>commands</strong> which are impure and are executed for their side effects.
If you&rsquo;ve ever used Haskell, you&rsquo;re already familiar with this
notion&mdash;we only need <code>do</code> notation when we need to write impure (or
&ldquo;monadic&rdquo;) code.</p>

<p>In an expression language, every <code>if</code> <em>must</em> have an <code>else</code>; for the
entire <code>if</code> expression to be used as a value, both branches must in turn
evaluate to values. It&rsquo;s only when we move to a language with commands
where it makes sense to allow omitting the <code>else</code> branch. <code>if</code>
expressions are not some abstract concept; chances are you&rsquo;ve
encountered them under the name &ldquo;the ternary operator.&rdquo;</p>

<p>An <code>if</code> <em>statement</em> (as opposed to an <code>if</code> expression) is a command;
it&rsquo;s useful for running side-effectful code. Sometimes, we don&rsquo;t want
one of the branches to have any side effects (for example, because the
state of the world doesn&rsquo;t need to be changed). Languages with commands
allow omitting the <code>else</code>.</p>

<p>What does this mean for us? Since expression languages form the basis
for purity, every pure function can be written where the <code>if</code> is matched
with an <code>else</code>. Put another way, an unmatched <code>if</code> is a likely indicator
that the code I&rsquo;ve written is impure.</p>

<p>This makes me more aware of when I&rsquo;m dealing with impure code. For
example, I might want to factor out as much of the pure code into a
separate helper function. There&rsquo;s a time and a place for impure code.
But since pure code is more composable and easier to test, it&rsquo;s best to
factor the impure code out whenever possible.</p>

<p>In a principled language, there&rsquo;s a distinction between <code>if</code> expressions
and <code>if</code> statements. On the other hand, some language only have one, or
they blur the line between the two. We can draw upon our experiences
with languages that are rigorous about minutia like this to better
inform how we write clean code.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
</feed>
