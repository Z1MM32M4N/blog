<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: fragment | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/fragment/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2021-06-05T04:37:18-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Search Down the Stack]]></title>
    <link href="https://blog.jez.io/search-down-the-stack/"/>
    <updated>2020-06-06T19:08:20-05:00</updated>
    <id>https://blog.jez.io/search-down-the-stack</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve found it useful to search though the source code of things lower in
the stack lately. For example I saw an error something like this at work
recently:</p>

<pre><code>‚ùØ rake test
symbol lookup error: /home/jez/.../foo.so: undefined symbol bar
</code></pre>

<p>I was pretty confused. Modulo the names of commands and files, this was
pretty much all the output.</p>

<p>So I started searching. First I searched through my codebase for
<code>"symbol lookup error"</code>, but found nothing. Surely that string exists
somewhere. That must mean it&rsquo;s coming from lower in the stack?</p>

<p>The next level lower would mean third party Ruby gems. At work we use
Bundler <a href="https://bundler.io/v2.0/guides/deploying.html#manual-deployment">in a mode</a> where it installs all gems into a single
convenient folder in the current directory: <code>./vendor/bundle/</code>. But a
search in that folder turned up nothing again. So&hellip; further down?</p>

<p>If it&rsquo;s not from the app, and not from the gems, then maybe it&rsquo;s in Ruby
itself? I cloned the <a href="https://github.com/ruby/ruby">Ruby source</a>, checked out the <a href="https://github.com/ruby/ruby/tree/v2_6_5">version tag</a> for
the Ruby version we&rsquo;re running, and searched for <code>"symbol lookup error"</code>
once again. And again nothing!</p>

<p>There&rsquo;s still plenty of layers below us, so let&rsquo;s keep peeling them
back. Ruby is written in C, which means we should check libc next (the C
standard library). There are multiple libc implementations, but I was
running this on Linux, so let&rsquo;s check GNU libc (glibc). glibc is <a href="https://www.gnu.org/software/libc/sources.html">isn&rsquo;t
on GitHub</a>, but that&rsquo;s not a huge deterrant. Here&rsquo;s the search:</p>

<pre><code>‚ùØ rg -t c 'symbol lookup error'
dl-lookup.c
876:      _dl_signal_cexception (0, &amp;exception, N_("symbol lookup error"));
</code></pre>

<p>That&rsquo;s a bit of a smoking gun! After all those layers, we found our
error message in libc itself. (This gave me a lot of leads on the problem
at hand, e.g., I had definitely ruled out a problem in my app or its
dependencies, and I was thinking, &ldquo;probably something is wrong about
how <code>foo.so</code> was compiled.&rdquo; There&rsquo;s a fun story here about how Ruby C
extensions work, but that&rsquo;s a <a href="/linkers-ruby-c-exts/">tangent for another time</a>.)</p>

<p>My point is that <a href="https://livegrep.com/search/linux">searching all the code</a> is a super power, and it
applies to more than just searching the code we&rsquo;ve written. What a
blessing that the tools we&rsquo;re building on, like Ruby and GNU libc, are
all open source!</p>

<p>The next time it looks like a problem is outside the scope of your app&rsquo;s
code, maybe try searching the code:</p>

<ul>
<li>inside your gems or packages!</li>
<li>inside your language&rsquo;s standard library!

<ul>
<li>Some IDEs will even let you jump-to-def into core libraries üòÆ</li>
</ul>
</li>
<li>inside your language&rsquo;s runtime

<ul>
<li>(if you&rsquo;re using a language with a runtime like Ruby or Python or
even <a href="https://github.com/v8/v8">JavaScript</a>)</li>
</ul>
</li>
<li>powering your operating system kernel! <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
</ul>


<p>For me, I&rsquo;ve already noticed it help save me time and give me more
context when I&rsquo;m debugging.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>This might sound daunting, but sometimes it can be useful. A good thing to keep in mind: every <strong>system call</strong> like <code>open(2)</code> or <code>write(2)</code> or <code>select(2)</code> (and every other function from section 2 of the man pages) is really just a way for your program to request that the operating system do something; knowing that can be a decent place to start traipsing through code in the operating system.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prefer .then() over .catch()]]></title>
    <link href="https://blog.jez.io/prefer-then-over-catch/"/>
    <updated>2018-05-31T15:58:52-07:00</updated>
    <id>https://blog.jez.io/prefer-then-over-catch</id>
    <content type="html"><![CDATA[<p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<pre><code class="js Bad code; don't do this">// "Success" and "failure" types (definitions omitted)
import type {OkResult, ErrResult} from 'src/types';

const doSomething = (): Promise&lt;OkResult&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve(...) when it worked, but
    // cal reject(...) when it failed.
  });
};

doSomething
  .then((res) =&gt; ...)
  .catch((err) =&gt; ...)
</code></pre>

<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<pre><code class="js">type ErrResult = string;
</code></pre>

<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<pre><code class="js">// number, not a string!
reject(42);
</code></pre>

<p>nor from doing this:</p>

<pre><code class="js">// boolean, not a string!
.catch((err: boolean) =&gt; ...);
</code></pre>

<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<pre><code class="js Better code than before">// Helper function for exhaustiveness.
// See here: https://blog.jez.io/flow-exhaustiveness/
import {absurd} from 'src/absurd';

import type {OkResult, ErrResult} from 'src/types';

// Use a union type to mean "success OR failure"
type Result =
  | {|tag: 'ok', val: OkResult|}
  | {|tag: 'err', val: ErrResult|};

//     Use our new union type ‚îÄ‚îÄ‚îê
const doSomething = (): Promise&lt;Result&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve({tag: 'ok',  val: ...}) when it worked, and
    // call resolve({tag: 'err', val: ...}) when it failed
  });
};

doSomething
  // Use a switch statement in the result:
  .then((res) =&gt; {
    switch (res.tag) {
      case 'ok':
        // ...
        break;
      case 'err':
        // ...
        break;
      default:
        // Guarantees we covered all cases.
        absurd(res);
        break;
    }
  })
</code></pre>

<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<pre><code class="js">// If I know that throwNumber will always call `reject` with a
// number, I can stop the loose types from propagating further
// with an explicit annotation:
throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ explicit annotation
  .catch((n: number) =&gt; handleWhenRejected(n))
</code></pre>

<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<pre><code class="js">throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ defensive annotation
  .catch((n: mixed) =&gt; {
    if (typeof n === 'number') {
      handleWhenRejected(n);
    } else {
      // Reports misbehavior to an imaginary observability service
      tracker.increment('throwNumber.unexpected_input');
    }
  });
</code></pre>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lenses & Composition]]></title>
    <link href="https://blog.jez.io/lens-composition/"/>
    <updated>2018-02-05T23:07:37-08:00</updated>
    <id>https://blog.jez.io/lens-composition</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>A lens is really just a function <code>a -&gt; b</code> that we represent
backwards<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and with an extra <code>Functor f</code> parameter lying
around:</p>

<pre><code>type Lens' a b = Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
</code></pre>

<p><strong>What does this mean for function composition?</strong></p>

<!-- more -->


<p>Normal function composition looks like this:</p>

<pre><code class="haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)

f :: a -&gt; b
g :: b -&gt; c

g . f :: (a -&gt; c)
</code></pre>

<p>We often have to read code that looks like this:</p>

<pre><code class="haskell">g . f $ x
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then run <code>f</code> on it, and run <code>g</code> after that.&rdquo;
This sentence reads opposite from how the code reads!</p>

<p>What about for lenses? Here we have <code>f'</code> and <code>g'</code> which behave similarly
in some sense to <code>f</code> and <code>g</code> from before:</p>

<pre><code class="haskell">f' :: Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
--  ‚âà a -&gt; b
g' :: Functor f =&gt; (c -&gt; f c) -&gt; (b -&gt; f b)
--  ‚âà b -&gt; c

f' . g' :: Functor f =&gt; (c -&gt; f c) -&gt; (a -&gt; f a)
--       ‚âà a -&gt; c
</code></pre>

<p>In the lens world, <code>^.</code> behaves kind of like a flipped <code>$</code> that turns
lenses into getters, which lets us write code like this:</p>

<pre><code class="haskell">x ^. f' . g'
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then get <code>f'</code> from it, then get <code>g'</code> after
that.&rdquo; The sentence reads just like the code!</p>

<p>This is pretty cool, because it means that lenses (which are
&ldquo;functional&rdquo; getters) read almost exactly like property access (which
are &ldquo;imperative&rdquo; getters). Same concise syntax, but with an elegant
semantics.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m exaggerating a bit here üòÖ To see what I <em>really</em> mean, see <a href="/lens-intuition">this post</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABTs in Haskell]]></title>
    <link href="https://blog.jez.io/abts-in-haskell/"/>
    <updated>2017-11-11T22:31:41-08:00</updated>
    <id>https://blog.jez.io/abts-in-haskell</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning and using Haskell on-and-off for the past couple
of years. One of my early complaints was that I couldn&rsquo;t find a good
library for working with variables and binding that used locally
nameless terms. Recently though, I found <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which
checks all my previously unfilled boxes.</p>

<p>Abstract binding trees (or ABTs) are abstract syntax trees (ASTs)
augmented with the ability to capture the binding structure of a
program. ABTs are one of the first topics we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles
of Programming Languages</a> because variables show up in every
interesting feature of a programming language.</p>

<p>I recently wrote at length about the various strategies for dealing with
<a href="/variables-and-binding/">variables and binding</a> and their implementations. While it&rsquo;s a good
exercise<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to implement ABTs from scratch, in most cases I&rsquo;d
rather just use a library. In school we used <a href="https://github.com/robsimmons/abbot"><code>abbot</code></a>, which is an ABT
library for Standard ML. For tinkering with Haskell, I recently found
<a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which provides a similar API.</p>

<p>I gave it a test drive while learning how to implement type inference
for the simply-typed lambda calculus (STLC) and was rather pleased. The
source code for my STLC inference program is <a href="https://github.com/jez/stlc-infer">on GitHub</a> if
you&rsquo;re looking for an example of <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a> in action.</p>

<p>To pluck a few snippets out, here&rsquo;s the definition of STLC terms:</p>

<pre><code class="haskell">data Term
  = Tvar Tvar
  | Tlam (Bind Tvar Term)
  | Tapp Term Term
  | Tlet Term (Bind Tvar Term)
  | Tz
  | Ts Term
  | Tifz Term Term (Bind Tvar Term)
  | Tbool Bool
  | Tif Term Term Term
  deriving (Show, Generic, Typeable)
</code></pre>

<p><code>Bind</code> is the abstract type for locally nameless terms that bind a
variable. It&rsquo;s cool in Haskell (compared to SML) because the compiler
can automatically derive the locally nameless representation from this
data type definition (with help from the <code>unbound-generics</code> library).</p>

<p>Here&rsquo;s what it looks like in use:</p>

<pre><code class="haskell">-- (This is a snippet from the type inference code)
constraintsWithCon ctx (Tlam bnd) = do
  -- 'out' the ABT to get a fresh variable
  -- (x used to be "locally nameless", but now has a globally unique name)
  (x, e) &lt;- unbind bnd
  -- Generate fresh type variable to put into the context
  t1 &lt;- Cvar &lt;$&gt; fresh (string2name "t1_")
  let ctx' = Map.insert x t1 ctx
  t2 &lt;- constraintsWithCon ctx' e
  return $ Carrow t1 t2
</code></pre>

<p>Apart from <code>out</code> being called <code>unbind</code> and <code>into</code> being called <code>bind</code>,
the API is pretty similar. Also, unlike <code>abbot</code>, which required a
standalone build step to generate SML code, <code>unbound-generics</code> uses the
Haskell&rsquo;s <code>derive Generic</code> to bake the code generation for capture
avoiding substitution and alpha equivalence right into the compiler. All
in all, <code>unbound-generics</code> is really pleasant to use!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In fact, it&rsquo;s hw1 for 15-312! If you&rsquo;re curious, check out the <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/hws/assn1.pdf">handout</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tests, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/tests-types-correctness/"/>
    <updated>2017-09-10T16:50:36-07:00</updated>
    <id>https://blog.jez.io/tests-types-correctness</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Monitoring tools</strong> prove that incorrect behavior hasn&rsquo;t occurred
<em>yet</em>, or provide us with a concrete counter example when it
happens.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! The fourth might seem not helpful, but is often
better than nothing, and in many situations can be leveraged into making
powerful claims. None of the above are as universally applicable as the
last: doing the proof ourself, but it&rsquo;s also usually the most error prone.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, tests are rarely (if
ever) exhaustive, and frequently allow bugs to pass through to
production. This is why testing, types, and monitoring are
complementary&mdash;one is not a substitute for another.</p>

<p>The hardest part of writing high-quality software is ensuring that it
runs without bugs. The more tools we have in our arsenal to combat
incorrectness, the easier it is to write code for the long term.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Recall that raising an exception is logically the same as throwing a value to a continuation and carrying out a <a href="/continuations-notes/">proof by contradiction</a>!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
