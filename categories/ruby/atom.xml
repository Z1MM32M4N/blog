<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/ruby/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2020-01-05T04:04:29-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Intersection Types in Sorbet are Surprisingly Common]]></title>
    <link href="https://blog.jez.io/intersection-types-common/"/>
    <updated>2020-01-04T19:50:32-06:00</updated>
    <id>https://blog.jez.io/intersection-types-common</id>
    <content type="html"><![CDATA[<p>Conventional knowledge is that union types are common and intersection
types are rare. But actually that&rsquo;s not the case—intersection types
show up in nearly every program Sorbet type checks thanks to control
flow.</p>

<p><a href="https://sorbet.org/docs/union-types">Union types</a> in Sorbet are incredibly common, which should be no
surprise. In Sorbet, <code>T.nilable(...)</code> is sugar for <code>T.any(NilClass,
...)</code>. <code>T.nilable</code> shows up all over the place and probably catches more
bugs than any other feature in Sorbet.</p>

<p>Sorbet also has <a href="https://sorbet.org/docs/intersection-types">intersection types</a>. While union types mean &ldquo;either
this or that,&rdquo; intersection types mean &ldquo;both this and that.&rdquo; On first
glance, intersection types seem like some super niche feature which only
benefits a handful of programs. In Stripe&rsquo;s Ruby monorepo, the strings
<code>T.any</code> and <code>T.nilable</code> occur nearly 300 times more than <code>T.all</code> does.</p>

<p>But those numbers hide something critical: intersection types power
Sorbet&rsquo;s <a href="https://sorbet.org/docs/flow-sensitive">control flow-sensitive typing</a>. They&rsquo;re actually present in
every Ruby program, but just a little hard to spot. Let&rsquo;s look at how
pervasive they are with a few examples:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class Parent; end
class Child &lt; Parent; end

sig {params(x: Parent).void}
def example1(x)
  case x
  when Child
    T.reveal_type(x) # Revealed type: `Child`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>Here <code>x</code> starts out having type <code>Parent</code>, but inside the <code>case</code>
statement Sorbet treats <code>x</code> as having the more specific type <code>Child</code>.
There&rsquo;s no <code>T.all</code> in sight, but that&rsquo;s because it&rsquo;s hiding. Sorbet
doesn&rsquo;t just throw away the fact that it knew <code>x &lt;: Parent</code>. Instead, it
uses <code>T.all</code> to update its type for <code>x</code> to <code>T.all(Parent, Child)</code>.</p>

<p><code>T.all(Parent, Child)</code> is equivalent to <code>Child</code> because <code>Child</code> is a
subtype of <code>Parent</code>. If types represent sets of values, then the set of
values represented by <code>Child</code> is a subset of the set of values
represented by <code>Parent</code>, so the intersection of those two sets would
just leave <code>Child</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Sorbet attempts to simplify a large type to a smaller, equivalent type
when it can for two reasons:</p>

<ul>
<li><p><strong>Usability</strong> – Most users don&rsquo;t know that <code>T.all</code> means &ldquo;intersection
type&rdquo; or even what intersection types are. (And even those who do
still end up drawing Venn diagrams from time to time!) It only gets
more complicated when <code>T.all</code>s and <code>T.any</code>s nest inside each other.</p>

<p>Meanwhile, <code>Child</code> is a super easy type to understand, and leads to
nice, short error messages.</p></li>
<li><p><strong>Performance</strong> – Checking whether one type is a subtype of another is
a super common operation, so it has to be fast. By collapsing
<code>T.all(Parent, Child)</code> to <code>Child</code>, Sorbet does at least half as much
work when checking subtyping (probably more, because of some common
path optimizations).</p>

<p>When this simplification happens, Sorbet even skips an allocation
entirely. Cnstructing <code>T.all(Parent, Child)</code> in Sorbet short
circuits and returns a reference to the already allocated <code>Child</code> type
that was passed as an argument (with ownership tracked via
<code>std::shared_ptr</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>).</p></li>
</ul>


<p>Let&rsquo;s look at another example of control flow:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class A; end
class B; end

sig {params(a_or_b: T.any(A, B)).void}
def example2(a_or_b)
  case a_or_b
  when A
    T.reveal_type(a_or_b) # Revealed type: `A`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>This example method accepts either <code>A</code> or <code>B</code> (<code>T.any(A, B)</code>) and then
branches on whether <code>a_or_b</code> is an instance of <code>A</code>. Again: Sorbet
doesn&rsquo;t throw away that it knows <code>a_or_b &lt;: T.any(A, B)</code>. Instead it
updates its knowledge of the type of <code>a_or_b</code> using <code>T.all</code> to get
<code>T.all(T.any(A, B), A)</code>. Realizing that this is equivalent to <code>A</code> is a
bit trickier:</p>

<pre><code class="ruby">T.all(T.any(A, B), A)

# Distribute
T.any( T.all(A, A) , T.all(B, A) )

# T.all(A, A) is just A (idempotence)
T.any( A , T.all(B, A) )

# A and B are classes (not mixins) and neither inherits the other.
# It's impossible to have a value of that type, so it's bottom:
T.any( A , T.noreturn )

# bottom is the identity of union
A
</code></pre>

<p>You can start to see how usability and performance and might get a
little out of hand if Sorbet didn&rsquo;t keep attempting to simplify things!
The cumulative effect of all the control flow in a program would result
in huge, unweidly types.</p>

<p>Until now you could claim that I&rsquo;ve been hyping up intersection types as
the solution to problems that were self-imposed. That if we just
invented some other method for modeling control flow, it would have been
naturally usable or naturally performant, and we wouldn&rsquo;t have had
problems in the first place. So next let&rsquo;s look at some examples to see
why intersection types really are the most natural solution:</p>

<pre><code class="ruby">module I1
  def foo1; end
end
module I2
  def foo2; end
end

sig {params(x: I1).void}
def example3(x)
  x.foo1  # Works outside
  case x
  when I2
    x.foo1  # Should (and does) still work inside
    x.foo2
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A">→ View on sorbet.run</a></p>

<p>Unlike in the other examples, this is the first example where had we
tried to implement control-flow-sensitive typing by throwing away the
old type and using the new type instead it wouldn&rsquo;t have worked. The key
thing to notice: this example uses modules. Outside the <code>case</code> of course
calling <code>x.method_from_1</code> works because <code>x</code> starts out at type <code>I1</code>. But
if we treated <code>x</code> as only <code>I2</code> inside the <code>when I2</code>, we&rsquo;d start
reporting an error for calling <code>x.method_from_1</code> because it doesn&rsquo;t
exist on <code>I2</code>.</p>

<p>Unlike intersecting unrelated classes (our <code>T.all(B, A)</code> example from
earlier), intersecting unrelated modules does&rsquo;t collapse to
<code>T.noreturn</code>. There&rsquo;s nothing stopping some class from including both
<code>I1</code> and <code>I2</code>. Instances of that class would be values of type
<code>T.any(I1, I2)</code>:</p>

<pre><code class="ruby">class SomeClass
  include I1
  include I2
end

# This type assertion is okay:
T.let(SomeClass.new, T.all(I1, I2))
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))">→ View on sorbet.run</a></p>

<p>So at least for implementing certain cases of flow sensitive typing,
we&rsquo;ll <em>need</em> intersection types anyways. Then for these certain cases
we&rsquo;d incur the usability and performance problems we discovered earlier
and have to solve them.</p>

<p>But more than that, intersection types are fundamentally easier to work
with compared to some ad hoc approach to flow sensitive typing. Type
system bugs are weird. It&rsquo;s frquently harder to figure out whether the
current behavior is buggy in the first place than it is to find the
cause!</p>

<p>In that light, intersection types present an elegant, robust model for
arriving at what the correct behavior <em>should</em> be, independent of what
Sorbet&rsquo;s existing behavior is. It&rsquo;s clear how intersection types
interact with union types, and with subtyping, and with generics, and
with variance, etc.</p>

<p>By repurposing intersection types to model control flow sensitivity,
when things go wrong there&rsquo;s a framework for discovering what&rsquo;s right.</p>

<p>(Speaking of repurposing, intersection types also play an important role
in how Sorbet <a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend">suggests potential method signatures</a>! That&rsquo;s three birds
with one stone.)</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you&rsquo;re not convinced, consider: with <code>T.all(Parent, Child)</code> we should be able to call all the methods on <code>Parent</code> and all the methods on <code>Child</code>. But <code>Child</code> inherits <code>Parent</code>&rsquo;s methods, so any method <code>Parent</code> has will already be on <code>Child</code>. So <code>Child</code> is equivalently good as <code>T.all(Parent, Child)</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you&rsquo;re looking for a good intro to modern C++ things like <code>shared_ptr</code>, I can&rsquo;t recommend <a href="https://berthub.eu/articles/posts/cpp-intro/">this blog post series</a> enough.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What makes type checking Ruby hard?]]></title>
    <link href="https://blog.jez.io/ruby-mutation/"/>
    <updated>2019-12-29T01:29:52-06:00</updated>
    <id>https://blog.jez.io/ruby-mutation</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Mutation makes typechecking Ruby harder than many other programming
languages. Most people will immediately think I mean mutation in the
sense of <code>x += 1</code> or something—that&rsquo;s not what I&rsquo;m referring to. In
fact, that&rsquo;s the easy kind of mutation to model in a type system.</p>

<p>What I mean is that nearly everything worth knowing statically about a
Ruby program involves mutation. Defining a class?</p>

<pre><code class="ruby">class A
end
</code></pre>

<p>That mutates the global namespace of constants. After those lines run,
all code in the project can reference the class <code>A</code>.</p>

<p>Defining a method?</p>

<pre><code class="ruby">class A
  def foo
    puts 'hello'
  end
end
</code></pre>

<p>The method <code>foo</code> is undefined just before the <code>def</code> block (at runtime!),
but defined after—mutation again.</p>

<p>Ruby provides things like <code>attr_reader</code> and <code>attr_accessor</code> to define
getter and setter methods:</p>

<pre><code class="ruby">class B
  attr_reader :foo
end
</code></pre>

<p><code>attr_reader</code> is not a Ruby keyword, contrary to popular belief: it&rsquo;s a
method on the singleton class which takes an argument. It defines an
instance method called <code>foo</code> as a side effect by mutating the class <code>B</code>.</p>

<p>It&rsquo;s the same for mixing modules into classes:</p>

<pre><code class="ruby">module M; end
class C
  include M
end
</code></pre>

<p><code>include</code> is another method disguised like a keyword which mutates the
class&rsquo;s list of ancestors.</p>

<p>One of my least favorite Ruby features: you can <strong>redefine</strong> (not
override) a method:</p>

<pre><code class="ruby">class D
  attr_reader :foo
  alias_method :old_foo, :foo
  def foo
    puts 'Calling D#foo'
    old_foo
  end
end
</code></pre>

<p>Because <code>D#foo</code> is defined by the <code>attr_reader</code> line, the subsequent
<code>def</code> overwrites it (akin to mutating a local variable, like <code>x += 1</code>).
Oh and that <code>alias_method</code>? Another method looking like a keyword which
mutates the class.</p>

<p>Even the way libraries work in Ruby is powered by mutation:</p>

<pre><code class="ruby">require 'some_gem'
</code></pre>

<p><code>require</code> is a method (again, not a keyword) that looks up and runs
arbitrary Ruby code, whose result we discard. It&rsquo;s only convention that
the primary side effect of the <code>require</code>&rsquo;d code is to mutate the global
namespace, defining more classes and methods.</p>

<h2>DSLs and metaprogramming</h2>

<p>It would be one thing if Ruby constrained the places where this mutation
could occur. But instead, it provides first-class support for these
features anywhere Ruby code runs. Everything we&rsquo;ve seen so far can be
hidden behind arbitrary computation at runtime:</p>

<ul>
<li>With <code>Module#const_set</code>, a Ruby program can compute an arbitrary name
and use it to create new constant at runtime.</li>
<li><code>Module#define_method</code> does the same for methods.</li>
<li>Again <code>require</code> is a method, so it can occur wherever other methods
are called.</li>
</ul>


<p>It&rsquo;s not uncommon to see Ruby libraries embrace this rather than avoid
it (Rails definitely does). Ruby programs frequently build up large
abstractions and do tons of computation which at the end of the day
result in a <code>define_method</code> or a <code>const_set</code>.</p>

<p>Rubyists call this &ldquo;metaprogramming&rdquo; or &ldquo;building DSLs&rdquo; but I call it
like I see it: mutation.</p>

<h2>Modeling mutation</h2>

<p>Type systems are notoriously bad at modelling this kind of mutation.
Look at other typed, object-oriented languages: Java, Scala, C++, &hellip;
Each of these languages <strong>forbids</strong> this kind of mutation. (Whether
because it&rsquo;s hard to implement support for it or because they&rsquo;re making
a value judgement is beyond me.)</p>

<p>So how can Sorbet can model this? Mostly, it just cheats. Err,
&ldquo;approximates.&rdquo; From my experience working on the Sorbet team, I can
think of three main ways it cheats.</p>

<p>First, Sorbet assumes that if a class or method might exist, it does
exist, and universally throughout a project.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It pretends
that all <code>include</code>, <code>extend</code>, and <code>alias_method</code> statements in a class
run first, before all other code at the top-level of that class. It
restricts method redefinitions—the old and new methods must take the
same number and kinds of arguments. And it restricts <code>alias_method</code>: you
can only alias to a method on your class, not to a parent class. Sorbet
makes no attempt to model <code>undef_method</code> at all (another
method-not-keyword!).</p>

<p>Second, Sorbet cheats by implementing heuristics for the most common
DSLs. To support <code>attr_reader</code>, Sorbet says, &ldquo;Hey, this method call
happens to be to some method named <code>attr_reader</code>. I&rsquo;m not sure if it&rsquo;s
to <code>Module#attr_reader</code> or to some other <code>attr_reader</code> definition or to
any definition at all, but it&rsquo;s provided with a single Symbol argument,
the result is discarded, and it&rsquo;s called at the syntactic top-level of a
class, so I bet that it is a call to <code>Module#attr_reader</code>.&rdquo; It&rsquo;s similar
for many other popular DSLs: it makes decent educated guesses.</p>

<p>But after all that, it sort of gives up. Sorbet makes no attempts to
work backwards from a call to <code>define_method</code> or <code>const_set</code> inside a
method body to learn that a class or method might have been defined
somewhere. Instead, it cheats one last time and uses runtime information.</p>

<p>As a part of initializing a Sorbet project, Sorbet <code>require</code>s (read:
executes) as much code in a project as it can: all the gems listed in
the Gemfile and all the Ruby files in the current folder. Afterwards, it
can see the result of all that&rsquo;s been mutated thus far (via reflection)
and serialize what it sees into <a href="https://sorbet.org/docs/rbi">RBI files</a> to convey what it saw to the
static checker. This is still imperfect (it completely misses things
that are defined after <code>require</code> time), but empirically it finds most of
the remaining undiscovered definitions.</p>

<h2>Beyond mutation</h2>

<p>Don&rsquo;t get me wrong, those approximations are really useful and
effective. But really, the way Sorbet handles mutation in a codebase is
by incentivicing people to get rid of it.</p>

<ul>
<li><p>Sorbet can type check a project in seconds, but it takes minutes to
re-generate all RBIs files. When Sorbet can see things statically,
there&rsquo;s also a canonical place to write a type annotation for it.</p></li>
<li><p>It&rsquo;s a much better experience to click &ldquo;Go to Definition&rdquo; and jump to
the actual source definition rather than to an auto-generated RBI
file.</p></li>
<li><p>And arguably, if it&rsquo;s easy for Sorbet to understand what&rsquo;s defined and
where, it&rsquo;s easier for a programmer to understand. Understandable code
lets people iterate faster, is less brittle, and harder to break by
accident.</p></li>
</ul>


<p>Programming languages are tools to change and structure the way we
think. In the long run, all code can be changed. We adopt type systems
specifically to help guide these changes, which <a href="https://blog.jez.io/on-language-choice/">I&rsquo;ve touched on
before</a>. When it comes to mutation in Ruby, Sorbet makes a solid effort
to model the helpful parts, while providing guide rails and suggestions
to deal with the rest.</p>

<hr />

<h2>Appendix A: By comparison with typed JavaScript</h2>

<p>You might say, &ldquo;the things that you&rsquo;re talking about aren&rsquo;t unique to
Ruby! It&rsquo;s the same for all dynamic programming languages!&rdquo; But is that
true in practice?</p>

<p>Let&rsquo;s compare our Ruby snippets from before with JavaScript.</p>

<p>Ruby:</p>

<pre><code class="ruby">class A
  def self.my_dsl(name)
    define_method(name) do; end
  end
end
</code></pre>

<p>JavaScript:</p>

<pre><code class="js">class A {
  static myDsl(name) {
    this.prototype[name] = function() {}
  }
}
</code></pre>

<p>First I&rsquo;ll point out: the mutation becomes way more obvious in the
JavaScript program! But second: both TypeScript and Flow report static
errors on this program. They both complain that there&rsquo;s no type
annotation declaring that it&rsquo;s ok to treat <code>this.prototype</code> as if it
were a key-value mapping.</p>

<p>The fact that both Flow and TypeScript report an error here speak to how
common this idiom is in practice. It&rsquo;s not common, and they&rsquo;d rather not
encourage programs like this, so they forbid it.</p>

<p>Here&rsquo;s another example, first in Ruby:</p>

<pre><code class="ruby">require 'some_gem'

SomeNamespace::SomeClass.new
</code></pre>

<p>And then in JavaScript:</p>

<pre><code class="js">import someNamespace from 'some_package';

new someNamespace.SomeClass();
</code></pre>

<p>With no RBI files declaring whether <code>SomeNamespace::SomeClass</code> exists
or not, Sorbet will report an error that the class doesn&rsquo;t exist. But in
TypeScript and Flow, the code is just fine, even if there&rsquo;s no type
declaration file. Both can still see that whatever vale is imported will
be bound to the <code>someNamespace</code> variable (even if it&rsquo;s treated as
<code>any</code>).</p>

<p>Sorbet is thus forced to come up with ways to generate RBI files for all
new projects, because without them Sorbet would be crippled: it would
have no way to distinguish between a class name that has actually been
typoed vs one that is typed correctly but for which there&rsquo;s no visible
definition. Meanwhile, TypeScript and Flow work completely fine in new
codebases out of the box.</p>

<p>So my claim is that: no, these problems <strong>are</strong> unique to Ruby, because
the design of the language and the culture of its use so pervasively
promote or require mutation.</p>

<h2>Appendix B: More things that are actually mutation</h2>

<ul>
<li><p><code>freeze</code> (ironic: to prevent mutation on a class or object&hellip; we
mutate it!)</p></li>
<li><p><code>private</code> / <code>private_class_method</code> (not keywords! These are methods
that take a <strong>Symbol</strong>; it just so happens that <code>def foo; end</code> is an
expression that evaluates to the symbol <code>:foo</code>. Which is why there&rsquo;s
both <code>private</code> and <code>private_class_method</code>, because <code>def self.foo; end</code>
also evaluates to <code>:foo</code>, so <code>private def self.foo; end</code> would attempt
to mark an <strong>instance</strong> method named <code>:foo</code> private, even it didn&rsquo;t
exist!)</p></li>
</ul>


<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Frequently this assumption is backed up by an autoloader. For example, Rails includes an autoloader that loads constants lazily on demand, so that the programmer doesn&rsquo;t have to sprinkle require statements throughout the code. But how do autoloads work? Mutation again 🙂.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Virtualenvs]]></title>
    <link href="https://blog.jez.io/ruby-virtualenvs/"/>
    <updated>2014-12-22T12:52:40-06:00</updated>
    <id>https://blog.jez.io/ruby-virtualenvs</id>
    <content type="html"><![CDATA[<p>A while back I found a command that removes all Ruby gems installed on a system
when you&rsquo;re using rbenv. It worked great, so I decided to build on top of it.
After a bit of research, I found a much better solution to the root of my
problems: sandboxing Ruby gems.</p>

<!-- more -->


<h2>Ugh, Ruby&hellip;</h2>

<p>If you&rsquo;re anything like me, you can never do anything right on the first try
using Ruby. At one point, I found myself needing a script to just nuke
everything and start over&hellip; That&rsquo;s when I found Ian Vaughan&rsquo;s <a href="https://gist.github.com/IanVaughan/2902499">script</a> that
magically removes all gems. I was delighted to see that it worked perfectly on
the first try, and went about the rest of my business.</p>

<h2>Modifications</h2>

<p>There were two ways though in which this script&rsquo;s functionality differed from
what I wanted it to do: it always removed <strong>all</strong> gems, and it left behind a
<code>.ruby_version</code> file after it was used, clobbering any file that might have been
there before.</p>

<p>In my updated script, you can specify a list of ruby versions as arguments, and
it will only gems from those versions instead of all of them.  Also, it saves
and restores the value of the old <code>.ruby_version</code> file once it&rsquo;s done.</p>

<p>The new script is available <a href="https://gist.github.com/jez/cc2ba08062c6183a489c">as a fork of the original Gist</a> and also as
a part of of <a href="https://github.com/jez/bin/blob/master/uninstall_gems">my personal bin folder</a>.</p>

<h2>The Underlying Problem: Virtualenv&rsquo;s in Ruby</h2>

<p>After a bit of reflection, I realized I should be trying to solve the underlying
problem: different projects had different dependencies, and gems from one
project were bleeding into gems from another. If you&rsquo;re a Python developer, you
don&rsquo;t have this issue: <a href="http://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a>, <code>pip</code>, and <code>requirements.txt</code>
files make this a non-issue.</p>

<p>After looking into if there existed a similar Ruby solution, I came up with
<a href="http://honza.ca/2011/06/install-ruby-gems-into-virtualenv">this blog post</a> outlining how you can do the exact same thing using
virtualenvs but with Ruby gems! Once again, it needed a little bit of
modification so that everything works again as you&rsquo;d expect when you
<code>deactivate</code>. Add these lines to your virtualenv&rsquo;s <code>postactivate</code> script:</p>

<pre><code class="python $VIRTUAL_ENV/bin/postactivate">export OLD_GEMHOME="$GEM_HOME"
export GEM_HOME="$VIRTUAL_ENV/gems"

export OLD_GEM_PATH="$GEM_PATH"
export GEM_PATH=""

export OLD_PATH="$PATH"
export PATH="$GEM_HOME/bin:$PATH"
</code></pre>

<p>And then add this complementary section to your <code>predeactivate</code> script:</p>

<pre><code class="python $VIRTUAL_ENV/bin/predeactivate">export GEM_HOME="$OLD_GEM_HOME"
unset OLD_GEM_HOME

export GEM_PATH="$OLD_GEM_PATH"
unset OLD_GEM_PATH

export PATH="$OLD_PATH"
unset OLD_PATH
</code></pre>

<p>Now, whenever you install gems, they&rsquo;ll install to the folder
<code>$VIRTUAL_ENV/gems/</code> instead of the system&rsquo;s location, so no gems bleed into
another project!</p>

<h2>One Step Further</h2>

<p>Bringing up this web page, copying those snippets, and pasting them in the two
necessary files every time is a bit tedious. To automate this process, we can
tap into virtualenvwrapper&rsquo;s configurability using hooks. Instead of dropping
those snippets into <code>$VIRTUAL_ENV/bin/{post,prede}activate,</code>, place them in
<code>$VIRTUALENVWRAPPER_HOOK_DIR/{post,prede}activate</code>.</p>

<p>Now every time you <code>workon</code> a virtualenv, the appropriate configuration will
be set up. Note that this means every normal Python project you use will have
this Ruby configuration added (not just the Ruby projects), but that shouldn&rsquo;t
matter because they interoperate nicely. If it&rsquo;s really an issue, you can stick
with the per-virtualenv solution above.</p>

<p>Note: a side effect of this nice sandboxing is that you can normally run
commands without prefixing them with <code>bundle exec ...</code>, which is actually really
handy.</p>
]]></content>
  </entry>
  
</feed>
