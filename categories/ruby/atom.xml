<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/ruby/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2021-05-29T05:11:34-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have Checked Exceptions]]></title>
    <link href="https://blog.jez.io/union-types-checked-exceptions/"/>
    <updated>2021-05-29T01:21:41-07:00</updated>
    <id>https://blog.jez.io/union-types-checked-exceptions</id>
    <content type="html"><![CDATA[<p>People new to Sorbet ask this all the time:</p>

<blockquote><p>Does Sorbet support checked exceptions, like Java?</p></blockquote>

<p>(In fact, this was the <a href="https://youtu.be/odmlf_ezsBo?t=1921">first ever question</a> I was asked at my <a href="https://jez.io/talks/state-of-sorbet-2019/">first
ever conference talk</a>.)</p>

<p>The answer: Sorbet doesn&rsquo;t support checked exceptions, and I don&rsquo;t think
it ever should.</p>

<!-- more -->


<p>Before I dive in: chances are you&rsquo;re reading this because you asked the
question above and someone linked you this. Or maybe you saw the title
and just happened to click. Either way, I&rsquo;m going to take for granted
that you know what I mean by &ldquo;checked exceptions.&rdquo; If you want a quick
refresher, jump down to the <a href="#appendix">Appendix</a> and then come back.</p>

<p>My claim is that checked exceptions are a poor man&rsquo;s ad hoc union types,
that Sorbet has ad hoc union types, and thus that Sorbet doesn&rsquo;t need
checked exceptions.</p>

<p>I&rsquo;ll discuss this claim in three parts:</p>

<ul>
<li>I&rsquo;ll give some background on a key feature of Sorbet&rsquo;s union types,
which are unique compared with union types in many other languages.</li>
<li>I&rsquo;ll describe a translation from checked exceptions in Java to
union-typed returns in Ruby with a concrete example.</li>
<li>I&rsquo;ll give evidence for why the union types approach is better.</li>
</ul>


<p>(I won&rsquo;t hold it against you if you skip to the conclusion and come back
for the lead up. It&rsquo;s what I know I&rsquo;d do too.)</p>

<h2>Background: Sorbet&rsquo;s union types</h2>

<blockquote><p>The throws clause is the only point in the entire Java language that
allows union types. You can tack &ldquo;throws A,B,C&rdquo; onto a method
signature meaning it might throw A or B or C, but outside of the
throws clause you cannot say &ldquo;type A or B or C&rdquo; in Java.</p>

<p>— James Iry, <em><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t
In Java</a></em> (2012)</p></blockquote>

<p>Sorbet supports <a href="https://sorbet.org/docs/union-types">union types</a>. More specifically, Sorbet&rsquo;s union types
are ad hoc: any number of types can be unioned together on demand:</p>

<pre><code class="ruby">sig {returns(T.any(A, B, C))}
def foo; ...; end
</code></pre>

<p>By contrast, many languages with union types require predeclaring a
union&rsquo;s variants, for example in Rust:</p>

<pre><code class="rust">enum AorBorC {
    A(A),
    B(B),
    C(C),
}
</code></pre>

<p>(Rust is not alone here. There are benefits to having an explicit name.
Requiring a name makes it <a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html">harder to use union types to use for
errors</a>. This article is not about Rust, please
don&rsquo;t @ me.)</p>

<p>This &ldquo;on demand&rdquo; characteristic of union types is similar to Java&rsquo;s
<code>throws</code> clause, but more powerful: <code>throws A, B, C</code> is not a type,
while <code>T.any(A, B, C)</code> is. We&rsquo;ll see why that matters below.</p>

<h2>Example: From checked exceptions to union types</h2>

<p>Using Sorbet&rsquo;s ad hoc union types, it&rsquo;s mechanical to convert Java-style
checked exceptions to Sorbet-annotated Ruby. To demonstrate:</p>

<pre><code class="java">Currency parseCurrency(String currencyStr) throws ParseException {
    Currency currency = KNOWN_CURRENCIES.get(currencyStr);
    if (currency == null) {
        throw new ParseException(
          "'" currencyStr + "' is not a valid currency", 0);
    }

    return currency;
}
</code></pre>

<p>This is a somewhat contrived Java method, but it&rsquo;ll be good enough to
demonstrate the concepts.</p>

<p>If <code>parseCurrency</code> is given a string it can&rsquo;t handle, it raises a
<code>ParseException</code>. It declares this with <code>throws</code> because
<code>ParseException</code> is a checked exception. If the currency string is
recognized, it returns some <code>Currency</code> object.</p>

<p>Here&rsquo;s how we&rsquo;d write that in Sorbet:</p>

<pre><code class="ruby"># (0) Ruby's standard library doesn't have `ParseException`,
# so I've re-implemented it.
class ParseError &lt; T::Struct
  const :message, String
  const :offset, Integer
end

# (1) return type + `throws` becomes just `returns`
# (2) Return type uses `T.any`
sig do
  params(currency_str: String)
    .returns(T.any(Currency, ParseError))
end
def parse_currency(currency_str)
  currency = KNOWN_CURRENCIES[currency_str]
  if currency.nil?
    # (3) `throw` becomes `return`
    return ParseError.new(
      message: "'#{currency_str}' is not a valid currency",
      offset: 0
    )
  end

  currency
end
</code></pre>

<p>The important changes:</p>

<ol>
<li>Where Java had a return type and a <code>throws</code> clause, Sorbet just has a
return type.</li>
<li>Sorbet&rsquo;s return type is a union type (<code>T.any(...)</code>). It mentions the Java
method&rsquo;s return type and all the exceptions mentioned in the <code>throws</code>.</li>
<li>Where the Java example uses <code>throw</code>, the Ruby example uses <code>return</code>.</li>
</ol>


<p>The translation isn&rsquo;t complete until we see how the <code>parseCurrency</code>
caller side changes:</p>

<pre><code class="java">Charge createCharge(int amount, String currencyStr) throws ParseException {
    Currency currency = parseCurrency(currencyStr);
    return new Charge(amount, currency);
}
</code></pre>

<p>With Sorbet, this Java snippet becomes:</p>

<pre><code class="ruby">sig do
  params(amount: Integer, currency_str: String)
    .returns(T.any(Charge, ParseError))
end
def create_charge(amount, currency_str)
  currency = parse_currency(currency_str)
  return currency unless currency.is_a?(Currency)

  Charge.new(amount: amount, currency: currency)
end
</code></pre>

<p>As before, the <code>throws</code> clause in Java becomes a union-typed return in Ruby.</p>

<p>The new bit is the explicit <code>return ... unless ...</code>. Whereas uncaught
exceptions implicitly bubble up to the caller, return values only bubble
up if explicitly returned. This is a key benefit of the union types
approach, which brings us to our next section.</p>

<h2>Analysis: Why the union types approach is better</h2>

<p>To recap, Sorbet&rsquo;s union types are ad hoc, much in the same sense as the
classes mentioned in Java&rsquo;s <code>throws</code> clause. When converting from <code>Java</code> to
<code>Ruby</code>, a single, union-typed return takes the place of a separate return
type and <code>throws</code> clause.</p>

<p>First off, this translation preserves the best parts of checked
exceptions:</p>

<ul>
<li><p>A method&rsquo;s failure modes still appear in an <strong>explicit, public API</strong>.</p>

<p>In both Java and Ruby, the method signature behaves as machine-checked
error documentation.</p></li>
<li><p>Ad hoc error specifications enable <strong>low-friction composition</strong>.</p>

<p>In both Java and Ruby, if our method is the first to combine two
methods with unrelated failure modes, there&rsquo;s no ceremony to
predeclare that combination.  Instead, we just mention one more class
in the method&rsquo;s signature.</p></li>
</ul>


<p>What&rsquo;s more, the union types approach has a couple unique benefits:</p>

<ul>
<li><p>As a language feature, <strong>union types are not special</strong>.</p>

<p>Union types are types. Like other types, we can store them in
variables. We can factor common error recovery code into helper
functions. We can map functions returning union types over lists. We
can write type aliases that abbreviate commonly-grouped error classes.
We can&rsquo;t do any of this with checked exceptions, and this is the most
common complaint against them.</p></li>
<li><p>Union types have <strong>call-site granularity</strong>, not method-body
granularity.</p>

<p>The union types approach forces a choice of how to handle errors at
each call site. This is more robust in the face of changing code,
because new call sites should not necessarily inherit the error
handling logic of existing call sites. Just because one
<code>ParseException</code> was uncaught and mentioned in the <code>throws</code> does not
mean all of them should be.</p></li>
</ul>


<p>And finally, let me get out ahead of some common counter arguments.</p>

<blockquote><p>The union types approach requires more typing at the call site!</p></blockquote>

<p>Yep. But I&rsquo;ve already counted this as a blessing, not a curse.</p>

<blockquote><p>But real-world Ruby code already uses exceptions!</p></blockquote>

<p>Yep. But in Java too, the world is already split into checked and
unchecked exceptions. In both Java and Ruby, exceptions are a fact of
life, and you&rsquo;ll always need a way to deal with unexpected exceptions
(e.g., comprehensive tests, automated production alerting, etc.).</p>

<blockquote><p>With checked exceptions, I could handle all the failures at once!</p></blockquote>

<p>That&rsquo;s true; with checked exceptions, it&rsquo;s easy to write a single
<code>catch</code> statement that handles all failures due to, say, a
<code>ParseException</code> in a whole region of code, avoiding the need for code
repetition.</p>

<p>The upshot is that with union types, we can just use functions. Take
everything in the <code>catch</code> body, put it in a helper function, and call it
at each call site.  This cuts down on duplication, and I already
mentioned how call-site granularity is a win.</p>

<h2>I love union types</h2>

<p>That&rsquo;s it, that&rsquo;s the whole take. Sorbet doesn&rsquo;t need checked exceptions, it
already has ad hoc union types.</p>

<hr />

<h2 id="appendix">Appendix: Checked Exceptions</h2>


<p>As a quick refresher, <a href="https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions">checked exceptions</a> are a feature popularized by
Java.  The syntax looks like this:</p>

<pre><code class="java">void doThing() throws MyException {
    // ...
}
</code></pre>

<p>The <code>throws</code> keyword declares that in addition to the method&rsquo;s argument
types and return type, it might also throw <code>MyException</code>. If a method
throws multiple classes of exceptions, they can all be listed:</p>

<pre><code class="java">void doThing() throws MyException, YourException, AnotherException {
    // ...
}
</code></pre>

<p>The <code>throws</code> keyword is checked at all call sites, just like argument
and return types. A method containing calls to <code>doThing</code> must either
<code>catch</code> all mentioned exceptions or repeat the <code>throws</code> clause in its
own signature.</p>

<p>The argument in favor of checked exceptions is that it&rsquo;s explicit and
machine-checked. Users don&rsquo;t have to guess at what a method might throw,
or hope that there&rsquo;s accurate documentation—all benefits shared by
static typing in general, which is a sympathetic goal.</p>

<p>Checked exceptions seem like a good feature on paper. In practice,
they&rsquo;re generally regretted. I&rsquo;m nowhere near the first person to come
to this conclusion, so instead I&rsquo;ll link you to some previous
discussions:</p>

<ul>
<li><a href="https://www.artima.com/articles/the-trouble-with-checked-exceptions">The Trouble with Checked Exceptions</a>, A Conversation
with Anders Hejlsberg</li>
<li><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t In
Java</a>, by James Iry</li>
<li><a href="https://ericlippert.com/2008/09/10/vexing-exceptions/">Vexing Exceptions</a>, by Eric Lippert</li>
</ul>


<p>(The last one isn&rsquo;t actually about checked exceptions: it&rsquo;s just about
exceptions and I like it, so I included it.)</p>

<p>Java has been copied and imitated for decades. Among all the features we
see other languages copy from Java, checked exceptions are absent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring Ruby with clangd]]></title>
    <link href="https://blog.jez.io/clangd-ruby/"/>
    <updated>2020-07-21T15:40:23-07:00</updated>
    <id>https://blog.jez.io/clangd-ruby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve managed to get LSP-based IDE features powered by <a href="https://clangd.llvm.org/">clangd</a> working
for the Ruby VM&rsquo;s source code (in my case, in Vim). Here&rsquo;s how I did it!</p>

<!-- more -->


<p>I&rsquo;ve been making a point to learn more about <a href="/search-down-the-stack/">things I depend
on</a> recently. Today, that means learning about
Ruby. And what better way to learn than to check out the source code,
and jump around?</p>

<p><a href="https://clangd.llvm.org/">clangd</a> is an editor-agnostic language server that uses the <a href="https://langserver.org/">Language
Server Protocol</a> to power IDE-like features in
your preferred text editor. All it needs is a <code>compile_commands.json</code>,
which is basically a mapping of filename to options to pass to <code>clang</code>
so that it knows things like which warnings to enable and where to
search for header files.</p>

<p><a href="https://clangd.llvm.org/">clangd</a> works best for projects built using <code>cmake</code>, but the Ruby VM
doesn&rsquo;t use <code>cmake</code>. Regardless, we can make a <code>compile_commands.json</code>
file by using <a href="https://github.com/rizsotto/Bear">Bear</a> to trace the execution of a Ruby build, and use the
trace information to write out a <code>compile_commands.json</code> file.</p>

<h2>Steps</h2>

<p>I could only get these steps to work for Linux, as the Bear README
mentions that on macOS you have to disable System Integrity Protection
to get it to work.</p>

<h3>1. Install <a href="https://github.com/rizsotto/Bear">Bear</a></h3>

<p>I describe how I built Bear from source in the Appendix.</p>

<h3>2. Clone the Ruby source code.</h3>

<pre><code class="bash">git clone https://github.com/ruby/ruby
cd ruby
</code></pre>

<h3>3. Configure the Ruby build.</h3>

<p>We have to tell the <code>configure</code> script to use Clang to compile (or
if you&rsquo;re confident that your system compiler toolchain is Clang,
you can just run <code>./configure</code>).</p>

<pre><code class="bash"># Create the ./configure file
autoconf
# This only works when using clang to build Ruby
./configure CC=clang
</code></pre>

<h3>4. Use <code>bear</code> to invoke <code>make</code></h3>

<p>Bear will use a dynamically preloaded library to trace system calls
that exec <code>clang</code> processes, looking at things like the command line
arguments given to Clang.</p>

<pre><code class="bash">bear make
</code></pre>

<h3>5. That&rsquo;s it!</h3>

<p>The output is <code>./compile_commands.json</code>, which should be non-empty. If
it&rsquo;s empty or just has <code>[]</code>, it didn&rsquo;t work. There&rsquo;s some
troubleshooting in the <a href="https://github.com/rizsotto/Bear">Bear</a> README.</p>

<p>The <code>compile_commands.json</code> file will be consumed by <code>clangd</code> in your
editor. Check <a href="https://langserver.org">https://langserver.org</a> to find an LSP client for your
preferred editor, and follow its setup instructions.</p>

<p>Once you&rsquo;ve built the <code>compile_commands.json</code> file and configured your
editor to use LSP with <code>clangd</code>, you should be able to do things like
Jump to Definition and Hover on the Ruby source code!</p>

<h2>Appendix: Building Bear from source</h2>

<p>This is probably common knowledge for people who use <code>cmake</code> regularly,
but this is how I built Bear from source, because I built it on a
machine where I didn&rsquo;t have root so I couldn&rsquo;t write to <code>/usr/local</code>.</p>

<pre><code class="bash">git clone https://github.com/rizsotto/Bear
cd Bear
mkdir build
cd build

# Install to $HOME/.local/bin instead of /usr/local/bin
cmake .. "-DCMAKE_INSTALL_PREFIX=$HOME/.local"
make -j$(nproc)
make install

# → $HOME/.local/bin/bear exists now
</code></pre>

<h2>Appendix: LSP in Neovim with LanguageClient-neovim</h2>

<p>I use Neovim. My preferred LSP client is <a href="https://github.com/autozimu/LanguageClient-neovim">LanguageClient-neovim</a>. Here&rsquo;s
the parts of my Neovim config files that setup <code>clangd</code>:</p>

<p><a href="https://github.com/jez/dotfiles/blob/865a74d93d8ab1c28713ae0dcd53797b6c26dc6a/vim/plug-settings.vim#L576-L587">→ <code>vim/plug-settings.vim</code> in jez/dotfiles</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linkers & Ruby C Extensions]]></title>
    <link href="https://blog.jez.io/linkers-ruby-c-exts/"/>
    <updated>2020-06-07T12:05:07-05:00</updated>
    <id>https://blog.jez.io/linkers-ruby-c-exts</id>
    <content type="html"><![CDATA[<p>I recently learned that linkers are really cool. It all started when I
saw an error message that looked something like this:</p>

<pre><code>❯ rake test
symbol lookup error: /home/jez/.../foo.so: undefined symbol bar
</code></pre>

<p>I <a href="/search-down-the-stack/">already wrote</a> about finding where this
error was coming from. The tl;dr is that it was coming from GNU&rsquo;s libc
implementation:</p>

<pre><code>❯ rg -t c 'symbol lookup error'
dl-lookup.c
876:      _dl_signal_cexception (0, &amp;exception, N_("symbol lookup error"));
</code></pre>

<p>That led me to a fun exploration of how linux linkers work, and how Ruby
C extensions rely on them.</p>

<p>I always knew that Ruby C extensions existed (that they <a href="https://twitter.com/asolove/status/1261339091485917184">break all the
time</a> is a constant reminder&hellip;) but I never really connected
the dots between &ldquo;here&rsquo;s some C code&rdquo; and how Ruby actually runs that
code.</p>

<p>Ruby C extensions are just shared libraries following certain
conventions. Specifically, a Ruby C extension might look like this:</p>

<pre><code class="c">#include "ruby.h"

VALUE my_foo(VALUE self, VALUE val) {
  return rb_funcall(self, rb_intern("puts"), 1, val)
}

// This function's name matters:
void Init_my_lib() {
  rb_define_method(rb_cObject, "foo", my_foo);
}
</code></pre>

<p>The important part is that the name of that <code>Init_my_lib</code> function
matters. When Ruby sees a line like</p>

<pre><code class="ruby">require_relative './my_lib'
</code></pre>

<p>it looks for a file called <code>my_lib.so</code> (or <code>my_lib.bundle</code> on macOS),
asks the operating system to load that file as a shared library, and
then looks for a function with the name <code>Init_my_lib</code> inside the library
it just loaded.</p>

<p>When that function runs, it&rsquo;s a chance for the C extension to do
the same sorts of things that a normal Ruby file might have done if it
had been <code>require</code>&rsquo;d. In this example, it defines a method <code>foo</code> at the
top level, almost like the user had written normal Ruby code like this:</p>

<pre><code class="ruby my_lib.rb">def foo(val)
  puts val
end
</code></pre>

<p>That&rsquo;s kind of wild! That means:</p>

<ul>
<li>C programs can load libraries dynamically at runtime, using arbitrary
user input.</li>
<li>C programs can then ask if there&rsquo;s a function defined in that library
with an arbitrary name, and get a function pointer to call it if there
is!</li>
</ul>


<p>I was pretty shocked to learn this, because my mental model of how
linking worked was that it split evenly into two parts:</p>

<ul>
<li><p>&ldquo;My application is statically linked, where all the code and libraries
my application depends on are compiled into my binary.&rdquo;</p></li>
<li><p>&ldquo;My application is dynamically linked, which means my binary
pre-declares some libraries that must be loaded before my program can
start running.&rdquo;</p></li>
</ul>


<p>There&rsquo;s actually a third option!</p>

<p>Then I looked into what code Ruby actually calls to do this. I found the
code in <code>dln.c</code>:</p>

<pre><code class="c dln.c">/* Load file */
if ((handle = (void*)dlopen(file, RTLD_LAZY|RTLD_GLOBAL)) == NULL) {
    error = dln_strerror();
    goto failed;
}
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1341">→ View on github.com</a></p>

<p>Ruby uses the <code>dlopen(3)</code> function in libc to request that an arbitrary
user library be loaded. From the man page:</p>

<blockquote><p>The function dlopen() loads the dynamic shared object (shared library)
file named by the null-terminated string filename and returns an
opaque &ldquo;handle&rdquo; for the loaded object.</p>

<p>&mdash; man dlopen</p></blockquote>

<p>The next thing Ruby does with this opaque <code>handle</code> is to find if the
thing it just loaded has an <code>Init_&lt;...&gt;</code> function inside it:</p>

<pre><code class="c dln.c">init_fct = (void(*)())(VALUE)dlsym(handle, buf);
if (init_fct == NULL) {
    const size_t errlen = strlen(error = dln_strerror()) + 1;
    error = memcpy(ALLOCA_N(char, errlen), error, errlen);
    dlclose(handle);
    goto failed;
}
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1363-L1369">→ View on github.com</a></p>

<p>It uses <code>dlsym(3)</code> (again in libc) to look up a method with an arbitrary
name (<code>buf</code>) inside the library it just opened (<code>handle</code>). That function
must exist—if it doesn&rsquo;t, it&rsquo;s not a valid Ruby C extension and Ruby
reports an error.</p>

<p>If <code>dlsym</code> found a function with the right name, it stores a function
pointer into <code>init_fct</code>, which Ruby immediately dereferences and calls:</p>

<pre><code class="c dln.c">/* Call the init code */
(*init_fct)();
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1370-L1371">→ View on github.com</a></p>

<p>It&rsquo;s still kind of mind bending to think that C provides this level of
&ldquo;dynamism.&rdquo; I had always thought that being a compiled language meant
that the set of functions a C program could call was fixed at compile
time, but that&rsquo;s not true at all!</p>

<p>This search led me down a rabbit hole of learning more about linkers,
and now I think they&rsquo;re super cool—and far less cryptic! I <strong>highly</strong>
recommend <em>Chapter 7: Linking</em> from <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer&rsquo;s
Perspective</a> if this was interesting to you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have FixMe Comments]]></title>
    <link href="https://blog.jez.io/sorbet-fixme-comment/"/>
    <updated>2020-02-11T23:18:40-08:00</updated>
    <id>https://blog.jez.io/sorbet-fixme-comment</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Sorbet has no way to ignore an error on a specific line with a magic
comment. This is different from all other gradual static type checkers I
know about:</p>

<ul>
<li>TypeScript: <code>// @ts-ignore</code></li>
<li>Flow: <code>// $FlowFixMe</code></li>
<li>Hack: <code>// HH_FIXME</code></li>
<li>MyPy: <code># type: ignore</code></li>
</ul>


<p>When I first joined the team, I was skeptical. But having seen it play
out in practice, it&rsquo;s actually worked great.</p>

<p>Instead of ignore comments, Sorbet has <code>T.unsafe</code>, which accepts
anything and returns it unchanged (so for example <code>T.unsafe(3)</code>
evaluates to <code>3</code>). The trick is that it forces Sorbet to forget the
type of the input statically. This confers the power to silence most
errors. For example:</p>

<pre><code class="ruby">1 + '1'            # error: Expected `Integer` but found `String`
T.unsafe(1) + '1'  # no error
</code></pre>

<p><a href="https://sorbet.run/#%20%20%20%20%20%20%20%20%201%20%20%2B%20'1'%20%20%23%20error%3A%20Expected%20%60Integer%60%20but%20found%20%60String%60%0AT.unsafe(1)%20%2B%20'1'%20%20%23%20no%20error">→ View on sorbet.run</a></p>

<p>In this example, Sorbet knows that calling <code>+</code> on an Integer with a
String would raise an exception at runtime, and so it reports a static
type error. But wrapping the <code>1</code> in a call to <code>T.unsafe</code> causes Sorbet
to think that the expression <code>T.unsafe(1)</code> has type <code>T.untyped</code>. Then,
like for all untyped code, Sorbet admits the addition.</p>

<p>All Sorbet-typed Ruby programs must grapple with <code>T.untyped</code>. Every
Sorbet user has to learn how it works and what the tradeoffs of using it
are. In particular, that <code>T.untyped</code> is viral. Given a variable that&rsquo;s
<code>T.untyped</code>, all method calls on that variable will also be untyped:</p>

<pre><code class="ruby"># typed: true
extend T::Sig

sig {params(x: T.untyped).void}
def foo(x)
  y = x.even?
# ^ type: T.untyped
  z = !y
# ^ type: T.untyped
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.untyped).void%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20x.even%3F%0A%23%20%5E%20type%3A%20T.untyped%0A%20%20z%20%3D%20!y%0A%23%20%5E%20type%3A%20T.untyped%0Aend">→ View on sorbet.run</a></p>

<p>In this example <code>x</code> enters the method as <code>T.untyped</code>, so calling the
method <code>.even?</code> propagates the <code>T.untyped</code> to <code>y</code>. Then again because
<code>y</code> is untyped, calling<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <code>!</code> on it propgates the <code>T.untyped</code> to
<code>z</code>. There are plenty of reasons to <a href="https://sorbet.org/docs/gradual">both embrace and avoid</a>
<code>T.untyped</code> in a type system but the point is: Sorbet&rsquo;s type system
already has it.</p>

<p>Re-using <code>T.untyped</code> as the way to silence errors plays nicely with
everything else in Sorbet:</p>

<ul>
<li><p>Hover and jump to definition become tools to track down the source of
silenced errors.</p></li>
<li><p>Errors are effectively silenced at the source of the error. There are
no errors downstream that only show up because an error was silenced
earlier.</p></li>
<li><p>We plan to eventually build a tool to show which parts of a file are
untyped (to see things like which methods don&rsquo;t have signatures). That
tool will trivially take suppressed errors into account.</p></li>
</ul>


<p>The <a href="https://sorbet.org/docs/gradual">Sorbet docs</a> bill <code>T.untyped</code> as the way to &ldquo;turn off the
type system.&rdquo; By reusing <code>T.untyped</code> to supress errors, silencing one
error means silencing them all, which is a win for simplicity.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Did you know that <code>!x</code> in Ruby is syntactic sugar for <code>x.!()</code>, which means that you can override <code>!</code> to make it do something else?<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intersection Types in Sorbet are Surprisingly Common]]></title>
    <link href="https://blog.jez.io/intersection-types-common/"/>
    <updated>2020-01-04T19:50:32-06:00</updated>
    <id>https://blog.jez.io/intersection-types-common</id>
    <content type="html"><![CDATA[<p>Conventional knowledge is that union types are common and intersection
types are rare. But actually that&rsquo;s not the case—intersection types
show up in nearly every program Sorbet type checks thanks to control
flow.</p>

<p><a href="https://sorbet.org/docs/union-types">Union types</a> in Sorbet are incredibly common, which should be no
surprise. In Sorbet, <code>T.nilable(...)</code> is sugar for <code>T.any(NilClass,
...)</code>. <code>T.nilable</code> shows up all over the place and probably catches more
bugs than any other feature in Sorbet.</p>

<p>Sorbet also has <a href="https://sorbet.org/docs/intersection-types">intersection types</a>. While union types mean &ldquo;either
this or that,&rdquo; intersection types mean &ldquo;both this and that.&rdquo; On first
glance, intersection types seem like some super niche feature which only
benefits a handful of programs. In Stripe&rsquo;s Ruby monorepo, the strings
<code>T.any</code> and <code>T.nilable</code> occur nearly 300 times more than <code>T.all</code> does.</p>

<p>But those numbers hide something critical: intersection types power
Sorbet&rsquo;s <a href="https://sorbet.org/docs/flow-sensitive">control flow-sensitive typing</a>. They&rsquo;re actually present in
every Ruby program, but just a little hard to spot. Let&rsquo;s look at how
pervasive they are with a few examples:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class Parent; end
class Child &lt; Parent; end

sig {params(x: Parent).void}
def example1(x)
  case x
  when Child
    T.reveal_type(x) # Revealed type: `Child`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>Here <code>x</code> starts out having type <code>Parent</code>, but inside the <code>case</code>
statement Sorbet treats <code>x</code> as having the more specific type <code>Child</code>.
There&rsquo;s no <code>T.all</code> in sight, but that&rsquo;s because it&rsquo;s hiding. Sorbet
doesn&rsquo;t just throw away the fact that it knew <code>x &lt;: Parent</code>. Instead, it
uses <code>T.all</code> to update its type for <code>x</code> to <code>T.all(Parent, Child)</code>.</p>

<p><code>T.all(Parent, Child)</code> is equivalent to <code>Child</code> because <code>Child</code> is a
subtype of <code>Parent</code>. If types represent sets of values, then the set of
values represented by <code>Child</code> is a subset of the set of values
represented by <code>Parent</code>, so the intersection of those two sets would
just leave <code>Child</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Sorbet attempts to simplify a large type to a smaller, equivalent type
when it can for two reasons:</p>

<ul>
<li><p><strong>Usability</strong> – Most users don&rsquo;t know that <code>T.all</code> means &ldquo;intersection
type&rdquo; or even what intersection types are. (And even those who do
still end up drawing Venn diagrams from time to time!) It only gets
more complicated when <code>T.all</code>s and <code>T.any</code>s nest inside each other.</p>

<p>Meanwhile, <code>Child</code> is a super easy type to understand, and leads to
nice, short error messages.</p></li>
<li><p><strong>Performance</strong> – Checking whether one type is a subtype of another is
a super common operation, so it has to be fast. By collapsing
<code>T.all(Parent, Child)</code> to <code>Child</code>, Sorbet does at least half as much
work when checking subtyping (probably more, because of some common
path optimizations).</p>

<p>When this simplification happens, Sorbet even skips an allocation
entirely. Cnstructing <code>T.all(Parent, Child)</code> in Sorbet short
circuits and returns a reference to the already allocated <code>Child</code> type
that was passed as an argument (with ownership tracked via
<code>std::shared_ptr</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>).</p></li>
</ul>


<p>Let&rsquo;s look at another example of control flow:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class A; end
class B; end

sig {params(a_or_b: T.any(A, B)).void}
def example2(a_or_b)
  case a_or_b
  when A
    T.reveal_type(a_or_b) # Revealed type: `A`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>This example method accepts either <code>A</code> or <code>B</code> (<code>T.any(A, B)</code>) and then
branches on whether <code>a_or_b</code> is an instance of <code>A</code>. Again: Sorbet
doesn&rsquo;t throw away that it knows <code>a_or_b &lt;: T.any(A, B)</code>. Instead it
updates its knowledge of the type of <code>a_or_b</code> using <code>T.all</code> to get
<code>T.all(T.any(A, B), A)</code>. Realizing that this is equivalent to <code>A</code> is a
bit trickier:</p>

<pre><code class="ruby">T.all(T.any(A, B), A)

# Distribute
T.any( T.all(A, A) , T.all(B, A) )

# T.all(A, A) is just A (idempotence)
T.any( A , T.all(B, A) )

# A and B are classes (not mixins) and neither inherits the other.
# It's impossible to have a value of that type, so it's bottom:
T.any( A , T.noreturn )

# bottom is the identity of union
A
</code></pre>

<p>You can start to see how usability and performance and might get a
little out of hand if Sorbet didn&rsquo;t keep attempting to simplify things!
The cumulative effect of all the control flow in a program would result
in huge, unweidly types.</p>

<p>Until now you could claim that I&rsquo;ve been hyping up intersection types as
the solution to problems that were self-imposed. That if we just
invented some other method for modeling control flow, it would have been
naturally usable or naturally performant, and we wouldn&rsquo;t have had
problems in the first place. So next let&rsquo;s look at some examples to see
why intersection types really are the most natural solution:</p>

<pre><code class="ruby">module I1
  def foo1; end
end
module I2
  def foo2; end
end

sig {params(x: I1).void}
def example3(x)
  x.foo1  # Works outside
  case x
  when I2
    x.foo1  # Should (and does) still work inside
    x.foo2
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A">→ View on sorbet.run</a></p>

<p>Unlike in the other examples, this is the first example where had we
tried to implement control-flow-sensitive typing by throwing away the
old type and using the new type instead it wouldn&rsquo;t have worked. The key
thing to notice: this example uses modules. Outside the <code>case</code> of course
calling <code>x.method_from_1</code> works because <code>x</code> starts out at type <code>I1</code>. But
if we treated <code>x</code> as only <code>I2</code> inside the <code>when I2</code>, we&rsquo;d start
reporting an error for calling <code>x.method_from_1</code> because it doesn&rsquo;t
exist on <code>I2</code>.</p>

<p>Unlike intersecting unrelated classes (our <code>T.all(B, A)</code> example from
earlier), intersecting unrelated modules does&rsquo;t collapse to
<code>T.noreturn</code>. There&rsquo;s nothing stopping some class from including both
<code>I1</code> and <code>I2</code>. Instances of that class would be values of type
<code>T.any(I1, I2)</code>:</p>

<pre><code class="ruby">class SomeClass
  include I1
  include I2
end

# This type assertion is okay:
T.let(SomeClass.new, T.all(I1, I2))
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))">→ View on sorbet.run</a></p>

<p>So at least for implementing certain cases of flow sensitive typing,
we&rsquo;ll <em>need</em> intersection types anyways. Then for these certain cases
we&rsquo;d incur the usability and performance problems we discovered earlier
and have to solve them.</p>

<p>But more than that, intersection types are fundamentally easier to work
with compared to some ad hoc approach to flow sensitive typing. Type
system bugs are weird. It&rsquo;s frquently harder to figure out whether the
current behavior is buggy in the first place than it is to find the
cause!</p>

<p>In that light, intersection types present an elegant, robust model for
arriving at what the correct behavior <em>should</em> be, independent of what
Sorbet&rsquo;s existing behavior is. It&rsquo;s clear how intersection types
interact with union types, and with subtyping, and with generics, and
with variance, etc.</p>

<p>By repurposing intersection types to model control flow sensitivity,
when things go wrong there&rsquo;s a framework for discovering what&rsquo;s right.</p>

<p>(Speaking of repurposing, intersection types also play an important role
in how Sorbet <a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend">suggests potential method signatures</a>! That&rsquo;s three birds
with one stone.)</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you&rsquo;re not convinced, consider: with <code>T.all(Parent, Child)</code> we should be able to call all the methods on <code>Parent</code> and all the methods on <code>Child</code>. But <code>Child</code> inherits <code>Parent</code>&rsquo;s methods, so any method <code>Parent</code> has will already be on <code>Child</code>. So <code>Child</code> is equivalently good as <code>T.all(Parent, Child)</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you&rsquo;re looking for a good intro to modern C++ things like <code>shared_ptr</code>, I can&rsquo;t recommend <a href="https://berthub.eu/articles/posts/cpp-intro/">this blog post series</a> enough.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
