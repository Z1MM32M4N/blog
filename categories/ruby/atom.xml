<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/ruby/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2021-06-05T04:37:18-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Typed Errors in Sorbet]]></title>
    <link href="https://blog.jez.io/typed-errors-sorbet/"/>
    <updated>2021-06-04T22:12:37-07:00</updated>
    <id>https://blog.jez.io/typed-errors-sorbet</id>
    <content type="html"><![CDATA[<!-- more -->




<p></p>


<p>I really like this post from Matt Parsons, <a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html">The Trouble with Typed
Errors</a>. It&rsquo;s written for an audience writing Haskell,
but if you can grok Haskell syntax, it&rsquo;s worth the read because the
lessons apply broadly to most statically typed programming languages.</p>

<p>If you haven&rsquo;t read it (or it&rsquo;s been a while) the setup is basically:
typing errors is hard, and nearly every solution is either brittle,
clunky, verbose, or uses powerful type system features that we didn&rsquo;t
want to have to reach for.</p>

<p>Hidden towards the bottom of the post, we find:</p>

<blockquote><p>In PureScript or OCaml, you can use open variant types to do this
flawlessly. Haskell doesn&rsquo;t have open variants, and the attempts to
mock them end up quite clumsy to use in practice.</p></blockquote>

<p>What Matt calls &ldquo;open variant types&rdquo; I call <strong>ad hoc union types</strong> (see
my previous post about <a href="https://blog.jez.io/union-types-checked-exceptions/">checked exceptions and
Sorbet</a>). Naming aside, Sorbet has them! We don&rsquo;t
have to suffer from clunky error handling!</p>

<p>I thought it&rsquo;d be interesting to show what Matt meant in this quote by
translating his example to Sorbet.</p>

<p>I wrote a complete, working example, but rather than repeat the whole
thing here, I&rsquo;m just going to excerpt the good stuff. If you&rsquo;re wondering
how something is defined in full, check the full example:</p>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0A%0A%23%20This%20is%20a%20re-implementation%20of%20Matt%20Parsons's%20%22The%20Trouble%20with%20Typed%0A%23%20Errors%22%20in%20Sorbet%20(Ruby)%20because%20I%20think%20Sorbet%20happens%20to%20handle%20it%0A%23%20pretty%20well%20all%20things%20considered.%0A%23%0A%23%20%20%20%20%20%3Chttps%3A%2F%2Fwww.parsonsmatt.org%2F2018%2F11%2F03%2Ftrouble_with_typed_errors.html%3E%0A%23%0A%23%20Specifically%2C%20he%20mentions%0A%23%0A%23%20%20%20%20%20In%20PureScript%20or%20OCaml%2C%20you%20can%20use%20open%20variant%20types%20to%20do%20this%0A%23%20%20%20%20%20flawlessly.%0A%23%0A%23%20and%20Sorbet%20more%20or%20less%20has%20those%20(untagged%20unions).%20It's%20interesting%0A%23%20to%20see%20what%20that%20means%20for%20being%20able%20to%20track%20errors%2C%20because%20we%0A%23%20actually%20use%20Sorbet%20in%20a%20huge%20codebase%20at%20work.%20Tracking%20all%20the%20kinds%0A%23%20of%20errors%20that%20could%20happen--and%20no%20more--can%20make%20code%20far%20easier%20to%0A%23%20understand.%0A%0A%23%20To%20run%20this%20file%3A%0A%23%0A%23%20%20%20gem%20install%20sorbet-runtime%0A%23%20%20%20ruby%20typed-errors.rb%0A%0Arequire%20'sorbet-runtime'%0A%0A%23%20There's%20a%20bug%20in%20Sorbet%20that%20forces%20us%20to%20wrap%20all%20this%20code%20in%20a%0A%23%20class%2C%20but%20I%20have%20a%20PR%20open%20to%20fix%20it.%20For%20now%2C%20we%20tolerate%20it.%0Aclass%20Main%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20%23%20-----%20Custom%20error%20types%20-----%0A%0A%20%20%23%20Defining%20custom%20data%20types%20is%20a%20little%20clunky%20in%20Ruby%20%2F%20Sorbet.%20You%0A%20%20%23%20have%20to%20chose%20whether%20you%20want%20a%20plain%20class%2C%20an%20enum%2C%20a%20sealed%0A%20%20%23%20class%20hierarchy%2C%20etc.%20In%20a%20real%20codebase%2C%20I%20think%20if%20you%20were%20going%0A%20%20%23%20to%20this%20length%20to%20care%20for%20errors%20the%20kinds%20of%20errors%20that%20you%20have%0A%20%20%23%20are%20usually%20pretty%20rich%20(e.g.%2C%20there's%20a%20message%20and%20context%20with%0A%20%20%23%20the%20failures)%2C%20so%20you'd%20probably%20go%20with%20the%20sealed%20class%20hierarchy.%0A%20%20%23%0A%20%20%23%20For%20this%20example%2C%20I%20chose%20three%20different%20ways%20to%20just%20show%20them%20all.%0A%0A%20%20class%20HeadError%0A%20%20end%0A%0A%20%20class%20LookupError%20%3C%20T%3A%3AEnum%0A%20%20%20%20enums%20do%0A%20%20%20%20%20%20KeyWasNotPresent%20%3D%20new%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20module%20ParseError%0A%20%20%20%20extend%20T%3A%3AHelpers%0A%20%20%20%20sealed!%0A%0A%20%20%20%20class%20UnexpectedChar%20%3C%20T%3A%3AStruct%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20%20%20prop%20%3Amessage%2C%20String%0A%20%20%20%20end%0A%0A%20%20%20%20class%20RanOutOfInput%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Helper%20methods%20-----%0A%0A%20%20%23%20Again%2C%20concise%20syntax%20is%20not%20Sorbet's%20strong%20suit.%20The%20signature%0A%20%20%23%20annotations%20are%20pretty%20verbose%20here%20(especially%20generics)%20but%20they%0A%20%20%23%20pretty%20much%20exactly%20map%20to%20the%20Haskell%20functions%20in%20the%20post.%0A%0A%20%20sig%20do%0A%20%20%20%20%20%20params(xs%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(String%2C%20HeadError))%0A%20%20end%0A%20%20def%20self.head(xs)%0A%20%20%20%20case%20xs.size%0A%20%20%20%20when%200%20then%20HeadError.new%0A%20%20%20%20else%20T.must(xs%5B0%5D)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters(%3AK%2C%20%3AV)%0A%20%20%20%20%20%20.params(%0A%20%20%20%20%20%20%20%20hash%3A%20T%3A%3AHash%5BT.type_parameter(%3AK)%2C%20T.type_parameter(%3AV)%5D%2C%0A%20%20%20%20%20%20%20%20key%3A%20T.type_parameter(%3AK)%0A%20%20%20%20%20%20)%0A%20%20%20%20%20%20.returns(T.any(T.type_parameter(%3AV)%2C%20LookupError))%0A%20%20end%0A%20%20def%20self.lookup(hash%2C%20key)%0A%20%20%20%20if%20hash.key%3F(key)%0A%20%20%20%20%20%20hash.fetch(key)%0A%20%20%20%20else%0A%20%20%20%20%20%20LookupError%3A%3AKeyWasNotPresent%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20params(source%3A%20String).returns(T.any(Integer%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.parse(source)%0A%20%20%20%20case%20source%0A%20%20%20%20when%20%22%22%20then%20ParseError%3A%3ARanOutOfInput.new%0A%20%20%20%20else%0A%20%20%20%20%20%20begin%0A%20%20%20%20%20%20%20%20Integer(source%2C%2010)%0A%20%20%20%20%20%20rescue%20ArgumentError%20%3D%3E%20exn%0A%20%20%20%20%20%20%20%20ParseError%3A%3AUnexpectedChar.new(message%3A%20exn.message)%0A%20%20%20%20%20%20end%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Composing%20errors%20-----%0A%0A%20%20STR_MAP%20%3D%20T.let(%7B%0A%20%20%20%20%224__%22%20%3D%3E%20%222%22%0A%20%20%7D%2C%20T%3A%3AHash%5BString%2C%20String%5D)%0A%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20HeadError%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.foo(str)%0A%20%20%20%20%23%20These%20%60return%60%20lines%20are%20definitely%20not%20as%20convenient%20as%20do%0A%20%20%20%20%23%20notation%20in%20Haskell%2C%20but%20the%20interesting%20thing%20is%20that%20they're%0A%20%20%20%20%23%20still%20pretty%20nice%3A%20because%20of%20flow-sensitive%20typing%2C%20the%20type%20of%0A%20%20%20%20%23%20%60c%60%20changes%2C%20as%20commented%3A%0A%20%20%20%20c%20%3D%20head(str)%20%23%20%3D%3E%20c%20%3A%20T.any(String%2C%20HeadError)%0A%20%20%20%20return%20c%20unless%20c.is_a%3F(String)%0A%20%20%20%20%23%20%3D%3E%20c%20%3A%20String%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(%22%23%7Bc%7D%23%7Br%7D%22)%0A%20%20end%0A%0A%20%20%23%20This%20method%20doesn't%20call%20%60head%60%20like%20before%2C%20so%20it%20doesn't%20need%20to%0A%20%20%23%20have%20%60HeadError%60%20in%20the%20return%20type.%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.bar(str)%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(r)%0A%20%20end%0A%0A%20%20p%20foo(%224__%22)%0A%20%20p%20bar(%224__%22)%0Aend%0A%0A%23%20Because%20%60T.any%60%20can%20create%20ad%20hoc%2C%20untagged%20union%20types%20anywhere%2C%0A%23%20there's%20no%20need%20to%20define%20an%20%60AllErrorsEver%60%20data%20type%20like%20the%20reader%0A%23%20was%20tempted%20to%20in%20the%20Typed%20Errors%20blog%20post.%0A%23%0A%23%20If%20you%20find%20that%20a%20particular%20set%20of%20errors%20are%20showing%20up%20super%0A%23%20frequently%2C%20you%20can%20lurk%20them%20into%20a%20type%20alias%3A%0A%23%0A%23%20%20%20%20%20MostCommonErrors%20%3D%20T.type_alias%20%7BT.any(LookupError%2C%20ParseError)%7D%0A%23%0A%23%20and%20then%20use%20this%20alias%20in%20various%20places.%0A%23%0A%23%20One%20other%20note%3A%20to%20make%20this%20pattern%20nicer%2C%20code%20might%20want%20to%0A%23%20explicitly%20box%20up%20successful%20results%2C%20with%20a%20type%20like%0A%23%0A%23%20%20%20%20%20class%20Ok%20%3C%20T%3A%3AStruct%0A%23%20%20%20%20%20%20%20extend%20T%3A%3AGeneric%0A%23%20%20%20%20%20%20%20Type%20%3D%20type_member%0A%23%20%20%20%20%20%20%20prop%20%3Aval%2C%20Type%0A%23%20%20%20%20%20end%0A%23%0A%23%20So%20then%20you'd%20have%0A%23%20%20%20%20%20T.any(Ok%5BString%5D%2C%20MostCommonErrors)%0A%23%20and%20you%20could%20do%20make%20all%20the%20%60return%60%20lines%20always%20look%20the%20same%3A%0A%23%20%20%20%20%20return%20x%20unless%20x.is_a%3F(Ok)%0A%23%20but%20the%20flipside%20would%20mean%20that%20you'd%20have%20to%20use%20%60.val%60%20at%20all%20the%0A%23%20places%20that%20you%20would%20have%20normally%20used%20%60x%60%3A%0A%23%20%20%20%20%20parse(x.val)%0A%23%20so%20it's%20maybe%20not%20worth%20it.%0A%0A">→ View on sorbet.run</a></p>

<p>First, here&rsquo;s how we&rsquo;d type the three running helper methods from Matt&rsquo;s
post:</p>

<pre><code class="ruby"># Returns the first letter of the input,
# or returns `HeadError` if empty
sig {params(xs: String).returns(T.any(String, HeadError))}
def self.head(xs); ...; end


# Gets the value for `key` in `hash`, or returns LookupError.
#
# This is normally defined in the stdlib, and in trying to
# match Matt's post, it ends up not being super idiomatic,
# but the types still work out.
sig do
  type_parameters(:K, :V)
    .params(
      hash: T::Hash[T.type_parameter(:K), T.type_parameter(:V)],
      key: T.type_parameter(:K)
    )
    .returns(T.any(T.type_parameter(:V), LookupError))
end
def self.lookup(hash, key); ...; en


# Convert a String to an integer, or return ParseError.
sig {params(source: String).returns(T.any(Integer, ParseError))}
def self.parse(source); ...; end
</code></pre>

<p>Notice how in all three cases, we use a normal <a href="https://sorbet.org/docs/union-types">Sorbet union type</a> in
the return, like <code>T.any(String, HeadError)</code>. All of the error types are
just user-defined classes. For example, <code>HeadError</code> is just defined like
this:</p>

<pre><code class="ruby">class HeadError; end
</code></pre>

<p>And <code>ParseError</code> is defined using <a href="https://sorbet.org/docs/sealed">sealed classes</a> and <a href="https://sorbet.org/docs/tstruct">typed structs</a>
to approximate algebraic data types in other typed languages:</p>

<pre><code class="ruby">module ParseError
  extend T::Helpers
  sealed!

  class UnexpectedChar &lt; T::Struct
    include ParseError
    prop :message, String
  end

  class RanOutOfInput
    include ParseError
  end
end
</code></pre>

<p>Then at the caller side, it&rsquo;s simple to handle the errors:</p>

<pre><code class="ruby">sig do
  params(str: String)
    .returns(T.any(Integer, HeadError, LookupError, ParseError))
end
def self.foo(str)
  c = head(str) # =&gt; c : T.any(String, HeadError)
  return c unless c.is_a?(String)
  # =&gt; c : String
  r = lookup(STR_MAP, str)
  return r unless r.is_a?(String)
  parse("#{c}#{r}")
end
</code></pre>

<p>The idea is that the return type includes the possible errors, so we
have to handle them. This example handles the errors by checking for
success and returning early with the error otherwise. This manifests in
the return type of <code>foo</code>, which mentions four outcomes:</p>

<ul>
<li>a successful result (<code>Integer</code>)</li>
<li>three kinds of failures (<code>HeadError</code>, <code>LookupError</code>, and <code>ParseError</code>)</li>
</ul>


<p>It would have worked equally well to handle and recover from any or all
of the errors: Sorbet knows exactly which error is returned by which
method, so there&rsquo;s never a burden of handling more errors than are
possible.</p>

<p>It&rsquo;s fun that what makes this work is Sorbet&rsquo;s natural <a href="https://sorbet.org/docs/flow-sensitive">flow-sensitive
typing</a>, not some special language feature. Notice how before and after
the first early return, Sorbet updates its knowledge of the type of <code>c</code>
(shown in the comments) because it knows how <code>is_a?</code> works.</p>

<p>Another example: if some other method only calls <code>lookup</code> and <code>parse</code>
(but not <code>head</code>), it doesn&rsquo;t have to mention <code>HeadError</code> in its return:</p>

<pre><code class="ruby">sig do
  params(str: String)
    # does need to mention HeadError
    .returns(T.any(Integer, LookupError, ParseError))
end
def self.bar(str)
  r = lookup(STR_MAP, str)
  return r unless r.is_a?(String)
  parse(r)
end
</code></pre>

<p>And while there&rsquo;s never a <strong>need</strong> to predeclare one monolithic error type
(like <code>AllErrorsEver</code> in Matt&rsquo;s post), if it happens to be convenient,
Sorbet still lets you, using type aliases. For example, maybe there are
a bunch of methods that all return <code>LookupError</code> and <code>ParseError</code>. We
can factor that out into a type alias:</p>

<pre><code class="ruby">MostCommonErrors = T.type_alias {T.any(LookupError, ParseError)}
</code></pre>

<p>That&rsquo;s it! Sorbet&rsquo;s union types in method returns provide a
low-friction, high value way to model how methods can fail.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have Checked Exceptions]]></title>
    <link href="https://blog.jez.io/union-types-checked-exceptions/"/>
    <updated>2021-05-29T01:21:41-07:00</updated>
    <id>https://blog.jez.io/union-types-checked-exceptions</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a common question I get asked about Sorbet:</p>

<blockquote><p>Does Sorbet support checked exceptions, like Java?</p></blockquote>

<p>(In fact, this was the <a href="https://youtu.be/odmlf_ezsBo?t=1921">first question</a> I was asked at my <a href="https://jez.io/talks/state-of-sorbet-2019/">first
conference talk</a>.)</p>

<p>The answer: Sorbet doesn&rsquo;t support checked exceptions, and I don&rsquo;t think
it ever should.</p>

<!-- more -->


<p>Before I dive in, there are two pretexts I&rsquo;m assuming: either you asked
this question and someone linked you this post, or the post title was
enough to catch your attention. Either way, I&rsquo;m going to take for
granted that you know what I mean by &ldquo;checked exceptions.&rdquo; If you want a
quick refresher, jump down to the <a href="#appendix">Appendix</a> and then come
back.</p>

<p>My claim is that checked exceptions are a poor man&rsquo;s ad hoc union types,
that since Sorbet has ad hoc union types it doesn&rsquo;t need checked
exceptions. I&rsquo;ll discuss this claim in three parts:</p>

<ul>
<li>I&rsquo;ll give some background on what it means for union types to be &ldquo;ad
hoc,&rdquo; which applies to Sorbet&rsquo;s union types but are somewhat rare.</li>
<li>I&rsquo;ll describe a translation from checked exceptions in Java to
union-typed returns in Ruby with a concrete example.</li>
<li>I&rsquo;ll give evidence for why the union types approach is better.</li>
</ul>


<p>(If you want to skip straight to the good stuff, the analysis <a href="#analysis">is down
here</a>.)</p>

<h2>Background: Sorbet&rsquo;s union types</h2>

<blockquote><p>The throws clause is the only point in the entire Java language that
allows union types. You can tack &ldquo;throws A,B,C&rdquo; onto a method
signature meaning it might throw A or B or C, but outside of the
throws clause you cannot say &ldquo;type A or B or C&rdquo; in Java.</p>

<p>— James Iry, <em><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t
In Java</a></em> (2012)</p></blockquote>

<p>Sorbet supports <a href="https://sorbet.org/docs/union-types">union types</a>. More specifically, Sorbet&rsquo;s union types
are ad hoc: any number of types can be unioned together on demand:</p>

<pre><code class="ruby">sig {returns(T.any(A, B, C))}
def foo; ...; end
</code></pre>

<p>By contrast, many languages with union types require predeclaring a
union&rsquo;s variants, for example in Rust:</p>

<pre><code class="rust">enum AorBorC {
    A(A),
    B(B),
    C(C),
}
</code></pre>

<p>That Sorbet allows defining union types on demand is similar to Java&rsquo;s
<code>throws</code> clause, but more powerful: <code>throws A, B, C</code> is not a type,
while <code>T.any(A, B, C)</code> is. We&rsquo;ll see why that matters below.</p>

<h2>Example: From checked exceptions to union types</h2>

<p>Using Sorbet&rsquo;s ad hoc union types, it&rsquo;s mechanical to convert Java-style
checked exceptions to Sorbet-annotated Ruby. To demonstrate:</p>

<pre><code class="java">Currency parseCurrency(String currencyStr) throws ParseException {
    Currency currency = KNOWN_CURRENCIES.get(currencyStr);
    if (currency == null) {
        throw new ParseException(
          "'" currencyStr + "' is not a valid currency", 0);
    }

    return currency;
}
</code></pre>

<p>This is a somewhat contrived Java method, but it&rsquo;ll be good enough to
demonstrate the concepts.</p>

<p>If <code>parseCurrency</code> is given a string it can&rsquo;t handle, it raises a
<code>ParseException</code>. It declares this with <code>throws</code> because
<code>ParseException</code> is a checked exception. If the currency string is
recognized, it returns some <code>Currency</code> object.</p>

<p>Here&rsquo;s how we&rsquo;d write that in Sorbet:</p>

<pre><code class="ruby"># (0) Ruby's standard library doesn't have `ParseException`,
# so I've re-implemented it.
class ParseError &lt; T::Struct
  const :message, String
  const :offset, Integer
end

# (1) return type + `throws` becomes just `returns`
# (2) Return type uses `T.any`
sig do
  params(currency_str: String)
    .returns(T.any(Currency, ParseError))
end
def parse_currency(currency_str)
  currency = KNOWN_CURRENCIES[currency_str]
  if currency.nil?
    # (3) `throw` becomes `return`
    return ParseError.new(
      message: "'#{currency_str}' is not a valid currency",
      offset: 0
    )
  end

  currency
end
</code></pre>

<p>The important changes:</p>

<ol>
<li>Where Java had a return type and a <code>throws</code> clause, Sorbet just has a
return type.</li>
<li>Sorbet&rsquo;s return type is a union type (<code>T.any(...)</code>). It mentions the Java
method&rsquo;s return type and all the exceptions mentioned in the <code>throws</code>.</li>
<li>Where the Java example uses <code>throw</code>, the Ruby example uses <code>return</code>.</li>
</ol>


<p>Our translation isn&rsquo;t complete until we see how the <code>parseCurrency</code>
caller side changes. In Java, we call <code>parseCurrency</code> like this:</p>

<pre><code class="java">Charge createCharge(int amount, String currencyStr) throws ParseException {
    Currency currency = parseCurrency(currencyStr);
    return new Charge(amount, currency);
}
</code></pre>

<p>With Sorbet, this snippet becomes:</p>

<pre><code class="ruby">sig do
  params(amount: Integer, currency_str: String)
    .returns(T.any(Charge, ParseError))
end
def create_charge(amount, currency_str)
  currency = parse_currency(currency_str)
  return currency unless currency.is_a?(Currency)

  Charge.new(amount: amount, currency: currency)
end
</code></pre>

<p>As before, the <code>throws</code> clause in Java becomes a union-typed return in Ruby.</p>

<p>The new bit is the explicit <code>return ... unless ...</code>. Whereas uncaught
exceptions implicitly bubble up to the caller, return values only bubble
up if explicitly returned. This is a key benefit of the union types
approach, which brings us to our next section.</p>

<h2 id="analysis">Analysis: Why the union types approach is better</h2>


<p>To recap, Sorbet&rsquo;s union types are ad hoc, much in the same sense as the
classes mentioned in Java&rsquo;s <code>throws</code> clause. When converting from <code>Java</code> to
<code>Ruby</code>, a single, union-typed return takes the place of a separate return
type and <code>throws</code> clause.</p>

<p>First off, this translation preserves the best parts of checked
exceptions:</p>

<ul>
<li><p>A method&rsquo;s failure modes still appear in an <strong>explicit, public API</strong>.</p>

<p>In both Java and Ruby, the method signature behaves as machine-checked
error documentation.</p></li>
<li><p>Ad hoc error specifications enable <strong>low-friction composition</strong>.</p>

<p>In both Java and Ruby, if our method is the first to combine two
methods with unrelated failure modes, there&rsquo;s no ceremony to
predeclare that combination. Instead, we just mention one more class
in the method&rsquo;s signature.</p></li>
</ul>


<p>But this approach is not only as good, it&rsquo;s better, because:</p>

<ul>
<li><p>As a language feature, <strong>union types are not special</strong>.</p>

<p>Union types are types. Like other types, we can store them in
variables. We can factor common error recovery code into helper
functions. We can map functions returning union types over lists. We
can write type aliases that abbreviate commonly-grouped error classes.
We can&rsquo;t do any of this with checked exceptions, and this is the most
common complaint against them.</p></li>
<li><p>Union types have <strong>call-site granularity</strong>, not method-body
granularity.</p>

<p>The union types approach forces a choice of how to handle errors at
each call site. This is more robust in the face of changing code,
because new call sites should not necessarily inherit the error
handling logic of existing call sites. Just because one
<code>ParseException</code> was uncaught and mentioned in the <code>throws</code> does not
mean all of them should be.</p></li>
</ul>


<p>And finally, let me get out ahead of some common counter arguments.</p>

<blockquote><p>The union types approach requires more typing at the call site!</p></blockquote>

<p>Yep. But I&rsquo;ve already counted this as a blessing, not a curse.</p>

<blockquote><p>But real-world Ruby code already uses exceptions!</p></blockquote>

<p>Yep. But in Java too, the world is already split into checked and
unchecked exceptions. In both Java and Ruby, exceptions are a fact of
life, and you&rsquo;ll always need a way to deal with unexpected exceptions
(e.g., comprehensive tests, automated production alerting, etc.).</p>

<blockquote><p>With checked exceptions, I could handle all the failures at once!</p></blockquote>

<p>That&rsquo;s true; with checked exceptions, it&rsquo;s easy to write a single
<code>catch</code> statement that handles all failures due to, say, a
<code>ParseException</code> in a whole region of code, avoiding the need for code
repetition.</p>

<p>The upshot is that with union types, we can just use functions. Take
everything in the <code>catch</code> body, put it in a helper function, and call it
at each call site.  This cuts down on duplication, and I already
mentioned how call-site granularity is a win.</p>

<h2>I love union types</h2>

<p>That&rsquo;s pretty much it. Sorbet doesn&rsquo;t need checked exceptions, it
already has ad hoc union types.</p>

<hr />

<h2 id="appendix">Appendix: Checked Exceptions</h2>


<p>As a quick refresher, <a href="https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions">checked exceptions</a> are a feature popularized by
Java. The syntax looks like this:</p>

<pre><code class="java">void doThing() throws MyException {
    // ...
}
</code></pre>

<p>The <code>throws</code> keyword is a part of the method&rsquo;s signature, just like
argument and return types. It declares that this method might throw
<code>MyException</code>.</p>

<p>Since it&rsquo;s a part of this method&rsquo;s signature the <code>throws</code> annotation
will be checked at all call sites (just like argument and return types).
A method containing calls to <code>doThing</code> must either <code>catch</code> all mentioned
exceptions or repeat any maybe-thrown-but-uncaught exceptions in its own
<code>throws</code> clause.</p>

<p>If a method throws multiple classes of exceptions, they can all be
listed:</p>

<pre><code class="java">void doThing() throws MyException, YourException, AnotherException {
    // ...
}
</code></pre>

<p>The argument in favor of checked exceptions is that they&rsquo;re explicit and
machine-checked. Users don&rsquo;t have to guess at what a method might throw,
or hope that there&rsquo;s accurate documentation—all benefits shared by
static typing in general, which is a sympathetic goal.</p>

<p>Checked exceptions seem like a good feature on paper. In practice,
they&rsquo;re generally regretted. I&rsquo;m nowhere near the first person to come
to this conclusion, so instead I&rsquo;ll link you to some previous
discussions:</p>

<ul>
<li><a href="https://www.artima.com/articles/the-trouble-with-checked-exceptions">The Trouble with Checked Exceptions</a>, A Conversation
with Anders Hejlsberg</li>
<li><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t In
Java</a>, by James Iry</li>
<li><a href="https://ericlippert.com/2008/09/10/vexing-exceptions/">Vexing Exceptions</a>, by Eric Lippert</li>
</ul>


<p>(The last one isn&rsquo;t actually about checked exceptions: it&rsquo;s just about
exceptions and I like it, so I included it.)</p>

<p>Java has been copied and imitated for decades. Among all the features we
see other languages copy from Java, checked exceptions are absent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring Ruby with clangd]]></title>
    <link href="https://blog.jez.io/clangd-ruby/"/>
    <updated>2020-07-21T15:40:23-07:00</updated>
    <id>https://blog.jez.io/clangd-ruby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve managed to get LSP-based IDE features powered by <a href="https://clangd.llvm.org/">clangd</a> working
for the Ruby VM&rsquo;s source code (in my case, in Vim). Here&rsquo;s how I did it!</p>

<!-- more -->


<p>I&rsquo;ve been making a point to learn more about <a href="/search-down-the-stack/">things I depend
on</a> recently. Today, that means learning about
Ruby. And what better way to learn than to check out the source code,
and jump around?</p>

<p><a href="https://clangd.llvm.org/">clangd</a> is an editor-agnostic language server that uses the <a href="https://langserver.org/">Language
Server Protocol</a> to power IDE-like features in
your preferred text editor. All it needs is a <code>compile_commands.json</code>,
which is basically a mapping of filename to options to pass to <code>clang</code>
so that it knows things like which warnings to enable and where to
search for header files.</p>

<p><a href="https://clangd.llvm.org/">clangd</a> works best for projects built using <code>cmake</code>, but the Ruby VM
doesn&rsquo;t use <code>cmake</code>. Regardless, we can make a <code>compile_commands.json</code>
file by using <a href="https://github.com/rizsotto/Bear">Bear</a> to trace the execution of a Ruby build, and use the
trace information to write out a <code>compile_commands.json</code> file.</p>

<h2>Steps</h2>

<p>I could only get these steps to work for Linux, as the Bear README
mentions that on macOS you have to disable System Integrity Protection
to get it to work.</p>

<h3>1. Install <a href="https://github.com/rizsotto/Bear">Bear</a></h3>

<p>I describe how I built Bear from source in the Appendix.</p>

<h3>2. Clone the Ruby source code.</h3>

<pre><code class="bash">git clone https://github.com/ruby/ruby
cd ruby
</code></pre>

<h3>3. Configure the Ruby build.</h3>

<p>We have to tell the <code>configure</code> script to use Clang to compile (or
if you&rsquo;re confident that your system compiler toolchain is Clang,
you can just run <code>./configure</code>).</p>

<pre><code class="bash"># Create the ./configure file
autoconf
# This only works when using clang to build Ruby
./configure CC=clang
</code></pre>

<h3>4. Use <code>bear</code> to invoke <code>make</code></h3>

<p>Bear will use a dynamically preloaded library to trace system calls
that exec <code>clang</code> processes, looking at things like the command line
arguments given to Clang.</p>

<pre><code class="bash">bear make
</code></pre>

<h3>5. That&rsquo;s it!</h3>

<p>The output is <code>./compile_commands.json</code>, which should be non-empty. If
it&rsquo;s empty or just has <code>[]</code>, it didn&rsquo;t work. There&rsquo;s some
troubleshooting in the <a href="https://github.com/rizsotto/Bear">Bear</a> README.</p>

<p>The <code>compile_commands.json</code> file will be consumed by <code>clangd</code> in your
editor. Check <a href="https://langserver.org">https://langserver.org</a> to find an LSP client for your
preferred editor, and follow its setup instructions.</p>

<p>Once you&rsquo;ve built the <code>compile_commands.json</code> file and configured your
editor to use LSP with <code>clangd</code>, you should be able to do things like
Jump to Definition and Hover on the Ruby source code!</p>

<h2>Appendix: Building Bear from source</h2>

<p>This is probably common knowledge for people who use <code>cmake</code> regularly,
but this is how I built Bear from source, because I built it on a
machine where I didn&rsquo;t have root so I couldn&rsquo;t write to <code>/usr/local</code>.</p>

<pre><code class="bash">git clone https://github.com/rizsotto/Bear
cd Bear
mkdir build
cd build

# Install to $HOME/.local/bin instead of /usr/local/bin
cmake .. "-DCMAKE_INSTALL_PREFIX=$HOME/.local"
make -j$(nproc)
make install

# → $HOME/.local/bin/bear exists now
</code></pre>

<h2>Appendix: LSP in Neovim with LanguageClient-neovim</h2>

<p>I use Neovim. My preferred LSP client is <a href="https://github.com/autozimu/LanguageClient-neovim">LanguageClient-neovim</a>. Here&rsquo;s
the parts of my Neovim config files that setup <code>clangd</code>:</p>

<p><a href="https://github.com/jez/dotfiles/blob/865a74d93d8ab1c28713ae0dcd53797b6c26dc6a/vim/plug-settings.vim#L576-L587">→ <code>vim/plug-settings.vim</code> in jez/dotfiles</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linkers & Ruby C Extensions]]></title>
    <link href="https://blog.jez.io/linkers-ruby-c-exts/"/>
    <updated>2020-06-07T12:05:07-05:00</updated>
    <id>https://blog.jez.io/linkers-ruby-c-exts</id>
    <content type="html"><![CDATA[<p>I recently learned that linkers are really cool. It all started when I
saw an error message that looked something like this:</p>

<pre><code>❯ rake test
symbol lookup error: /home/jez/.../foo.so: undefined symbol bar
</code></pre>

<p>I <a href="/search-down-the-stack/">already wrote</a> about finding where this
error was coming from. The tl;dr is that it was coming from GNU&rsquo;s libc
implementation:</p>

<pre><code>❯ rg -t c 'symbol lookup error'
dl-lookup.c
876:      _dl_signal_cexception (0, &amp;exception, N_("symbol lookup error"));
</code></pre>

<p>That led me to a fun exploration of how linux linkers work, and how Ruby
C extensions rely on them.</p>

<p>I always knew that Ruby C extensions existed (that they <a href="https://twitter.com/asolove/status/1261339091485917184">break all the
time</a> is a constant reminder&hellip;) but I never really connected
the dots between &ldquo;here&rsquo;s some C code&rdquo; and how Ruby actually runs that
code.</p>

<p>Ruby C extensions are just shared libraries following certain
conventions. Specifically, a Ruby C extension might look like this:</p>

<pre><code class="c">#include "ruby.h"

VALUE my_foo(VALUE self, VALUE val) {
  return rb_funcall(self, rb_intern("puts"), 1, val)
}

// This function's name matters:
void Init_my_lib() {
  rb_define_method(rb_cObject, "foo", my_foo);
}
</code></pre>

<p>The important part is that the name of that <code>Init_my_lib</code> function
matters. When Ruby sees a line like</p>

<pre><code class="ruby">require_relative './my_lib'
</code></pre>

<p>it looks for a file called <code>my_lib.so</code> (or <code>my_lib.bundle</code> on macOS),
asks the operating system to load that file as a shared library, and
then looks for a function with the name <code>Init_my_lib</code> inside the library
it just loaded.</p>

<p>When that function runs, it&rsquo;s a chance for the C extension to do
the same sorts of things that a normal Ruby file might have done if it
had been <code>require</code>&rsquo;d. In this example, it defines a method <code>foo</code> at the
top level, almost like the user had written normal Ruby code like this:</p>

<pre><code class="ruby my_lib.rb">def foo(val)
  puts val
end
</code></pre>

<p>That&rsquo;s kind of wild! That means:</p>

<ul>
<li>C programs can load libraries dynamically at runtime, using arbitrary
user input.</li>
<li>C programs can then ask if there&rsquo;s a function defined in that library
with an arbitrary name, and get a function pointer to call it if there
is!</li>
</ul>


<p>I was pretty shocked to learn this, because my mental model of how
linking worked was that it split evenly into two parts:</p>

<ul>
<li><p>&ldquo;My application is statically linked, where all the code and libraries
my application depends on are compiled into my binary.&rdquo;</p></li>
<li><p>&ldquo;My application is dynamically linked, which means my binary
pre-declares some libraries that must be loaded before my program can
start running.&rdquo;</p></li>
</ul>


<p>There&rsquo;s actually a third option!</p>

<p>Then I looked into what code Ruby actually calls to do this. I found the
code in <code>dln.c</code>:</p>

<pre><code class="c dln.c">/* Load file */
if ((handle = (void*)dlopen(file, RTLD_LAZY|RTLD_GLOBAL)) == NULL) {
    error = dln_strerror();
    goto failed;
}
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1341">→ View on github.com</a></p>

<p>Ruby uses the <code>dlopen(3)</code> function in libc to request that an arbitrary
user library be loaded. From the man page:</p>

<blockquote><p>The function dlopen() loads the dynamic shared object (shared library)
file named by the null-terminated string filename and returns an
opaque &ldquo;handle&rdquo; for the loaded object.</p>

<p>&mdash; man dlopen</p></blockquote>

<p>The next thing Ruby does with this opaque <code>handle</code> is to find if the
thing it just loaded has an <code>Init_&lt;...&gt;</code> function inside it:</p>

<pre><code class="c dln.c">init_fct = (void(*)())(VALUE)dlsym(handle, buf);
if (init_fct == NULL) {
    const size_t errlen = strlen(error = dln_strerror()) + 1;
    error = memcpy(ALLOCA_N(char, errlen), error, errlen);
    dlclose(handle);
    goto failed;
}
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1363-L1369">→ View on github.com</a></p>

<p>It uses <code>dlsym(3)</code> (again in libc) to look up a method with an arbitrary
name (<code>buf</code>) inside the library it just opened (<code>handle</code>). That function
must exist—if it doesn&rsquo;t, it&rsquo;s not a valid Ruby C extension and Ruby
reports an error.</p>

<p>If <code>dlsym</code> found a function with the right name, it stores a function
pointer into <code>init_fct</code>, which Ruby immediately dereferences and calls:</p>

<pre><code class="c dln.c">/* Call the init code */
(*init_fct)();
</code></pre>

<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1370-L1371">→ View on github.com</a></p>

<p>It&rsquo;s still kind of mind bending to think that C provides this level of
&ldquo;dynamism.&rdquo; I had always thought that being a compiled language meant
that the set of functions a C program could call was fixed at compile
time, but that&rsquo;s not true at all!</p>

<p>This search led me down a rabbit hole of learning more about linkers,
and now I think they&rsquo;re super cool—and far less cryptic! I <strong>highly</strong>
recommend <em>Chapter 7: Linking</em> from <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer&rsquo;s
Perspective</a> if this was interesting to you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have FixMe Comments]]></title>
    <link href="https://blog.jez.io/sorbet-fixme-comment/"/>
    <updated>2020-02-11T23:18:40-08:00</updated>
    <id>https://blog.jez.io/sorbet-fixme-comment</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Sorbet has no way to ignore an error on a specific line with a magic
comment. This is different from all other gradual static type checkers I
know about:</p>

<ul>
<li>TypeScript: <code>// @ts-ignore</code></li>
<li>Flow: <code>// $FlowFixMe</code></li>
<li>Hack: <code>// HH_FIXME</code></li>
<li>MyPy: <code># type: ignore</code></li>
</ul>


<p>When I first joined the team, I was skeptical. But having seen it play
out in practice, it&rsquo;s actually worked great.</p>

<p>Instead of ignore comments, Sorbet has <code>T.unsafe</code>, which accepts
anything and returns it unchanged (so for example <code>T.unsafe(3)</code>
evaluates to <code>3</code>). The trick is that it forces Sorbet to forget the
type of the input statically. This confers the power to silence most
errors. For example:</p>

<pre><code class="ruby">1 + '1'            # error: Expected `Integer` but found `String`
T.unsafe(1) + '1'  # no error
</code></pre>

<p><a href="https://sorbet.run/#%20%20%20%20%20%20%20%20%201%20%20%2B%20'1'%20%20%23%20error%3A%20Expected%20%60Integer%60%20but%20found%20%60String%60%0AT.unsafe(1)%20%2B%20'1'%20%20%23%20no%20error">→ View on sorbet.run</a></p>

<p>In this example, Sorbet knows that calling <code>+</code> on an Integer with a
String would raise an exception at runtime, and so it reports a static
type error. But wrapping the <code>1</code> in a call to <code>T.unsafe</code> causes Sorbet
to think that the expression <code>T.unsafe(1)</code> has type <code>T.untyped</code>. Then,
like for all untyped code, Sorbet admits the addition.</p>

<p>All Sorbet-typed Ruby programs must grapple with <code>T.untyped</code>. Every
Sorbet user has to learn how it works and what the tradeoffs of using it
are. In particular, that <code>T.untyped</code> is viral. Given a variable that&rsquo;s
<code>T.untyped</code>, all method calls on that variable will also be untyped:</p>

<pre><code class="ruby"># typed: true
extend T::Sig

sig {params(x: T.untyped).void}
def foo(x)
  y = x.even?
# ^ type: T.untyped
  z = !y
# ^ type: T.untyped
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.untyped).void%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20x.even%3F%0A%23%20%5E%20type%3A%20T.untyped%0A%20%20z%20%3D%20!y%0A%23%20%5E%20type%3A%20T.untyped%0Aend">→ View on sorbet.run</a></p>

<p>In this example <code>x</code> enters the method as <code>T.untyped</code>, so calling the
method <code>.even?</code> propagates the <code>T.untyped</code> to <code>y</code>. Then again because
<code>y</code> is untyped, calling<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <code>!</code> on it propgates the <code>T.untyped</code> to
<code>z</code>. There are plenty of reasons to <a href="https://sorbet.org/docs/gradual">both embrace and avoid</a>
<code>T.untyped</code> in a type system but the point is: Sorbet&rsquo;s type system
already has it.</p>

<p>Re-using <code>T.untyped</code> as the way to silence errors plays nicely with
everything else in Sorbet:</p>

<ul>
<li><p>Hover and jump to definition become tools to track down the source of
silenced errors.</p></li>
<li><p>Errors are effectively silenced at the source of the error. There are
no errors downstream that only show up because an error was silenced
earlier.</p></li>
<li><p>We plan to eventually build a tool to show which parts of a file are
untyped (to see things like which methods don&rsquo;t have signatures). That
tool will trivially take suppressed errors into account.</p></li>
</ul>


<p>The <a href="https://sorbet.org/docs/gradual">Sorbet docs</a> bill <code>T.untyped</code> as the way to &ldquo;turn off the
type system.&rdquo; By reusing <code>T.untyped</code> to supress errors, silencing one
error means silencing them all, which is a win for simplicity.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Did you know that <code>!x</code> in Ruby is syntactic sugar for <code>x.!()</code>, which means that you can override <code>!</code> to make it do something else?<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
