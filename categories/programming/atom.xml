<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/programming/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-12-16T18:10:55-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Programming Language Choice]]></title>
    <link href="https://blog.jez.io/on-language-choice/"/>
    <updated>2019-06-21T09:30:25-07:00</updated>
    <id>https://blog.jez.io/on-language-choice</id>
    <content type="html"><![CDATA[<p>My opinion on programming language choice has changed over the years,
from &ldquo;Java is the only language I know&rdquo; to &ldquo;Standard ML is clearly the
right answer&rdquo; to something a little more nuanced now. Still, since this
post is largely my <strong>opinion</strong>, I withold the right to make claims
without evidence and say things you&rsquo;ll disagree with. But enough
qualifiers—let&rsquo;s get into it.</p>

<!-- more -->


<p>Earlier in my career, I thought that the answer to &ldquo;which language
should I use&rdquo; ought to be constant. That there should be One Best
Language. And while I still think it makes sense to compare languages on
the relative merits of their designs, answering the question &ldquo;which
language is <strong>best</strong> designed&rdquo; is a completely different question. The
question I&rsquo;ll answer in this post is: &ldquo;Which language should I choose to
start this new project?&rdquo;<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Answering &ldquo;which language is best designed&rdquo; is better left to
programming language theorists. To claim that I (or most people reading
this) have any authority to answer this question is absurd. Language
design is a well-studied, complex problem, with a wealth of
peer-reviewed, prior work. One semester studying programming language
theory in college is not sufficient qualification to answer this
question.</p>

<p>As it turns out, most people trying to answer the former question of
&ldquo;which language is best designed&rdquo; knowingly or unknowingly end up
answering the latter question: &ldquo;which language should I choose to start
this new project?&rdquo; Luckily, this is a much easier question to answer,
because we can narrow the choice space by asking questions like these:</p>

<ul>
<li>What languages does the initial team know?</li>
<li>What languages will future collaborators know?</li>
<li>What languages have strong package ecosystems? (Especially for our
domain?)</li>
<li>What performance properties must our solution have?</li>
</ul>


<p>But there&rsquo;s one big question missing, and it 100% overshadows all other
questions. Absolutely the most regret from choosing a programming
language has come from forgetting to ask this question:</p>

<p><strong>In this language, how easy is it to delete code?</strong></p>

<p>Code is a liability. More code means more to understand and more systems
to maintain. More moving parts means more points of failure. More
failures mean more people trying to fix old code with new code. Company
pressures to ship more features mean new code accumulating on top of old
code.</p>

<p>This is a nightmare.</p>

<p>Code is a liability, so regardless of language it must be trivial to
delete. And this means our language must be easy to statically analyze
(ideally, though not necessarily, a language with a type system). Static
analysis means that <strong>when</strong> I delete code, I can know whether other
code relied on it. Renaming a function, relocating files, deleting
unused features—I choose languages that make these operations easy.</p>

<p>As a quick aside, I&rsquo;d like to elaborate on what I mean by &ldquo;not
necessarily&rdquo; a type system. Take for example the case of JavaScript&rsquo;s
<code>package.json</code> files (specified with JSON) versus Ruby&rsquo;s <code>Gemfile</code>s
(specified with Ruby code). Neither of these configuration files are
&ldquo;typed&rdquo; in the traditional sense, but that does not mean they&rsquo;re
statically unanalyzable:</p>

<ul>
<li><p><code>package.json</code> files can be (and frequently are) parsed and analyzed
in any language with a JSON parser. It&rsquo;s easy to check that all
required keys are passed, that custom config for some specific package
has been set up correctly, etc.</p></li>
<li><p>On the other hand, <code>Gemfile</code>s can only be analyzed from Ruby and even
then only by actually running the code. <code>Gemfile</code>s can even have
different behavior based on the environment—only a simple <code>ENV[...]</code>
access away—so even running the code might not be enough to completely
analyze it.</p></li>
</ul>


<p>My point is that even though JSON is untyped<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> it&rsquo;s still
statically analyzable, which is better than nothing.</p>

<p>Going back to the case where the language <strong>does</strong> use a type system to
achieve static analysis, the set of features we get expands from &ldquo;safely
delete code&rdquo; to loads of other things:</p>

<ul>
<li>Types serve as machine-checked documentation.</li>
<li>Jump-to-def powered by a type system is fast and accurate.</li>
<li>Types power trustworthy autocompletion results, so people can rely on them.</li>
<li>&hellip;</li>
</ul>


<p>The full list is of course longer, but I want to re-iterate: choosing a
typed language is for me a downstream consequence of choosing a language
where it&rsquo;s trivial to delete code.</p>

<p>Until now I&rsquo;ve relied on an implicit assumption that only via static
analysis or type checking can we easily reason about how to delete code.
The alternative might be to use some sort of dynamic analysis, like
running tests, rolling out refactors behind feature flags, or using some
sort of manual QA checklist.</p>

<p>And while these techniques are still valuable, on their own they&rsquo;re a
poor substitute for static analysis. Why? First: they&rsquo;re opt in.
Programmers have to remember to write tests and to choose to use feature
flags. Static analysis on the other hand is opt out. Having chosen a
language with static analysis from the beginning, it applies everywhere.
This also means if we choose a language we&rsquo;re not satisfied with, it&rsquo;s
easier to change our mind in the future.</p>

<p>Second: they over-index on the quality of the data they&rsquo;re fed. An
example of &ldquo;poor data quality&rdquo; might be excessive use of mocks and stubs
in tests. I&rsquo;ve seen all too many test suites that overuse mocking and
stubbing to the point where they&rsquo;re really just testing the testing
framework.</p>

<p>Another common dynamic analysis technique we use where I work is adding
&ldquo;soft assertions&rdquo; which we define as an assertion that raises an
exception if it fails in tests, but logs to Sentry in production. Before
deleting the core code, we&rsquo;ll preface all calls to it with unconditional
soft assertions, and merge to production to see whether any assertions
fire. Our confidence is directly tied to how well the production data
collected in that time represents all production data.</p>

<p>How long spent waiting for no soft assertions is enough to get a
representative sample? A day? A week? What if we have behavior that only
executes on the first of the month? Or code paths that customers only
hit when they&rsquo;re computing quarterly accounting statements? Or yearly
when they&rsquo;re doing taxes? A week of data collected after changing tax
code might as well be useless if that week wasn&rsquo;t in March or April.</p>

<p>For these two reasons, dynamic analysis fails us when we need it the
most: when we&rsquo;re trying to delete the code that&rsquo;s untested, uncommonly
run, and yet critically important. With only dynamic analysis, the code
that we understand the least is also the code that&rsquo;s the hardest to
remove.</p>

<p>So here&rsquo;s my unsubstantiated claim: dynamic analysis techniques
(anything that involves running the code) are too weak to empower people
to delete code. If we want to delete code, and we do because code is a
liability, we want static analysis.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>The next thing to point out is that not all forms of static analysis are
created equal. Arguably Haskell&rsquo;s static analysis is more powerful than
C&rsquo;s. While I&rsquo;ll acknowledge that some languages give <strong>more</strong> static
guarantees than others, as long as a language can at least reason about
code that&rsquo;s been mistakenly deleted, I prefer to turn my attention to
other questions getting into those minutia. Comparing C and Haskell gets
back into debating language design which, again, is a bit fruitless.</p>

<p>After all that, here&rsquo;s my checklist when choosing a language to start a
new project:</p>

<ol>
<li>Rule out languages where we can&rsquo;t easily delete code.</li>
<li>Narrow the remaining languages to those that fit the circumstances.</li>
<li>Pick any language that&rsquo;s left, because according to step (2) they
all fit our project&rsquo;s needs.</li>
</ol>


<p>Optimizing for deleting code minimizes the biggest regret I&rsquo;ve seen
stemming from a language choice and keeps the door open so we can change
our mind in the future. As a consequence we usually pick up extra
benefits in the process (namely those that come from a good type
system), but choosing a language to fit the circumstances trumps
attempting to debate which type system is The Best.</p>

<p>&nbsp;</p>

<p><em>If you read this far and were hoping that I declare one winner in the
end, I&rsquo;m sorry to disappoint. I&rsquo;m happy to indulge you over lunch or
email, or you can read <a href="https://blog.jez.io/categories/#bash">the rest</a> of <a href="https://blog.jez.io/categories/#haskell">my blog</a> and <a href="https://blog.jez.io/categories/#sml">guess</a> at what I
might say. Regardless, thanks for your time.</em></p>

<!-- vim:tw=72:fdm=marker
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Fundamentally, I believe language choice <strong>only</strong> applies to new projects. Given an existing project, the question is not &ldquo;which language&rdquo; but instead &ldquo;should we rewrite,&rdquo; to which the answer is overwhelmingly <strong>no</strong>. But that&rsquo;s a topic for another post.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>I&rsquo;m aware that it&rsquo;s possible to use schemas and specs to approximate types for JSON, but this only goes to strengthen my argument: those make it <strong>even easier</strong> to statically analyze JSON.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>At this point you might think that I don&rsquo;t believe in dynamic analysis techniques at all. That&rsquo;s not the case, as <a href="/tests-types-correctness/">I&rsquo;ve written before</a> about how I value them. I&rsquo;m only saying that relying on running the code to check if code can be deleted safely does not work. Tests are still useful for plenty of other things.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Case Exhaustiveness in Flow]]></title>
    <link href="https://blog.jez.io/flow-exhaustiveness/"/>
    <updated>2018-04-15T20:02:26-07:00</updated>
    <id>https://blog.jez.io/flow-exhaustiveness</id>
    <content type="html"><![CDATA[<p>Compared to some other languages, <a href="https://flow.org/">Flow</a>&rsquo;s story around exhaustiveness
checking within <code>if / else</code> and <code>switch</code> statements leaves something to
be desired. By default, Flow doesn&rsquo;t do any exhaustiveness checks! But
we <strong>can</strong> opt-in to exhaustiveness checking one statement at a time.</p>

<!-- more -->


<p>In this post, we&rsquo;ll discover from the ground up how Flow&rsquo;s
exhaustiveness checking behaves. But if you&rsquo;re just looking for the
result, here&rsquo;s a snippet:</p>

<h2>TL;DR</h2>

<pre><code class="js">type A = {tag: "A"};
type B = {tag: "B"};
type AorB = A | B;

const absurd = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('This function will never run!');
}

const allGood = (x: AorB): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    return absurd(x);
  }
}

const forgotTagB = (x: AorB): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else {
    // B. This type is incompatible with the expected param type of empty.
    return absurd(x);
  }
}
</code></pre>

<h2>How Exhaustiveness Behaves in Flow</h2>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiQrACQKYCdOnngBYCGAbnsaAC4CeADngOQCCs2AQo-gJZWHXxYoUsWzdiAOyoBnNIloNQzUAF5QAbyrEA5gC5QAImYGAvgG559PO1Uatew+1MWFeVh1vKAPqHYXEAMawEtJUoJASAIy2ABQAHvru7ACU+qFiEtqqAHwaiKCg3JDxAHT2qipqRgbJ6vkFoLhUAK7YEoYAku0ARtiSAfzGFgUmoJjQ0nh1DY2YLW2dPX0SA74Gw6AmiFtyIErQ0Pjjh5IAJqDasLCnADSg3c1h8CRhRUegxKfnlBKY8KABYiTAD8aFAADE2GM4sQALZ0aCYO4EWaQYgBKhQvgUbqwcjhbiI0AAPWoQmx93GCF0cksigAwrZNDp9AZ6c46W42Ow2Iy1N5fKAfPT-EEQmEIgAmWIJJTc3mpUDpbiZHJ5ApFUrlSpVYzJdUNJqtdoGLr3ZarIb1UbjSYGgpGhampb9fhODZbHaoPYAdWIvA+SswYtuhTCrgBhGDAGtpABCMEAFRejGklMBzTtKMzmG+AOIVAGAFpiAdQIxbZguL1XSVdmAfS9CpB3rDiNG8Jh0fwayt+Jg4gjuAFeKDUGCAKIAJSnAHkp-oZkvl6BADCkgABSQBtpIA4P6VVAy2hKoGT3DTEdPhRWsHhBe43SJ8F4-EkhXh0GHvGgNCLjt+52aEinJgkAqrmdZiqE4QSAAzDKiTytg9KKsqqoqLk0zNlqOgVLqNT2rM8wmmavaWus1pjBMeBvFhWQ6o4eEYQ6czGos5qumsHrbMg3pgAAClG8B3NIQi8KmsywiqpwqlkmbUE2BCMLgoASLAYRBOQB4fGWFKApM0h1nsAAycxiZ85wUr8-yMPSXC6ZgNLjns05zguK5uQUG47nuB5HieZ5WIUaYqkEN5UHeD5Ph87TcG+H5UF+P7MW0uagABQEgX+4HBJBEQACxwXKHAKmk+7SWqGGanEZTYXR1T6oxBEsc6bF9koZEjBRdrUVV2qVPR9X1ExhGsSRbrtZsnVUS2NE4YY7IDTMv4jRa-DspxXrAGCfoBpQkwhiUB1hnuhKHHwKqxnJBattw2iEGES1pcBoGnAmezsI8RyMPi6Uqrw4w0ACeI4ClpanVG+Z6UeuhnRI0bSQA+miAT2fWoCNldKL0swAByoCnCJaZmYG6XEM00BqUCSL3B9QLRhCcD-JioC8XOABqE6XU8eCAhIjBhNocxycDDmbYE2UShIACsBVJMV3llWhBqVdVtF9XV+FLc1o1tR6k3NqAM21U4C2GklREuq17rkZW+uG2r80a2by3sWt1uUfh8T6Jg8K0MkGwFHw2AIMpfygBO2BB9gMSMMQ3TSK0pyMH71pcajyZMIHweWWHEdsFw76-B8uL4o+Za-BpjQAXc3TBqTkxgqJaYqWEdCwNI0jhXgTMQfuzQYoGIjQM0eCwC2EYVj7NCMGCMQGOnSmiHgKnCKWw9Be0FLe3QtBBlQNSox0LYop8sDb3JF50AWVA4O0mAaTQzzA8iVbnJMXeEBeOCR6AsKYO3OiYAbkfPAkA2CXHDEIImFlQ52XCFCekItkA9yggANhlghJCJVNKKwqsUHqNU1Z6kdsNLWK0dZuy6tNfBqsqjG2IU1YiZCrYdRtg1PY9JfIf38ooC8wVryXzCvePAj4+BjEnnWGYnsxHbxoMnGYmd-jZ3DpHaOsd47YETnIzYqceL02DtfA4aZZIGCwDQO4HQ4FpUDPSOMoAADKQgLFBDJqcXmLcg74j4FdM6aZpAiNWPAIE0ISCZjCuQEoBhUbvXDFw0AAjr4LAvNId8t14oA0kCpGgZUmY5mrrXHMYc7GGRVGpfh0B-QhBFqAXIKkiwARzKcIsA46C4HbtwbK+gJyDmDNfb47QgQd20BIX+UhQBQkgABDE7T2iAjLGcS8oQuyv2IP8F8zTWkd2CAZTavpuYvhAnEc+aZugAyRpiTSFJ4k30vEzSgUZoAMGwOESZYVgiILBDHOOCcuAXgsnCbm15YTBC-KlSY5xKyPyUqAp5PjnkrFeRII8kInkDjhAiFGew7pUDoNIXQIASABGjAAkoJBpAdgOCUMBwBL6EoAcAUgsBuCNIAAwlAAOwlEiMAfGARpDAAACIFmIEWVmjLTgkqoLCaAABiUgug1EJzFuKIu6jzhqAADyJmyFIrevt9CJnKvUBRId-jKLYKor5Gik4WHMEg8WUE2XoKKohZCpVULoXqMrXquETZDQYRbUiusbbdRVrNAwdCGqa0YexZhE1g1UNDbVB2kanakJduNG07sU3DQVRo+IWjPSDSXEqnKEgAAcTqeQuqwQrD1Go8GJsIQxItUaA2DAzXrEN3r+r0KdNGy2HbWFFvYZw35AVeFXlCp3HgojN7dIxClS+fRYTUACqPaRtAJGmxzZa04+b1pAA"><strong>Read on flow.org/try/</strong></a></p>

<p>Here we have a type <code>AorB</code> with two variants;</p>

<pre><code class="js">type A = {tag: "A"};
type B = {tag: "B"};
type AorB = A | B;

const fn1 = (x: AorB): string =&gt; {
  if(x.tag === "A"){
    return "In branch A";
  } else {
    return "In branch B";
  }
}
</code></pre>

<p>All well and good, but what if we add a new case?
For example, what if we take the snippet above and add this:</p>

<pre><code class="js">type C = {tag: "C"};
type AorBorC = A | B | C;

const fn2 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else {
    return "In branch B";
  }
}
</code></pre>

<p>Wait a second, it type checks!</p>

<p>That&rsquo;s because we used a catch-all <code>else</code> branch. What if we make each
branch explicit?</p>

<pre><code class="js">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.
const fn3 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  }
}
</code></pre>

<p>Phew, so it&rsquo;s reminding us that we&rsquo;re not covering all the cases.
Let&rsquo;s add the new <code>C</code> case:</p>

<pre><code class="js">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.
const fn4 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  }
}
</code></pre>

<p>Hmm: it still thinks that we might return <code>undefined</code>, even though we&rsquo;ve
definitely covered all the cases&hellip; 🤔</p>

<p>What we <strong>can</strong> do is add a default case, but ask Flow to <strong>prove</strong> that
we can&rsquo;t get there, using Flow&rsquo;s <code>empty</code> type:</p>

<pre><code class="js">const fn5 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  } else {
    (x: empty);
    throw new Error('This will never run!');
  }
}
</code></pre>

<p>The <code>throw new Error</code> line above will never run, because it&rsquo;s not
possible to construct a value of type <code>empty</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (&ldquo;There are no
values in the empty set.&rdquo;)</p>

<p>If we adopt this pattern everywhere, we&rsquo;d see this error message if we
forgot to add the new case for <code>C</code>:</p>

<pre><code class="js">const fn6 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    // C. This type is incompatible with empty.
    (x: empty);
    throw new Error('absurd');
  }
}
</code></pre>

<p>Flow tells us &ldquo;Hey, I found a C! So I couldn&rsquo;t prove that this switch
was exhaustive.&rdquo;</p>

<p>But this pattern is slightly annoying to use, because ESLint complains:</p>

<pre><code>no-unused-expressions: Expected an assignment or function call and instead saw an expression.
</code></pre>

<p>We can fix this by factoring that <code>empty ... throw</code> pattern into a
helper function:</p>

<pre><code class="js">// 'absurd' is the name commonly used elsewhere for this function. For example:
// https://hackage.haskell.org/package/void-0.7.1/docs/Data-Void.html#v:absurd
const absurd = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('absurd');
};

const fn7 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  } else {
    return absurd(x);
  }
}

const fn8 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    // C. This type is incompatible with the expected param type of empty.
    return absurd(x);
  }
}
</code></pre>

<p>So there you have it! You can put that helper function (<code>absurd</code>) in a
file somewhere and import it anywhere. You could even give it a
different name if you want! I&rsquo;ve been using this pattern in all the Flow
code I write these days and it&rsquo;s been nice to rely on it when doing
refactors.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Of course, this presumes that Flow&rsquo;s type system is sound, which it isn&rsquo;t. It&rsquo;s possible to accidentally inhabit <code>empty</code> if you use <code>any</code>! Moral of the story: be <em>very</em> diligent about eradicating <code>any</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Review from the Command Line]]></title>
    <link href="https://blog.jez.io/cli-code-review/"/>
    <updated>2018-01-13T13:14:24-08:00</updated>
    <id>https://blog.jez.io/cli-code-review</id>
    <content type="html"><![CDATA[<p>I do the bulk of my code reviews from the command line, especially when
reviewing larger changes. I&rsquo;ve built up a number of tools and config
settings that help me dig into the nuances of the code I&rsquo;m reviewing, so
that I can understand it better than if I were just browsing online.</p>

<!-- more -->


<p>In particular, I&rsquo;ll walk through how I&hellip;</p>

<ul>
<li>check out the code in the first place,</li>
<li>get a feel for what changed,</li>
<li>visualize the relationships between the files that changed,</li>
<li>bring up the code diffs in Vim,</li>
<li>leverage the unique power of the editor and the terminal.</li>
</ul>


<p>But first, let&rsquo;s talk briefly about the point of code review in the
first place.</p>

<h2>Code review philosophy</h2>

<p>When I ask that other people review my code, it&rsquo;s an opportunity for me
to teach them about the change I&rsquo;ve just made. When I review someone
else&rsquo;s code, it&rsquo;s to learn something from them. Some other benefits of
code review include:</p>

<ul>
<li>Team awareness (to keep a pulse on what else is going on within your
team).</li>
<li>Finding alternative solutions (maybe there&rsquo;s a small change that lets
us kill two birds with one stone).</li>
</ul>


<p>If this is different from how you think about code review, <a href="https://www.youtube.com/watch?v=PJjmw9TRB7s">check out
this talk</a>. Code review is a powerful tool for
learning and growing a team.</p>

<p>With that out of the way, let&rsquo;s dive into the tools I use to maximize
benefit I get from code review.</p>

<h2>Checking out the code</h2>

<p>The first step to reviewing code in the terminal is to check out the
code in the first place. One option is to simply to <code>git pull</code> and then
<code>git checkout &lt;branch&gt;</code>. But if you happen to be using GitHub, we can
get this down to just one command:</p>

<pre><code>hub pr checkout &lt;pr-number&gt;
</code></pre>

<p>It works using <a href="https://github.com/github/hub">hub</a>, which is a tool that exposes various features of
GitHub from the command line. If the pull request is from someone else&rsquo;s
fork, <code>hub</code> is even smart enough to add their fork as a remote and fetch
it.</p>

<h2>At first glance</h2>

<p>With the branch checked out locally, usually my next step is to get a
feel for what changed. For this, I&rsquo;ve written a git alias that shows:</p>

<ul>
<li>which files changed</li>
<li>how many lines changed in each file (additions and deletions)</li>
<li>how many lines changed overall</li>
</ul>


<p><a class="image-link" href="/images/git-stat.png"><img class="fullwidth" src="/images/git-stat.png" title="git stat" ></a></p>

<p>Here&rsquo;s the definition of <code>git stat</code> from my <code>~/.gitconfig</code>:</p>

<pre><code class="bash">[alias]
    # list files which have changed since REVIEW_BASE
    # (REVIEW_BASE defaults to 'master' in my zshrc)
    files = !git diff --name-only $(git merge-base HEAD \"$REVIEW_BASE\")

    # Same as above, but with a diff stat instead of just names
    # (better for interactive use)
    stat = !git diff --stat $(git merge-base HEAD \"$REVIEW_BASE\")
</code></pre>

<p>Under the hood, it just works using <code>git diff</code>, <code>git merge-base</code>, and a
personal environment variable <code>REVIEW_BASE</code>.</p>

<p><code>REVIEW_BASE</code> lets us choose which branch to review relative to. Most of
the time, <code>REVIEW_BASE</code> is <code>master</code>, but this isn&rsquo;t always the case! Some
repos branch off of <code>gh-pages</code>. Sometimes I like to review the most
recent commit as if it were its own branch.</p>

<p>To review the code relative so some other base, set <code>REVIEW_BASE</code> before
running <code>git stat</code>:</p>

<pre><code class="bash"># Review between 'gh-pages' and the current branch
REVIEW_BASE=gh-pages git stat

# Review changes made by the last commit of this branch:
REVIEW_BASE=HEAD^ git stat
</code></pre>

<p>I have <code>export REVIEW_BASE=master</code> in my <code>~/.bashrc</code>, because most
projects branch off of <code>master</code>.</p>

<p>Nothing too crazy yet&mdash;GitHub can already do everything we&rsquo;ve seen so
far. Let&rsquo;s start to up the ante.</p>

<h2>Visualizing file change frequency</h2>

<p>I&rsquo;ve written a short script that shows me a visualization of how
frequently the files involved in this branch change over time:</p>

<p><a class="image-link" href="/images/git-heatmap.png"><img class="fullwidth" src="/images/git-heatmap.png" title="git heatmap" ></a></p>

<p>This command identifies two main things:</p>

<ul>
<li><p><strong>Files with lots of changes</strong>.</p>

<p>Files that have changed a lot in the past are likely to change in the
future. I review these files with an eye towards what the <em>next</em>
change will bring.</p>

<p><em>&ldquo;Is this change robust enough to still be useful in the future?
Will we throw this out soon after merging it?&rdquo;</em></p></li>
<li><p><strong>Files with few changes</strong>.</p>

<p>Files that aren&rsquo;t changed frequently are more likely to be brittle.
Alternatively, it&rsquo;s often the case that infrequently changed files
stay unchanged because the change is better made elsewhere.</p>

<p><em>&ldquo;Does this change challenge an implicit assumption so that some other
part of the code was relying on? Is there a better place for this
change?&rdquo;</em></p></li>
</ul>


<p>Those two commands (<code>git stat</code> and <code>git heatmap</code>) are how I kick off my
code review: getting a birds-eye view of the change and some historical
context for what I&rsquo;m dealing with. Next, I drill down into the
relationships between the files that changed.</p>

<h2>Visualizing relationships between files</h2>

<p>At work I review JavaScript files, so I&rsquo;ve built out this next bit of
tooling specifically for JavaScript.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It helps to understand
which files import others, so I have a command that computes the
dependency graph of the files changed on this branch:</p>

<p><a class="image-link" href="/images/git-depgraph.png"><img class="fullwidth" src="/images/git-depgraph.png" title="git depgraph" ></a></p>

<p>This is where we start to see some distinct advantages over what GitHub
provides. As you see above, the <code>git depgraph</code> alias calculates the
dependency graph for files changed by this branch. Why is this useful?</p>

<ul>
<li><p>Maybe we want to start reviewing from <code>Provider.js</code>, since it doesn&rsquo;t
depend on any other files that have changed.</p></li>
<li><p>Maybe we want to work the other way: start with <code>Elements.js</code> so we
know the motivation for why <code>Provider.js</code> had to changed in the first
place.</p></li>
</ul>


<p>In either case, we can see the structure of the change. Three files
depend on <code>Elements.js</code>, so it&rsquo;s serving the needs of many modules.
<code>Element.js</code> only has one dependency, etc. Each branch&rsquo;s dependency
graph shows different information; it can be surprising what turns up.</p>

<p>I have the <code>git depgraph</code> alias defined like this:</p>

<pre><code class="bash">[alias]
    depgraph = !git madge image --webpack-config webpack.config.js --basedir . --style solarized-dark src
</code></pre>

<p>Some notes about this definition:</p>

<ul>
<li><p>It depends on the <code>git-madge</code> command, which you can <a href="https://github.com/jez/git-madge">download
and install here</a>.</p></li>
<li><p>It&rsquo;s using <em>this project&rsquo;s</em> <code>webpack.config.js</code> file, so I&rsquo;ve made
this alias local to the repo, rather than available globally.</p></li>
<li><p>It dumps the image to stdout. Above, we used iTerm2&rsquo;s <a href="https://iterm2.com/documentation-images.html">imgcat</a>
program to pipe stdin and dump a raster image to the terminal.</p>

<p>If you don&rsquo;t use iTerm2 or don&rsquo;t want to install <code>imgcat</code>, you can
pipe it to Preview using open<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (<code>open -f -a Preview</code>) or just
redirect the PNG to a file.</p></li>
</ul>


<p>The <code>git depgraph</code> alias is a game changer. It makes it easier to get spun
up in new code bases, helps make sense of large changes, and just looks
plain cool. But at the end of the day, we came here to review some code,
so let&rsquo;s take a look at how we can actually view the diffs of the files
that changed.</p>

<h2>Reviewing the diffs</h2>

<p>To review the diffs, the simplest option is to just run <code>git diff
master..HEAD</code>. This has a bunch of downsides:</p>

<ul>
<li><p>No syntax highlighting (everything is either green or red).</p></li>
<li><p>No surrounding context (for example, GitHub lets you click to expand
lines above or below a diff hunk).</p></li>
<li><p>The diff is &ldquo;unified,&rdquo; instead of split into two columns.</p></li>
<li><p>No way to exclude a specific file (the 300 line diff to your
<code>yarn.lock</code> file is sometimes nice to hide).</p></li>
</ul>


<p>My solution to all of these problems is to view the diffs in Vim, with
the help of two Vim plugins and two git aliases. Before we get to
that, here&rsquo;s a screenshot:</p>

<p><a class="image-link" href="/images/git-review.png"><img class="fullwidth" src="/images/git-review.png" title="git review" ></a></p>

<p>Looks pretty similar to GitHub&rsquo;s interface, with the added bonus that
it&rsquo;s using my favorite colorscheme! The Vim plugins featured are:</p>

<ul>
<li><a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> for showing the side-by-side diff (<code>:Gdiff</code>).</li>
<li><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> for showing the <code>+/-</code> signs.</li>
<li><a href="https://github.com/jez/vim-colors-solarized">jez/vim-colors-solarized</a> for tweaking the diff highlight
colors.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>And to orchestrate the whole thing, I&rsquo;ve set up these two aliases:</p>

<pre><code class="bash">[alias]
  # NOTE: These aliases depend on the `git files` alias from
  # a few sections ago!

    # Open all files changed since REVIEW_BASE in Vim tabs
    # Then, run fugitive's :Gdiff in each tab, and finally
    # tell vim-gitgutter to show +/- for changes since REVIEW_BASE
    review = !vim -p $(git files) +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"

    # Same as the above, except specify names of files as arguments,
    # instead of opening all files:
    # git reviewone foo.js bar.js
    reviewone = !vim -p +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"
</code></pre>

<p>Here&rsquo;s how they work:</p>

<ul>
<li><p><code>git review</code> opens each file changed by this branch as a tab in Vim.
Then <code>:Gdiff</code> from vim-fugitive shows the diff in each tab.</p></li>
<li><p><code>git reviewone</code> is like <code>git review</code>, but you specify which
files to open (in case you only want to diff a few).</p></li>
</ul>


<p>Like with the <code>git stat</code> alias, these aliases respect the <code>REVIEW_BASE</code>
environment variable I&rsquo;ve set up in my <code>~/.bashrc</code>. (Scroll back up for
a refresher.) For example, to review all files relative to <code>master</code>:</p>

<pre><code class="bash">REVIEW_BASE=master git review
</code></pre>

<p>At this point, you might think that all we&rsquo;ve done is re-create the
GitHub code review experience in Vim. But actually what we&rsquo;ve done is so
much more powerful.</p>

<h2>Interactive Code Review</h2>

<p>When reviewing on GitHub, the code is completely static&mdash;you can&rsquo;t
change it. Also, because the code is coming from GitHub&rsquo;s servers,
it&rsquo;s laggy when you click around to view related files. By switching our
code review to the terminal, we can now edit files, jump to other files,
and run arbitrary commands at no cost.</p>

<p>It might not be obvious how huge of a win this is, so let&rsquo;s see some
examples. Take this screenshot of the <code>requireElement</code> function. It
moved from <em>above</em> the <code>findElement</code> function to <em>below</em> it (probably
because the former calls the latter):</p>

<p><a class="image-link" href="/images/requireElement01.png"><img class="fullwidth" src="/images/requireElement01.png" title="diff" ></a></p>

<p>But is the location of the <code>requireElement</code> function the only thing
that&rsquo;s changed? By editing the file to move the function back to its
original location, vim-fugitive will automatically recompute the diff.
And in fact, we can see that the <em>type of the argument</em> has changed too,
from <code>string</code> to <code>ElementType</code>:</p>

<p><a class="image-link" href="/images/requireElement02.png"><img class="fullwidth" src="/images/requireElement02.png" title="diff" ></a></p>

<p>If we had been viewing this on GitHub, we might have taken for granted
that the function didn&rsquo;t change. But since we&rsquo;re in our editor, we can
interactively play around with our code and discover things we might
have missed otherwise. The advantages of interactive code review go well
beyond this example:</p>

<ul>
<li><p>In a Flow project, we can ask for the type of a variable.</p></li>
<li><p>In a test file, we can change the test and see if it still passes or
if it now fails.</p></li>
<li><p>We can <code>grep</code> the project for all uses of a function (including files
<em>not</em> changed by this branch).</p></li>
<li><p>We can open up related files for cross-referencing.</p></li>
<li><p>We can run the code in a debugger and see how it behaves.</p></li>
</ul>


<p>By having the full power of our editor, we can literally retrace the
steps that the author went through to create the pull request. If our
goal is to understand and learn from code review, there&rsquo;s no better way
than walking in the author&rsquo;s shoes.</p>

<h2>Recap</h2>

<p>To recap, here&rsquo;s a list of the tools I use to review code at the command
line:</p>

<ul>
<li><code>hub pr checkout</code></li>
<li><code>git stat</code> to list files that have changed</li>
<li><code>git heatmap</code> to show how frequently these files change</li>
<li><code>git depgraph</code> to show a graph of which files depend on which</li>
<li><code>git review</code> to open diffs of all the files in Vim</li>
<li><code>git reviewone</code> to open diffs for a specific handful of files</li>
</ul>


<p>If you&rsquo;re having trouble incorporating any of these into your workflow,
feel free to reach out and let me know! I&rsquo;m happy to help.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The techniques here apply to any language that you can statically analyze. In particular, I have a rough prototype of everything JavaScript-specific you see here that works with Standard ML instead. If you can find me the dependency information for your favorite language, I&rsquo;d be happy to help you turn it into a visualization.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The <code>open</code> command is macOS-specific. On Linux, you might want to look at the <code>display</code> command from ImageMagick.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>I&rsquo;ve patched the default Solarized colors for Vim so that lines retain their syntax highlighting in the diff mode, while the backgrounds are highlighted. You can see how this works in this commit: <a href="https://github.com/jez/vim-colors-solarized/commit/bca72cc">https://github.com/jez/vim-colors-solarized/commit/bca72cc</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tests, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/tests-types-correctness/"/>
    <updated>2017-09-10T16:50:36-07:00</updated>
    <id>https://blog.jez.io/tests-types-correctness</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Monitoring tools</strong> prove that incorrect behavior hasn&rsquo;t occurred
<em>yet</em>, or provide us with a concrete counter example when it
happens.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! The fourth might seem not helpful, but is often
better than nothing, and in many situations can be leveraged into making
powerful claims. None of the above are as universally applicable as the
last: doing the proof ourself, but it&rsquo;s also usually the most error prone.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, tests are rarely (if
ever) exhaustive, and frequently allow bugs to pass through to
production. This is why testing, types, and monitoring are
complementary&mdash;one is not a substitute for another.</p>

<p>The hardest part of writing high-quality software is ensuring that it
runs without bugs. The more tools we have in our arsenal to combat
incorrectness, the easier it is to write code for the long term.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Recall that raising an exception is logically the same as throwing a value to a continuation and carrying out a <a href="/continuations-notes/">proof by contradiction</a>!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If, Else, & Purity]]></title>
    <link href="https://blog.jez.io/if-else-purity/"/>
    <updated>2017-08-31T22:38:43-07:00</updated>
    <id>https://blog.jez.io/if-else-purity</id>
    <content type="html"><![CDATA[<p>I prefer to let the language I&rsquo;m using think on my behalf as much as
possible. Ideally, the language is rich enough that the proof of
correctness is inherent in the code I&rsquo;ve written. Even when I use
looser languages, these principled languages inform the structure of my
code. To make this a bit more let&rsquo;s turn our focus to <code>if</code>, <code>else</code>, and
purity.</p>

<!-- more -->


<p>A cool way to understand purity is using what&rsquo;s known as a &ldquo;modal
separation.&rdquo; This is a really fancy way to say that we have
<strong>expressions</strong> which are pure and always evaluate to a value, alongside
<strong>commands</strong> which are impure and are executed for their side effects.
If you&rsquo;ve ever used Haskell, you&rsquo;re already familiar with this
notion&mdash;we only need <code>do</code> notation when we need to write impure (or
&ldquo;monadic&rdquo;) code.</p>

<p>In an expression language, every <code>if</code> <em>must</em> have an <code>else</code>; for the
entire <code>if</code> expression to be used as a value, both branches must in turn
evaluate to values. It&rsquo;s only when we move to a language with commands
where it makes sense to allow omitting the <code>else</code> branch. <code>if</code>
expressions are not some abstract concept; chances are you&rsquo;ve
encountered them under the name &ldquo;the ternary operator.&rdquo;</p>

<p>An <code>if</code> <em>statement</em> (as opposed to an <code>if</code> expression) is a command;
it&rsquo;s useful for running side-effectful code. Sometimes, we don&rsquo;t want
one of the branches to have any side effects (for example, because the
state of the world doesn&rsquo;t need to be changed). Languages with commands
allow omitting the <code>else</code>.</p>

<p>What does this mean for us? Since expression languages form the basis
for purity, every pure function can be written where the <code>if</code> is matched
with an <code>else</code>. Put another way, an unmatched <code>if</code> is a likely indicator
that the code I&rsquo;ve written is impure.</p>

<p>This makes me more aware of when I&rsquo;m dealing with impure code. For
example, I might want to factor out as much of the pure code into a
separate helper function. There&rsquo;s a time and a place for impure code.
But since pure code is more composable and easier to test, it&rsquo;s best to
factor the impure code out whenever possible.</p>

<p>In a principled language, there&rsquo;s a distinction between <code>if</code> expressions
and <code>if</code> statements. On the other hand, some language only have one, or
they blur the line between the two. We can draw upon our experiences
with languages that are rigorous about minutia like this to better
inform how we write clean code.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
</feed>
