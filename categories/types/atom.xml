<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: types | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/types/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2021-06-05T00:42:05-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Typed Errors in Sorbet]]></title>
    <link href="https://blog.jez.io/typed-errors-sorbet/"/>
    <updated>2021-05-30T22:12:37-07:00</updated>
    <id>https://blog.jez.io/typed-errors-sorbet</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s answer another question about how best to use Sorbet:</p>

<blockquote><p>How should I type methods that might fail?</p></blockquote>

<p>Let&rsquo;s take a look at an example.</p>

<!-- more -->




<!-- This could work, but might be verbose -->


<pre><code class="ruby">def create_customer(email, card_number, exp_month, exp_year); end
def create_charge(customer, amount, currency); end
def handle_create_charge_request(req); end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have Checked Exceptions]]></title>
    <link href="https://blog.jez.io/union-types-checked-exceptions/"/>
    <updated>2021-05-29T01:21:41-07:00</updated>
    <id>https://blog.jez.io/union-types-checked-exceptions</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a common question I get asked about Sorbet:</p>

<blockquote><p>Does Sorbet support checked exceptions, like Java?</p></blockquote>

<p>(In fact, this was the <a href="https://youtu.be/odmlf_ezsBo?t=1921">first question</a> I was asked at my <a href="https://jez.io/talks/state-of-sorbet-2019/">first
conference talk</a>.)</p>

<p>The answer: Sorbet doesn&rsquo;t support checked exceptions, and I don&rsquo;t think
it ever should.</p>

<!-- more -->


<p>Before I dive in, there are two pretexts I&rsquo;m assuming: either you asked
this question and someone linked you this post, or the post title was
enough to catch your attention. Either way, I&rsquo;m going to take for
granted that you know what I mean by &ldquo;checked exceptions.&rdquo; If you want a
quick refresher, jump down to the <a href="#appendix">Appendix</a> and then come
back.</p>

<p>My claim is that checked exceptions are a poor man&rsquo;s ad hoc union types,
that since Sorbet has ad hoc union types it doesn&rsquo;t need checked
exceptions. I&rsquo;ll discuss this claim in three parts:</p>

<ul>
<li>I&rsquo;ll give some background on what it means for union types to be &ldquo;ad
hoc,&rdquo; which applies to Sorbet&rsquo;s union types but are somewhat rare.</li>
<li>I&rsquo;ll describe a translation from checked exceptions in Java to
union-typed returns in Ruby with a concrete example.</li>
<li>I&rsquo;ll give evidence for why the union types approach is better.</li>
</ul>


<p>(If you want to skip straight to the good stuff, the analysis <a href="#analysis">is down
here</a>.)</p>

<h2>Background: Sorbet&rsquo;s union types</h2>

<blockquote><p>The throws clause is the only point in the entire Java language that
allows union types. You can tack &ldquo;throws A,B,C&rdquo; onto a method
signature meaning it might throw A or B or C, but outside of the
throws clause you cannot say &ldquo;type A or B or C&rdquo; in Java.</p>

<p>â€” James Iry, <em><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t
In Java</a></em> (2012)</p></blockquote>

<p>Sorbet supports <a href="https://sorbet.org/docs/union-types">union types</a>. More specifically, Sorbet&rsquo;s union types
are ad hoc: any number of types can be unioned together on demand:</p>

<pre><code class="ruby">sig {returns(T.any(A, B, C))}
def foo; ...; end
</code></pre>

<p>By contrast, many languages with union types require predeclaring a
union&rsquo;s variants, for example in Rust:</p>

<pre><code class="rust">enum AorBorC {
    A(A),
    B(B),
    C(C),
}
</code></pre>

<p>That Sorbet allows defining union types on demand is similar to Java&rsquo;s
<code>throws</code> clause, but more powerful: <code>throws A, B, C</code> is not a type,
while <code>T.any(A, B, C)</code> is. We&rsquo;ll see why that matters below.</p>

<h2>Example: From checked exceptions to union types</h2>

<p>Using Sorbet&rsquo;s ad hoc union types, it&rsquo;s mechanical to convert Java-style
checked exceptions to Sorbet-annotated Ruby. To demonstrate:</p>

<pre><code class="java">Currency parseCurrency(String currencyStr) throws ParseException {
    Currency currency = KNOWN_CURRENCIES.get(currencyStr);
    if (currency == null) {
        throw new ParseException(
          "'" currencyStr + "' is not a valid currency", 0);
    }

    return currency;
}
</code></pre>

<p>This is a somewhat contrived Java method, but it&rsquo;ll be good enough to
demonstrate the concepts.</p>

<p>If <code>parseCurrency</code> is given a string it can&rsquo;t handle, it raises a
<code>ParseException</code>. It declares this with <code>throws</code> because
<code>ParseException</code> is a checked exception. If the currency string is
recognized, it returns some <code>Currency</code> object.</p>

<p>Here&rsquo;s how we&rsquo;d write that in Sorbet:</p>

<pre><code class="ruby"># (0) Ruby's standard library doesn't have `ParseException`,
# so I've re-implemented it.
class ParseError &lt; T::Struct
  const :message, String
  const :offset, Integer
end

# (1) return type + `throws` becomes just `returns`
# (2) Return type uses `T.any`
sig do
  params(currency_str: String)
    .returns(T.any(Currency, ParseError))
end
def parse_currency(currency_str)
  currency = KNOWN_CURRENCIES[currency_str]
  if currency.nil?
    # (3) `throw` becomes `return`
    return ParseError.new(
      message: "'#{currency_str}' is not a valid currency",
      offset: 0
    )
  end

  currency
end
</code></pre>

<p>The important changes:</p>

<ol>
<li>Where Java had a return type and a <code>throws</code> clause, Sorbet just has a
return type.</li>
<li>Sorbet&rsquo;s return type is a union type (<code>T.any(...)</code>). It mentions the Java
method&rsquo;s return type and all the exceptions mentioned in the <code>throws</code>.</li>
<li>Where the Java example uses <code>throw</code>, the Ruby example uses <code>return</code>.</li>
</ol>


<p>Our translation isn&rsquo;t complete until we see how the <code>parseCurrency</code>
caller side changes. In Java, we call <code>parseCurrency</code> like this:</p>

<pre><code class="java">Charge createCharge(int amount, String currencyStr) throws ParseException {
    Currency currency = parseCurrency(currencyStr);
    return new Charge(amount, currency);
}
</code></pre>

<p>With Sorbet, this snippet becomes:</p>

<pre><code class="ruby">sig do
  params(amount: Integer, currency_str: String)
    .returns(T.any(Charge, ParseError))
end
def create_charge(amount, currency_str)
  currency = parse_currency(currency_str)
  return currency unless currency.is_a?(Currency)

  Charge.new(amount: amount, currency: currency)
end
</code></pre>

<p>As before, the <code>throws</code> clause in Java becomes a union-typed return in Ruby.</p>

<p>The new bit is the explicit <code>return ... unless ...</code>. Whereas uncaught
exceptions implicitly bubble up to the caller, return values only bubble
up if explicitly returned. This is a key benefit of the union types
approach, which brings us to our next section.</p>

<h2 id="analysis">Analysis: Why the union types approach is better</h2>


<p>To recap, Sorbet&rsquo;s union types are ad hoc, much in the same sense as the
classes mentioned in Java&rsquo;s <code>throws</code> clause. When converting from <code>Java</code> to
<code>Ruby</code>, a single, union-typed return takes the place of a separate return
type and <code>throws</code> clause.</p>

<p>First off, this translation preserves the best parts of checked
exceptions:</p>

<ul>
<li><p>A method&rsquo;s failure modes still appear in an <strong>explicit, public API</strong>.</p>

<p>In both Java and Ruby, the method signature behaves as machine-checked
error documentation.</p></li>
<li><p>Ad hoc error specifications enable <strong>low-friction composition</strong>.</p>

<p>In both Java and Ruby, if our method is the first to combine two
methods with unrelated failure modes, there&rsquo;s no ceremony to
predeclare that combination. Instead, we just mention one more class
in the method&rsquo;s signature.</p></li>
</ul>


<p>But this approach is not only as good, it&rsquo;s better, because:</p>

<ul>
<li><p>As a language feature, <strong>union types are not special</strong>.</p>

<p>Union types are types. Like other types, we can store them in
variables. We can factor common error recovery code into helper
functions. We can map functions returning union types over lists. We
can write type aliases that abbreviate commonly-grouped error classes.
We can&rsquo;t do any of this with checked exceptions, and this is the most
common complaint against them.</p></li>
<li><p>Union types have <strong>call-site granularity</strong>, not method-body
granularity.</p>

<p>The union types approach forces a choice of how to handle errors at
each call site. This is more robust in the face of changing code,
because new call sites should not necessarily inherit the error
handling logic of existing call sites. Just because one
<code>ParseException</code> was uncaught and mentioned in the <code>throws</code> does not
mean all of them should be.</p></li>
</ul>


<p>And finally, let me get out ahead of some common counter arguments.</p>

<blockquote><p>The union types approach requires more typing at the call site!</p></blockquote>

<p>Yep. But I&rsquo;ve already counted this as a blessing, not a curse.</p>

<blockquote><p>But real-world Ruby code already uses exceptions!</p></blockquote>

<p>Yep. But in Java too, the world is already split into checked and
unchecked exceptions. In both Java and Ruby, exceptions are a fact of
life, and you&rsquo;ll always need a way to deal with unexpected exceptions
(e.g., comprehensive tests, automated production alerting, etc.).</p>

<blockquote><p>With checked exceptions, I could handle all the failures at once!</p></blockquote>

<p>That&rsquo;s true; with checked exceptions, it&rsquo;s easy to write a single
<code>catch</code> statement that handles all failures due to, say, a
<code>ParseException</code> in a whole region of code, avoiding the need for code
repetition.</p>

<p>The upshot is that with union types, we can just use functions. Take
everything in the <code>catch</code> body, put it in a helper function, and call it
at each call site.  This cuts down on duplication, and I already
mentioned how call-site granularity is a win.</p>

<h2>I love union types</h2>

<p>That&rsquo;s pretty much it. Sorbet doesn&rsquo;t need checked exceptions, it
already has ad hoc union types.</p>

<hr />

<h2 id="appendix">Appendix: Checked Exceptions</h2>


<p>As a quick refresher, <a href="https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions">checked exceptions</a> are a feature popularized by
Java. The syntax looks like this:</p>

<pre><code class="java">void doThing() throws MyException {
    // ...
}
</code></pre>

<p>The <code>throws</code> keyword is a part of the method&rsquo;s signature, just like
argument and return types. It declares that this method might throw
<code>MyException</code>.</p>

<p>Since it&rsquo;s a part of this method&rsquo;s signature the <code>throws</code> annotation
will be checked at all call sites (just like argument and return types).
A method containing calls to <code>doThing</code> must either <code>catch</code> all mentioned
exceptions or repeat any maybe-thrown-but-uncaught exceptions in its own
<code>throws</code> clause.</p>

<p>If a method throws multiple classes of exceptions, they can all be
listed:</p>

<pre><code class="java">void doThing() throws MyException, YourException, AnotherException {
    // ...
}
</code></pre>

<p>The argument in favor of checked exceptions is that they&rsquo;re explicit and
machine-checked. Users don&rsquo;t have to guess at what a method might throw,
or hope that there&rsquo;s accurate documentationâ€”all benefits shared by
static typing in general, which is a sympathetic goal.</p>

<p>Checked exceptions seem like a good feature on paper. In practice,
they&rsquo;re generally regretted. I&rsquo;m nowhere near the first person to come
to this conclusion, so instead I&rsquo;ll link you to some previous
discussions:</p>

<ul>
<li><a href="https://www.artima.com/articles/the-trouble-with-checked-exceptions">The Trouble with Checked Exceptions</a>, A Conversation
with Anders Hejlsberg</li>
<li><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t In
Java</a>, by James Iry</li>
<li><a href="https://ericlippert.com/2008/09/10/vexing-exceptions/">Vexing Exceptions</a>, by Eric Lippert</li>
</ul>


<p>(The last one isn&rsquo;t actually about checked exceptions: it&rsquo;s just about
exceptions and I like it, so I included it.)</p>

<p>Java has been copied and imitated for decades. Among all the features we
see other languages copy from Java, checked exceptions are absent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have FixMe Comments]]></title>
    <link href="https://blog.jez.io/sorbet-fixme-comment/"/>
    <updated>2020-02-11T23:18:40-08:00</updated>
    <id>https://blog.jez.io/sorbet-fixme-comment</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Sorbet has no way to ignore an error on a specific line with a magic
comment. This is different from all other gradual static type checkers I
know about:</p>

<ul>
<li>TypeScript: <code>// @ts-ignore</code></li>
<li>Flow: <code>// $FlowFixMe</code></li>
<li>Hack: <code>// HH_FIXME</code></li>
<li>MyPy: <code># type: ignore</code></li>
</ul>


<p>When I first joined the team, I was skeptical. But having seen it play
out in practice, it&rsquo;s actually worked great.</p>

<p>Instead of ignore comments, Sorbet has <code>T.unsafe</code>, which accepts
anything and returns it unchanged (so for example <code>T.unsafe(3)</code>
evaluates to <code>3</code>). The trick is that it forces Sorbet to forget the
type of the input statically. This confers the power to silence most
errors. For example:</p>

<pre><code class="ruby">1 + '1'            # error: Expected `Integer` but found `String`
T.unsafe(1) + '1'  # no error
</code></pre>

<p><a href="https://sorbet.run/#%20%20%20%20%20%20%20%20%201%20%20%2B%20'1'%20%20%23%20error%3A%20Expected%20%60Integer%60%20but%20found%20%60String%60%0AT.unsafe(1)%20%2B%20'1'%20%20%23%20no%20error">â†’ View on sorbet.run</a></p>

<p>In this example, Sorbet knows that calling <code>+</code> on an Integer with a
String would raise an exception at runtime, and so it reports a static
type error. But wrapping the <code>1</code> in a call to <code>T.unsafe</code> causes Sorbet
to think that the expression <code>T.unsafe(1)</code> has type <code>T.untyped</code>. Then,
like for all untyped code, Sorbet admits the addition.</p>

<p>All Sorbet-typed Ruby programs must grapple with <code>T.untyped</code>. Every
Sorbet user has to learn how it works and what the tradeoffs of using it
are. In particular, that <code>T.untyped</code> is viral. Given a variable that&rsquo;s
<code>T.untyped</code>, all method calls on that variable will also be untyped:</p>

<pre><code class="ruby"># typed: true
extend T::Sig

sig {params(x: T.untyped).void}
def foo(x)
  y = x.even?
# ^ type: T.untyped
  z = !y
# ^ type: T.untyped
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.untyped).void%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20x.even%3F%0A%23%20%5E%20type%3A%20T.untyped%0A%20%20z%20%3D%20!y%0A%23%20%5E%20type%3A%20T.untyped%0Aend">â†’ View on sorbet.run</a></p>

<p>In this example <code>x</code> enters the method as <code>T.untyped</code>, so calling the
method <code>.even?</code> propagates the <code>T.untyped</code> to <code>y</code>. Then again because
<code>y</code> is untyped, calling<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <code>!</code> on it propgates the <code>T.untyped</code> to
<code>z</code>. There are plenty of reasons to <a href="https://sorbet.org/docs/gradual">both embrace and avoid</a>
<code>T.untyped</code> in a type system but the point is: Sorbet&rsquo;s type system
already has it.</p>

<p>Re-using <code>T.untyped</code> as the way to silence errors plays nicely with
everything else in Sorbet:</p>

<ul>
<li><p>Hover and jump to definition become tools to track down the source of
silenced errors.</p></li>
<li><p>Errors are effectively silenced at the source of the error. There are
no errors downstream that only show up because an error was silenced
earlier.</p></li>
<li><p>We plan to eventually build a tool to show which parts of a file are
untyped (to see things like which methods don&rsquo;t have signatures). That
tool will trivially take suppressed errors into account.</p></li>
</ul>


<p>The <a href="https://sorbet.org/docs/gradual">Sorbet docs</a> bill <code>T.untyped</code> as the way to &ldquo;turn off the
type system.&rdquo; By reusing <code>T.untyped</code> to supress errors, silencing one
error means silencing them all, which is a win for simplicity.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Did you know that <code>!x</code> in Ruby is syntactic sugar for <code>x.!()</code>, which means that you can override <code>!</code> to make it do something else?<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intersection Types in Sorbet are Surprisingly Common]]></title>
    <link href="https://blog.jez.io/intersection-types-common/"/>
    <updated>2020-01-04T19:50:32-06:00</updated>
    <id>https://blog.jez.io/intersection-types-common</id>
    <content type="html"><![CDATA[<p>Conventional knowledge is that union types are common and intersection
types are rare. But actually that&rsquo;s not the caseâ€”intersection types
show up in nearly every program Sorbet type checks thanks to control
flow.</p>

<p><a href="https://sorbet.org/docs/union-types">Union types</a> in Sorbet are incredibly common, which should be no
surprise. In Sorbet, <code>T.nilable(...)</code> is sugar for <code>T.any(NilClass,
...)</code>. <code>T.nilable</code> shows up all over the place and probably catches more
bugs than any other feature in Sorbet.</p>

<p>Sorbet also has <a href="https://sorbet.org/docs/intersection-types">intersection types</a>. While union types mean &ldquo;either
this or that,&rdquo; intersection types mean &ldquo;both this and that.&rdquo; On first
glance, intersection types seem like some super niche feature which only
benefits a handful of programs. In Stripe&rsquo;s Ruby monorepo, the strings
<code>T.any</code> and <code>T.nilable</code> occur nearly 300 times more than <code>T.all</code> does.</p>

<p>But those numbers hide something critical: intersection types power
Sorbet&rsquo;s <a href="https://sorbet.org/docs/flow-sensitive">control flow-sensitive typing</a>. They&rsquo;re actually present in
every Ruby program, but just a little hard to spot. Let&rsquo;s look at how
pervasive they are with a few examples:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class Parent; end
class Child &lt; Parent; end

sig {params(x: Parent).void}
def example1(x)
  case x
  when Child
    T.reveal_type(x) # Revealed type: `Child`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend">â†’ View on sorbet.run</a></p>

<p>Here <code>x</code> starts out having type <code>Parent</code>, but inside the <code>case</code>
statement Sorbet treats <code>x</code> as having the more specific type <code>Child</code>.
There&rsquo;s no <code>T.all</code> in sight, but that&rsquo;s because it&rsquo;s hiding. Sorbet
doesn&rsquo;t just throw away the fact that it knew <code>x &lt;: Parent</code>. Instead, it
uses <code>T.all</code> to update its type for <code>x</code> to <code>T.all(Parent, Child)</code>.</p>

<p><code>T.all(Parent, Child)</code> is equivalent to <code>Child</code> because <code>Child</code> is a
subtype of <code>Parent</code>. If types represent sets of values, then the set of
values represented by <code>Child</code> is a subset of the set of values
represented by <code>Parent</code>, so the intersection of those two sets would
just leave <code>Child</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Sorbet attempts to simplify a large type to a smaller, equivalent type
when it can for two reasons:</p>

<ul>
<li><p><strong>Usability</strong> â€“ Most users don&rsquo;t know that <code>T.all</code> means &ldquo;intersection
type&rdquo; or even what intersection types are. (And even those who do
still end up drawing Venn diagrams from time to time!) It only gets
more complicated when <code>T.all</code>s and <code>T.any</code>s nest inside each other.</p>

<p>Meanwhile, <code>Child</code> is a super easy type to understand, and leads to
nice, short error messages.</p></li>
<li><p><strong>Performance</strong> â€“ Checking whether one type is a subtype of another is
a super common operation, so it has to be fast. By collapsing
<code>T.all(Parent, Child)</code> to <code>Child</code>, Sorbet does at least half as much
work when checking subtyping (probably more, because of some common
path optimizations).</p>

<p>When this simplification happens, Sorbet even skips an allocation
entirely. Cnstructing <code>T.all(Parent, Child)</code> in Sorbet short
circuits and returns a reference to the already allocated <code>Child</code> type
that was passed as an argument (with ownership tracked via
<code>std::shared_ptr</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>).</p></li>
</ul>


<p>Let&rsquo;s look at another example of control flow:</p>

<pre><code class="ruby"># typed: strict
extend T::Sig

class A; end
class B; end

sig {params(a_or_b: T.any(A, B)).void}
def example2(a_or_b)
  case a_or_b
  when A
    T.reveal_type(a_or_b) # Revealed type: `A`
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend">â†’ View on sorbet.run</a></p>

<p>This example method accepts either <code>A</code> or <code>B</code> (<code>T.any(A, B)</code>) and then
branches on whether <code>a_or_b</code> is an instance of <code>A</code>. Again: Sorbet
doesn&rsquo;t throw away that it knows <code>a_or_b &lt;: T.any(A, B)</code>. Instead it
updates its knowledge of the type of <code>a_or_b</code> using <code>T.all</code> to get
<code>T.all(T.any(A, B), A)</code>. Realizing that this is equivalent to <code>A</code> is a
bit trickier:</p>

<pre><code class="ruby">T.all(T.any(A, B), A)

# Distribute
T.any( T.all(A, A) , T.all(B, A) )

# T.all(A, A) is just A (idempotence)
T.any( A , T.all(B, A) )

# A and B are classes (not mixins) and neither inherits the other.
# It's impossible to have a value of that type, so it's bottom:
T.any( A , T.noreturn )

# bottom is the identity of union
A
</code></pre>

<p>You can start to see how usability and performance and might get a
little out of hand if Sorbet didn&rsquo;t keep attempting to simplify things!
The cumulative effect of all the control flow in a program would result
in huge, unweidly types.</p>

<p>Until now you could claim that I&rsquo;ve been hyping up intersection types as
the solution to problems that were self-imposed. That if we just
invented some other method for modeling control flow, it would have been
naturally usable or naturally performant, and we wouldn&rsquo;t have had
problems in the first place. So next let&rsquo;s look at some examples to see
why intersection types really are the most natural solution:</p>

<pre><code class="ruby">module I1
  def foo1; end
end
module I2
  def foo2; end
end

sig {params(x: I1).void}
def example3(x)
  x.foo1  # Works outside
  case x
  when I2
    x.foo1  # Should (and does) still work inside
    x.foo2
  end
end
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A">â†’ View on sorbet.run</a></p>

<p>Unlike in the other examples, this is the first example where had we
tried to implement control-flow-sensitive typing by throwing away the
old type and using the new type instead it wouldn&rsquo;t have worked. The key
thing to notice: this example uses modules. Outside the <code>case</code> of course
calling <code>x.method_from_1</code> works because <code>x</code> starts out at type <code>I1</code>. But
if we treated <code>x</code> as only <code>I2</code> inside the <code>when I2</code>, we&rsquo;d start
reporting an error for calling <code>x.method_from_1</code> because it doesn&rsquo;t
exist on <code>I2</code>.</p>

<p>Unlike intersecting unrelated classes (our <code>T.all(B, A)</code> example from
earlier), intersecting unrelated modules does&rsquo;t collapse to
<code>T.noreturn</code>. There&rsquo;s nothing stopping some class from including both
<code>I1</code> and <code>I2</code>. Instances of that class would be values of type
<code>T.any(I1, I2)</code>:</p>

<pre><code class="ruby">class SomeClass
  include I1
  include I2
end

# This type assertion is okay:
T.let(SomeClass.new, T.all(I1, I2))
</code></pre>

<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))">â†’ View on sorbet.run</a></p>

<p>So at least for implementing certain cases of flow sensitive typing,
we&rsquo;ll <em>need</em> intersection types anyways. Then for these certain cases
we&rsquo;d incur the usability and performance problems we discovered earlier
and have to solve them.</p>

<p>But more than that, intersection types are fundamentally easier to work
with compared to some ad hoc approach to flow sensitive typing. Type
system bugs are weird. It&rsquo;s frquently harder to figure out whether the
current behavior is buggy in the first place than it is to find the
cause!</p>

<p>In that light, intersection types present an elegant, robust model for
arriving at what the correct behavior <em>should</em> be, independent of what
Sorbet&rsquo;s existing behavior is. It&rsquo;s clear how intersection types
interact with union types, and with subtyping, and with generics, and
with variance, etc.</p>

<p>By repurposing intersection types to model control flow sensitivity,
when things go wrong there&rsquo;s a framework for discovering what&rsquo;s right.</p>

<p>(Speaking of repurposing, intersection types also play an important role
in how Sorbet <a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend">suggests potential method signatures</a>! That&rsquo;s three birds
with one stone.)</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you&rsquo;re not convinced, consider: with <code>T.all(Parent, Child)</code> we should be able to call all the methods on <code>Parent</code> and all the methods on <code>Child</code>. But <code>Child</code> inherits <code>Parent</code>&rsquo;s methods, so any method <code>Parent</code> has will already be on <code>Child</code>. So <code>Child</code> is equivalently good as <code>T.all(Parent, Child)</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you&rsquo;re looking for a good intro to modern C++ things like <code>shared_ptr</code>, I can&rsquo;t recommend <a href="https://berthub.eu/articles/posts/cpp-intro/">this blog post series</a> enough.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What makes type checking Ruby hard?]]></title>
    <link href="https://blog.jez.io/ruby-mutation/"/>
    <updated>2019-12-29T01:29:52-06:00</updated>
    <id>https://blog.jez.io/ruby-mutation</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Mutation makes typechecking Ruby harder than many other programming
languages. Most people will immediately think I mean mutation in the
sense of <code>x += 1</code> or somethingâ€”that&rsquo;s not what I&rsquo;m referring to. In
fact, that&rsquo;s the easy kind of mutation to model in a type system.</p>

<p>What I mean is that nearly everything worth knowing statically about a
Ruby program involves mutation. Defining a class?</p>

<pre><code class="ruby">class A
end
</code></pre>

<p>That mutates the global namespace of constants. After those lines run,
all code in the project can reference the class <code>A</code>.</p>

<p>Defining a method?</p>

<pre><code class="ruby">class A
  def foo
    puts 'hello'
  end
end
</code></pre>

<p>The method <code>foo</code> is undefined just before the <code>def</code> block (at runtime!),
but defined afterâ€”mutation again.</p>

<p>Ruby provides things like <code>attr_reader</code> and <code>attr_accessor</code> to define
getter and setter methods:</p>

<pre><code class="ruby">class B
  attr_reader :foo
end
</code></pre>

<p><code>attr_reader</code> is not a Ruby keyword, contrary to popular belief: it&rsquo;s a
method on the singleton class which takes an argument. It defines an
instance method called <code>foo</code> as a side effect by mutating the class <code>B</code>.</p>

<p>It&rsquo;s the same for mixing modules into classes:</p>

<pre><code class="ruby">module M; end
class C
  include M
end
</code></pre>

<p><code>include</code> is another method disguised like a keyword which mutates the
class&rsquo;s list of ancestors.</p>

<p>One of my least favorite Ruby features: you can <strong>redefine</strong> (not
override) a method:</p>

<pre><code class="ruby">class D
  attr_reader :foo
  alias_method :old_foo, :foo
  def foo
    puts 'Calling D#foo'
    old_foo
  end
end
</code></pre>

<p>Because <code>D#foo</code> is defined by the <code>attr_reader</code> line, the subsequent
<code>def</code> overwrites it (akin to mutating a local variable, like <code>x += 1</code>).
Oh and that <code>alias_method</code>? Another method looking like a keyword which
mutates the class.</p>

<p>Even the way libraries work in Ruby is powered by mutation:</p>

<pre><code class="ruby">require 'some_gem'
</code></pre>

<p><code>require</code> is a method (again, not a keyword) that looks up and runs
arbitrary Ruby code, whose result we discard. It&rsquo;s only convention that
the primary side effect of the <code>require</code>&rsquo;d code is to mutate the global
namespace, defining more classes and methods.</p>

<h2>DSLs and metaprogramming</h2>

<p>It would be one thing if Ruby constrained the places where this mutation
could occur. But instead, it provides first-class support for these
features anywhere Ruby code runs. Everything we&rsquo;ve seen so far can be
hidden behind arbitrary computation at runtime:</p>

<ul>
<li>With <code>Module#const_set</code>, a Ruby program can compute an arbitrary name
and use it to create new constant at runtime.</li>
<li><code>Module#define_method</code> does the same for methods.</li>
<li>Again <code>require</code> is a method, so it can occur wherever other methods
are called.</li>
</ul>


<p>It&rsquo;s not uncommon to see Ruby libraries embrace this rather than avoid
it (Rails definitely does). Ruby programs frequently build up large
abstractions and do tons of computation which at the end of the day
result in a <code>define_method</code> or a <code>const_set</code>.</p>

<p>Rubyists call this &ldquo;metaprogramming&rdquo; or &ldquo;building DSLs&rdquo; but I call it
like I see it: mutation.</p>

<h2>Modeling mutation</h2>

<p>Type systems are notoriously bad at modelling this kind of mutation.
Look at other typed, object-oriented languages: Java, Scala, C++, &hellip;
Each of these languages <strong>forbids</strong> this kind of mutation. (Whether
because it&rsquo;s hard to implement support for it or because they&rsquo;re making
a value judgement is beyond me.)</p>

<p>So how can Sorbet can model this? Mostly, it just cheats. Err,
&ldquo;approximates.&rdquo; From my experience working on the Sorbet team, I can
think of three main ways it cheats.</p>

<p>First, Sorbet assumes that if a class or method might exist, it does
exist, and universally throughout a project.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It pretends
that all <code>include</code>, <code>extend</code>, and <code>alias_method</code> statements in a class
run first, before all other code at the top-level of that class. It
restricts method redefinitionsâ€”the old and new methods must take the
same number and kinds of arguments. And it restricts <code>alias_method</code>: you
can only alias to a method on your class, not to a parent class. Sorbet
makes no attempt to model <code>undef_method</code> at all (another
method-not-keyword!).</p>

<p>Second, Sorbet cheats by implementing heuristics for the most common
DSLs. To support <code>attr_reader</code>, Sorbet says, &ldquo;Hey, this method call
happens to be to some method named <code>attr_reader</code>. I&rsquo;m not sure if it&rsquo;s
to <code>Module#attr_reader</code> or to some other <code>attr_reader</code> definition or to
any definition at all, but it&rsquo;s provided with a single Symbol argument,
the result is discarded, and it&rsquo;s called at the syntactic top-level of a
class, so I bet that it is a call to <code>Module#attr_reader</code>.&rdquo; It&rsquo;s similar
for many other popular DSLs: it makes decent educated guesses.</p>

<p>But after all that, it sort of gives up. Sorbet makes no attempts to
work backwards from a call to <code>define_method</code> or <code>const_set</code> inside a
method body to learn that a class or method might have been defined
somewhere. Instead, it cheats one last time and uses runtime information.</p>

<p>As a part of initializing a Sorbet project, Sorbet <code>require</code>s (read:
executes) as much code in a project as it can: all the gems listed in
the Gemfile and all the Ruby files in the current folder. Afterwards, it
can see the result of all that&rsquo;s been mutated thus far (via reflection)
and serialize what it sees into <a href="https://sorbet.org/docs/rbi">RBI files</a> to convey what it saw to the
static checker. This is still imperfect (it completely misses things
that are defined after <code>require</code> time), but empirically it finds most of
the remaining undiscovered definitions.</p>

<h2>Beyond mutation</h2>

<p>Don&rsquo;t get me wrong, those approximations are really useful and
effective. But really, the way Sorbet handles mutation in a codebase is
by incentivicing people to get rid of it.</p>

<ul>
<li><p>Sorbet can type check a project in seconds, but it takes minutes to
re-generate all RBIs files. When Sorbet can see things statically,
there&rsquo;s also a canonical place to write a type annotation for it.</p></li>
<li><p>It&rsquo;s a much better experience to click &ldquo;Go to Definition&rdquo; and jump to
the actual source definition rather than to an auto-generated RBI
file.</p></li>
<li><p>And arguably, if it&rsquo;s easy for Sorbet to understand what&rsquo;s defined and
where, it&rsquo;s easier for a programmer to understand. Understandable code
lets people iterate faster, is less brittle, and harder to break by
accident.</p></li>
</ul>


<p>Programming languages are tools to change and structure the way we
think. In the long run, all code can be changed. We adopt type systems
specifically to help guide these changes, which <a href="https://blog.jez.io/on-language-choice/">I&rsquo;ve touched on
before</a>. When it comes to mutation in Ruby, Sorbet makes a solid effort
to model the helpful parts, while providing guide rails and suggestions
to deal with the rest.</p>

<hr />

<h2>Appendix A: By comparison with typed JavaScript</h2>

<p>You might say, &ldquo;the things that you&rsquo;re talking about aren&rsquo;t unique to
Ruby! It&rsquo;s the same for all dynamic programming languages!&rdquo; But is that
true in practice?</p>

<p>Let&rsquo;s compare our Ruby snippets from before with JavaScript.</p>

<p>Ruby:</p>

<pre><code class="ruby">class A
  def self.my_dsl(name)
    define_method(name) do; end
  end
end
</code></pre>

<p>JavaScript:</p>

<pre><code class="js">class A {
  static myDsl(name) {
    this.prototype[name] = function() {}
  }
}
</code></pre>

<p>First I&rsquo;ll point out: the mutation becomes way more obvious in the
JavaScript program! But second: both TypeScript and Flow report static
errors on this program. They both complain that there&rsquo;s no type
annotation declaring that it&rsquo;s ok to treat <code>this.prototype</code> as if it
were a key-value mapping.</p>

<p>The fact that both Flow and TypeScript report an error here speak to how
common this idiom is in practice. It&rsquo;s not common, and they&rsquo;d rather not
encourage programs like this, so they forbid it.</p>

<p>Here&rsquo;s another example, first in Ruby:</p>

<pre><code class="ruby">require 'some_gem'

SomeNamespace::SomeClass.new
</code></pre>

<p>And then in JavaScript:</p>

<pre><code class="js">import someNamespace from 'some_package';

new someNamespace.SomeClass();
</code></pre>

<p>With no RBI files declaring whether <code>SomeNamespace::SomeClass</code> exists
or not, Sorbet will report an error that the class doesn&rsquo;t exist. But in
TypeScript and Flow, the code is just fine, even if there&rsquo;s no type
declaration file. Both can still see that whatever vale is imported will
be bound to the <code>someNamespace</code> variable (even if it&rsquo;s treated as
<code>any</code>).</p>

<p>Sorbet is thus forced to come up with ways to generate RBI files for all
new projects, because without them Sorbet would be crippled: it would
have no way to distinguish between a class name that has actually been
typoed vs one that is typed correctly but for which there&rsquo;s no visible
definition. Meanwhile, TypeScript and Flow work completely fine in new
codebases out of the box.</p>

<p>So my claim is that: no, these problems <strong>are</strong> unique to Ruby, because
the design of the language and the culture of its use so pervasively
promote or require mutation.</p>

<h2>Appendix B: More things that are actually mutation</h2>

<ul>
<li><p><code>freeze</code> (ironic: to prevent mutation on a class or object&hellip; we
mutate it!)</p></li>
<li><p><code>private</code> / <code>private_class_method</code> (not keywords! These are methods
that take a <strong>Symbol</strong>; it just so happens that <code>def foo; end</code> is an
expression that evaluates to the symbol <code>:foo</code>. Which is why there&rsquo;s
both <code>private</code> and <code>private_class_method</code>, because <code>def self.foo; end</code>
also evaluates to <code>:foo</code>, so <code>private def self.foo; end</code> would attempt
to mark an <strong>instance</strong> method named <code>:foo</code> private, even it didn&rsquo;t
exist!)</p></li>
</ul>


<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Frequently this assumption is backed up by an autoloader. For example, Rails includes an autoloader that loads constants lazily on demand, so that the programmer doesn&rsquo;t have to sprinkle require statements throughout the code. But how do autoloads work? Mutation again ðŸ™‚.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
