<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/javascript/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2020-01-02T03:50:10-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prefer .then() over .catch()]]></title>
    <link href="https://blog.jez.io/prefer-then-over-catch/"/>
    <updated>2018-05-31T15:58:52-07:00</updated>
    <id>https://blog.jez.io/prefer-then-over-catch</id>
    <content type="html"><![CDATA[<p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<pre><code class="js Bad code; don't do this">// "Success" and "failure" types (definitions omitted)
import type {OkResult, ErrResult} from 'src/types';

const doSomething = (): Promise&lt;OkResult&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve(...) when it worked, but
    // cal reject(...) when it failed.
  });
};

doSomething
  .then((res) =&gt; ...)
  .catch((err) =&gt; ...)
</code></pre>

<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<pre><code class="js">type ErrResult = string;
</code></pre>

<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<pre><code class="js">// number, not a string!
reject(42);
</code></pre>

<p>nor from doing this:</p>

<pre><code class="js">// boolean, not a string!
.catch((err: boolean) =&gt; ...);
</code></pre>

<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<pre><code class="js Better code than before">// Helper function for exhaustiveness.
// See here: https://blog.jez.io/flow-exhaustiveness/
import {absurd} from 'src/absurd';

import type {OkResult, ErrResult} from 'src/types';

// Use a union type to mean "success OR failure"
type Result =
  | {|tag: 'ok', val: OkResult|}
  | {|tag: 'err', val: ErrResult|};

//     Use our new union type ‚îÄ‚îÄ‚îê
const doSomething = (): Promise&lt;Result&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    // call resolve({tag: 'ok',  val: ...}) when it worked, and
    // call resolve({tag: 'err', val: ...}) when it failed
  });
};

doSomething
  // Use a switch statement in the result:
  .then((res) =&gt; {
    switch (res.tag) {
      case 'ok':
        // ...
        break;
      case 'err':
        // ...
        break;
      default:
        // Guarantees we covered all cases.
        absurd(res);
        break;
    }
  })
</code></pre>

<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<pre><code class="js">// If I know that throwNumber will always call `reject` with a
// number, I can stop the loose types from propagating further
// with an explicit annotation:
throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ explicit annotation
  .catch((n: number) =&gt; handleWhenRejected(n))
</code></pre>

<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<pre><code class="js">throwNumber
  .then(() =&gt; console.log("Didn't throw!"))
  //         ‚îå‚îÄ‚îÄ defensive annotation
  .catch((n: mixed) =&gt; {
    if (typeof n === 'number') {
      handleWhenRejected(n);
    } else {
      // Reports misbehavior to an imaginary observability service
      tracker.increment('throwNumber.unexpected_input');
    }
  });
</code></pre>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Union Types in Flow & Reason]]></title>
    <link href="https://blog.jez.io/union-types-flow-reason/"/>
    <updated>2018-04-18T22:43:26-07:00</updated>
    <id>https://blog.jez.io/union-types-flow-reason</id>
    <content type="html"><![CDATA[<p>Union types are powerful yet often overlooked. At work, I&rsquo;ve been using
Flow which <a href="https://flow.org/en/docs/types/unions/">thankfully supports union types</a>. But as I&rsquo;ve
refactored more of our code to use union types, I&rsquo;ve noticed that our
bundle size has been steadily increasing!</p>

<!-- more -->


<p>In this post, we&rsquo;re going to explore why that&rsquo;s the case. We&rsquo;ll start
with a problem which union types can solve, flesh out the problem to
motivate why union types are definitely the solution, then examine the
resulting cost of introducing them. In the end, we&rsquo;ll compare Flow to
other compile-to-JS languages on the basis of how they represent union
types in the compiled output. I&rsquo;m especially excited about <a href="https://reasonml.github.io/">Reason</a>, so
we&rsquo;ll talk about it the most.</p>

<h2>Setup: Union Types in a React Component</h2>

<p>Let&rsquo;s consider we&rsquo;re writing a simple React 2FA<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> modal.
We&rsquo;ll be using Flow, but you can pretend it&rsquo;s TypeScript if you want.
The mockup we were given looks like this:</p>

<p><a href="/images/2fa-mockup.jpeg"><img src="/images/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>

<p>In this mockup:</p>

<ul>
<li>There&rsquo;s a loading state while we send the text message.</li>
<li>We&rsquo;ll show an input for the code after the message is sent.</li>
<li>There&rsquo;s no failure screen (it hasn&rsquo;t been drawn up yet).</li>
</ul>


<p>We&rsquo;ll need some way for our component to know which of the three screens
is visible. Let&rsquo;s use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>

<pre><code class="js">type Screen =
  | 'LoadingScreen'
  | 'CodeEntryScreen'
  | 'SuccessScreen';
</code></pre>

<p>Union types are a perfect fit! üéâ  Union types document intent and can
help guard against mistakes. Fellow developers and our compiler can
know &ldquo;these are all the cases.&rdquo; In particular, Flow can warn us when
we&rsquo;ve <a href="/flow-exhaustiveness/">forgotten a case</a>.</p>

<p>Our initial implementation is working great. After sharing it with the
team, someone suggests adding a &ldquo;cancel&rdquo; button in the top corner. It
doesn&rsquo;t make sense to cancel when the flow has already succeeded, so
we&rsquo;ll exclude it from the last screen:</p>

<p><a href="/images/2fa-close-btn.jpeg"><img src="/images/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>

<p>No problem: let&rsquo;s write a function called <code>needsCancelButton</code> to
determine if we need to put a cancel button in the header of a
particular screen:</p>

<pre><code class="js">const needsCancelButton = (screen: Screen): boolean =&gt; {
  // Recall: 'SuccessScreen' is the last screen,
  // so it shouldn't have a cancel button.
  return screen !== 'SuccessScreen';
};
</code></pre>

<p>Short and sweet. üëå Everything seems to be working great, until&hellip;</p>

<h2><code>switch</code>: Optimizing for Exhaustiveness</h2>

<p>The next day, we get some updated mocks from the design team. This time,
they&rsquo;ve also drawn up a &ldquo;failure&rdquo; screen for when the customer has
entered the wrong code too many times:</p>

<p><a href="/images/2fa-failure-screen.jpeg"><img src="/images/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>

<p>We can handle this&mdash;we&rsquo;ll just add a case to our <code>Screen</code> type:</p>

<pre><code class="js">type Screen =
  | 'LoadingScreen'
  | 'CodeEntryScreen'
  | 'SuccessScreen'
  // New case to handle too many wrong attempts:
  | 'FailureScreen';
</code></pre>

<p>But now <strong>there&rsquo;s a bug</strong> in our <code>needsCancelButton</code> function. üòß We
should only show a close button on screens where it makes sense, and
<code>'FailureScreen'</code> is not one of those screens. Our first reaction after
discovering the bug would be to just blacklist <code>'FailureScreen'</code> too:</p>

<pre><code class="js">const needsCancelButton = (screen: Screen): boolean =&gt; {
  return (
    screen !== 'SuccessScreen' ||
    screen !== 'FailureScreen'
  );
};
</code></pre>

<p>But we can do better than just fixing the <strong>current</strong> bug. We should
write code so that when we add a new case to a union type, our type
checker alerts us before a <strong>future</strong> bug even happens. What if instead
of a silent bug, we got this cheery message from our type checker?</p>

<blockquote><p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new
screen you added. <em>üôÇ</em></p>

<p>&mdash; your friendly, neighborhood type checker</p></blockquote>

<p>Let&rsquo;s go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell
us this when adding new cases. We&rsquo;ll use a <code>switch</code> statement with
<a href="/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>

<pre><code class="js">const impossible = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('This case is impossible.');
}

const needsCancelButton = (screen: Screen): boolean =&gt; {
  switch (screen) {
    case 'LoadingScreen':
      return true;
    case 'CodeEntryScreen':
      return true;
    case 'SuccessScreen':
      return false;
    default:
      // (I named this function 'absurd' in my earlier post:
      // https://blog.jez.io/flow-exhaustiveness/)
      // This function asks Flow to check for exhaustiveness.
      //
      // [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].
      return impossible(screen);
  }
}
</code></pre>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow ‚Üí)</strong></a></p>

<p>Now Flow is smart enough to give us an error! Making our code safer, one
<code>switch</code> statement at a time. üòÖ Union types in Flow are a powerful way
to use types to guarantee correctness. But to get the most out of union
types, <strong>always<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> access them</strong> through a <code>switch</code> statement.
Every time we use a union type without an exhaustive switch statement,
we make it harder for Flow to tell us where we&rsquo;ve missed something.</p>

<h2>Correctness, but at what cost?</h2>

<p>You might not have noticed, but we paid a subtle cost in rewriting
our <code>needsCancelButton</code> function. Let&rsquo;s compare our two functions:</p>

<pre><code class="js">// ----- before: 62 bytes (minified) -----

const needsCancelButton = (screen) =&gt; {
  return screen !== 'SuccessScreen';
};

// ----- after: 240 bytes (minified) -----

const impossible = (x) =&gt; {
  throw new Error('This case is impossible.');
};

const needsCancelButton = (screen) =&gt; {
  switch (screen) {
    case 'LoadingScreen':
      return true;
    case 'CodeEntryScreen':
      return true;
    case 'SuccessScreen':
      return false;
    default:
      return impossible(screen);
  }
};
</code></pre>

<p>With just an equality check, our function was small: 62 bytes minified.
But when we refactored to use a <code>switch</code> statement, its size shot up to
240 bytes! That&rsquo;s a 4x increase, just to get exhaustiveness. Admittedly,
<code>needsCancelButton</code> is a bit of a pathological case. But in general: as
we make our code bases <strong>more safe</strong> using Flow&rsquo;s union types of string
literals, our <strong>bundle size bloats</strong>!</p>

<h2>Types and Optimizing Compilers</h2>

<p>One of the many overlooked promises of types is the claim that by
writing our code with <strong>higher-level abstractions</strong>, we give more
information to the compiler. The compiler can then generate code that
captures our original intent, but as efficiently as possible.</p>

<p>Flow is decidedly <strong>not</strong> a compiler: it&rsquo;s only a type checker. To run
JavaScript annotated with Flow types, we first strip the types (with
something like Babel). All information about the types vanishes when we
run the code.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> What can we achieve if we were to <strong>keep the
types around</strong> all the way through compilation?</p>

<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the
benefits of the OCaml tool chain to the web. In particular, Reason
works using OCaml&rsquo;s mature optimizing compiler alongside BuckleScript
(which turns OCaml to JavaScript) to emit great code.</p>

<p>To see what I mean, let&rsquo;s re-implement our <code>Screen</code> type and
<code>needsCancelButton</code> function, this time in Reason:</p>

<pre><code class="js">type screen =
  | LoadingScreen
  | CodeEntryScreen
  | SuccessScreen;

let needsCancelButton = (screen: screen): bool =&gt; {
  switch (screen) {
  | LoadingScreen =&gt; true;
  | CodeEntryScreen =&gt; true;
  | SuccessScreen =&gt; false;
  }
};
</code></pre>

<p>Looks pretty close to JavaScript with Flow types, doesn&rsquo;t it? The
biggest difference is that the <code>case</code> keyword was replaced with the <code>|</code>
character. Making the way we define and use union types look the same is
a subtle reminder to always pair union types with <code>switch</code> statements!
<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> Another difference: Reason handles exhaustiveness checking
out of the box. üôÇ</p>

<p>What does the Reason output look like?</p>

<pre><code class="js">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE
'use strict';

function needsCancelButton(screen) {
  if (screen &gt;= 2) {
    return false;
  } else {
    return true;
  }
}
</code></pre>

<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason ‚Üí)</strong></a></p>

<p>Not bad! Telling Reason that our function was exhaustive let it optimize
the entire <code>switch</code> statement back down to a single <code>if</code> statement. In
fact, it gets even better: when we run this through <code>uglifyjs</code>, it
removes the redundant <code>true</code> / <code>false</code>:</p>

<pre><code class="js">"use strict";
function needsCancelButton(n){
  return !(n&gt;=2)
}
</code></pre>

<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code>
statement. Reason compiled what used to be a string literal
<code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely
because custom-defined types in Reason <strong>aren&rsquo;t</strong> strings, so it doesn&rsquo;t
matter if the names get mangled.</p>

<p>Taking a step back, Reason&rsquo;s type system delivered on the promise of
types in a way Flow couldn&rsquo;t:</p>

<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about our code&rsquo;s
correctness via exhaustiveness.</li>
<li>The compiler translated that all to tiny, performant output.</li>
</ul>


<p>I&rsquo;m really excited about Reason. üòÑ It has a delightful type system and
is backed by a decades-old optimizing compiler tool chain. I&rsquo;d love to
see more people take advantage of improvements in type systems to write
better code!</p>

<hr />

<h2>Appendix: Other Compile-to-JS Runtimes</h2>

<p>The above analysis only considered Flow + Babel and Reason. But then I
got curious about how other typed languages that compile to JavaScript
compare on the optimizations front:</p>

<h3>TypeScript</h3>

<p>Despite being a language <strong>and</strong> compiler, TypeScript maintains a
goal of compiling to JavaScript that closely resembles the source
TypesScript code. TypeScript has three language constructs for working
with exhaustiveness:</p>

<ol>
<li>union types (identical to the Flow unions that we&rsquo;ve been talking
about),</li>
<li><code>enum</code>s, which are sort of like definition a group of variable
constants all at once, and</li>
<li><code>const enum</code>s which are like <code>enum</code>s except that they&rsquo;re represented
more succinctly in the compiled output.</li>
</ol>


<p>TypeScript&rsquo;s union type over string literals are represented the same
way as Flow, so I&rsquo;m going to skip (1) and focus instead on (2) and (3).</p>

<p>TypeScript&rsquo;s <code>enum</code> and <code>const enum</code> are subtly different. Not having
used the language much, I&rsquo;ll refer you to <a href="https://www.typescriptlang.org/docs/handbook/enums.html">the TypeScript
documentation</a> to learn more about the differences. But for
sure, <code>const enum</code>s compile much better than normal <code>enum</code>s.</p>

<p>Here&rsquo;s what normal <code>enum</code>s look like in TypeScript&mdash;they&rsquo;re <strong>even
worse</strong> than unions of string literals:</p>

<pre><code class="js">var Screen_;
(function (Screen_) {
    Screen_[Screen_["LoadingScreen"] = 0] = "LoadingScreen";
    Screen_[Screen_["CodeEntryScreen"] = 1] = "CodeEntryScreen";
    Screen_[Screen_["SuccessScreen"] = 2] = "SuccessScreen";
})(Screen_ || (Screen_ = {}));
var impossible = function (x) {
    throw new Error('This case is impossible.');
};
var needsCancelButton = function (screen) {
    switch (screen) {
        case Screen_.LoadingScreen:
            return true;
        case Screen_.CodeEntryScreen:
            return true;
        case Screen_.SuccessScreen:
            return false;
        default:
            return impossible(screen);
    }
};
</code></pre>

<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground ‚Üí</strong></a></p>

<p>So for normal <code>enum</code>s:</p>

<ul>
<li>It&rsquo;s not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of
enum values at run time, in a format that doesn&rsquo;t minify well.</li>
</ul>


<p>And then here&rsquo;s what <code>const enum</code>s look like&mdash;you can see that
TypeScript represents them under the hood without any sort of <code>Screen_</code>
object:</p>

<pre><code class="js">var impossible = function (x) {
    throw new Error('This case is impossible.');
};
var needsCancelButton = function (screen) {
    switch (screen) {
        case 0 /* LoadingScreen */:
            return true;
        case 1 /* CodeEntryScreen */:
            return true;
        case 2 /* SuccessScreen */:
            return false;
        default:
            return impossible(screen);
    }
};
</code></pre>

<p><a href="https://www.typescriptlang.org/play/#src=const%20enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground ‚Üí</strong></a></p>

<ul>
<li>It uses numbers instead of strings.</li>
<li>It still uses a switch statement, instead of reducing to just an <code>if</code>
statement.</li>
</ul>


<h2>PureScript</h2>

<p>PureScript is another high-level language like Reason. Both Reason and
PureScript have data types where we can define unions with custom
constructor names. Despite that, PureScript&rsquo;s generated code is
significantly worse than Reason&rsquo;s.</p>

<pre><code class="js">"use strict";
var LoadingScreen = (function () {
    function LoadingScreen() {};
    LoadingScreen.value = new LoadingScreen();
    return LoadingScreen;
})();
var CodeEntryScreen = (function () {
    function CodeEntryScreen() {};
    CodeEntryScreen.value = new CodeEntryScreen();
    return CodeEntryScreen;
})();
var SuccessScreen = (function () {
    function SuccessScreen() {};
    SuccessScreen.value = new SuccessScreen();
    return SuccessScreen;
})();
var needsCancelButton = function (v) {
    if (v instanceof LoadingScreen) {
        return true;
    };
    if (v instanceof CodeEntryScreen) {
        return true;
    };
    if (v instanceof SuccessScreen) {
        return false;
    };
    throw new Error("Failed pattern match at Main line 10, column 1 - line 10, column 39: " + [ v.constructor.name ]);
};
</code></pre>

<ul>
<li>It&rsquo;s generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the match is exhaustive, it still emits a
<code>throw</code> statement in case the pattern match fails!</li>
</ul>


<p>Admittedly, I didn&rsquo;t try that hard to turn on optimizations in the
compiler. Maybe there&rsquo;s a flag I can pass to get this <code>Error</code> to go
away. But that&rsquo;s pretty disappointing, compared to how small Reason&rsquo;s
generated code was!</p>

<h2>Elm</h2>

<p>I list Elm in the same class as Reason and PureScript. Like the other
two, it lets us define custom data types, and will automatically warn
when us pattern matches aren&rsquo;t exhaustive. Here&rsquo;s the code Elm
generates:</p>

<pre><code class="js">var _user$project$Main$needsCancelButton = function (page) {
  var _p0 = page;
  switch (_p0.ctor) {
    case 'LoadingScreen':
      return true;
    case 'CodeEntryScreen':
      return true;
    default:
      return false;
  }
};
var _user$project$Main$SuccessScreen = {ctor: 'SuccessScreen'};
var _user$project$Main$CodeEntryScreen = {ctor: 'CodeEntryScreen'};
var _user$project$Main$LoadingScreen = {ctor: 'LoadingScreen'};
</code></pre>

<ul>
<li>It&rsquo;s using string literals, much like Flow and TypeScript.</li>
<li>It&rsquo;s smart enough to collapse the last case to just use <code>default</code>
(at least it doesn&rsquo;t <code>throw</code> in the <code>default</code> case!)</li>
<li>The variable names are long, but these would still minify well.</li>
</ul>


<p>It&rsquo;s interesting to see that even though Reason, PureScript, and Elm all
have ML-style datatypes, Reason is the only one that uses an integer
representation for the constructor tags.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>2FA: two-factor authentication<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>&ldquo;Always&rdquo; is a very strong statement. Please use your best judgement. But know that if you&rsquo;re not using a <code>switch</code>, you&rsquo;re trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it&rsquo;s not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn&rsquo;t do compile-time optimizations based on the types.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Case Exhaustiveness in Flow]]></title>
    <link href="https://blog.jez.io/flow-exhaustiveness/"/>
    <updated>2018-04-15T20:02:26-07:00</updated>
    <id>https://blog.jez.io/flow-exhaustiveness</id>
    <content type="html"><![CDATA[<p>Compared to some other languages, <a href="https://flow.org/">Flow</a>&rsquo;s story around exhaustiveness
checking within <code>if / else</code> and <code>switch</code> statements leaves something to
be desired. By default, Flow doesn&rsquo;t do any exhaustiveness checks! But
we <strong>can</strong> opt-in to exhaustiveness checking one statement at a time.</p>

<!-- more -->


<p>In this post, we&rsquo;ll discover from the ground up how Flow&rsquo;s
exhaustiveness checking behaves. But if you&rsquo;re just looking for the
result, here&rsquo;s a snippet:</p>

<h2>TL;DR</h2>

<pre><code class="js">type A = {tag: "A"};
type B = {tag: "B"};
type AorB = A | B;

const absurd = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('This function will never run!');
}

const allGood = (x: AorB): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    return absurd(x);
  }
}

const forgotTagB = (x: AorB): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else {
    // B. This type is incompatible with the expected param type of empty.
    return absurd(x);
  }
}
</code></pre>

<h2>How Exhaustiveness Behaves in Flow</h2>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiQrACQKYCdOnngBYCGAbnsaAC4CeADngOQCCs2AQo-gJZWHXxYoUsWzdiAOyoBnNIloNQzUAF5QAbyrEA5gC5QAImYGAvgG559PO1Uatew+1MWFeVh1vKAPqHYXEAMawEtJUoJASAIy2ABQAHvru7ACU+qFiEtqqAHwaiKCg3JDxAHT2qipqRgbJ6vkFoLhUAK7YEoYAku0ARtiSAfzGFgUmoJjQ0nh1DY2YLW2dPX0SA74Gw6AmiFtyIErQ0Pjjh5IAJqDasLCnADSg3c1h8CRhRUegxKfnlBKY8KABYiTAD8aFAADE2GM4sQALZ0aCYO4EWaQYgBKhQvgUbqwcjhbiI0AAPWoQmx93GCF0cksigAwrZNDp9AZ6c46W42Ow2Iy1N5fKAfPT-EEQmEIgAmWIJJTc3mpUDpbiZHJ5ApFUrlSpVYzJdUNJqtdoGLr3ZarIb1UbjSYGgpGhampb9fhODZbHaoPYAdWIvA+SswYtuhTCrgBhGDAGtpABCMEAFRejGklMBzTtKMzmG+AOIVAGAFpiAdQIxbZguL1XSVdmAfS9CpB3rDiNG8Jh0fwayt+Jg4gjuAFeKDUGCAKIAJSnAHkp-oZkvl6BADCkgABSQBtpIA4P6VVAy2hKoGT3DTEdPhRWsHhBe43SJ8F4-EkhXh0GHvGgNCLjt+52aEinJgkAqrmdZiqE4QSAAzDKiTytg9KKsqqoqLk0zNlqOgVLqNT2rM8wmmavaWus1pjBMeBvFhWQ6o4eEYQ6czGos5qumsHrbMg3pgAAClG8B3NIQi8KmsywiqpwqlkmbUE2BCMLgoASLAYRBOQB4fGWFKApM0h1nsAAycxiZ85wUr8-yMPSXC6ZgNLjns05zguK5uQUG47nuB5HieZ5WIUaYqkEN5UHeD5Ph87TcG+H5UF+P7MW0uagABQEgX+4HBJBEQACxwXKHAKmk+7SWqGGanEZTYXR1T6oxBEsc6bF9koZEjBRdrUVV2qVPR9X1ExhGsSRbrtZsnVUS2NE4YY7IDTMv4jRa-DspxXrAGCfoBpQkwhiUB1hnuhKHHwKqxnJBattw2iEGES1pcBoGnAmezsI8RyMPi6Uqrw4w0ACeI4ClpanVG+Z6UeuhnRI0bSQA+miAT2fWoCNldKL0swAByoCnCJaZmYG6XEM00BqUCSL3B9QLRhCcD-JioC8XOABqE6XU8eCAhIjBhNocxycDDmbYE2UShIACsBVJMV3llWhBqVdVtF9XV+FLc1o1tR6k3NqAM21U4C2GklREuq17rkZW+uG2r80a2by3sWt1uUfh8T6Jg8K0MkGwFHw2AIMpfygBO2BB9gMSMMQ3TSK0pyMH71pcajyZMIHweWWHEdsFw76-B8uL4o+Za-BpjQAXc3TBqTkxgqJaYqWEdCwNI0jhXgTMQfuzQYoGIjQM0eCwC2EYVj7NCMGCMQGOnSmiHgKnCKWw9Be0FLe3QtBBlQNSox0LYop8sDb3JF50AWVA4O0mAaTQzzA8iVbnJMXeEBeOCR6AsKYO3OiYAbkfPAkA2CXHDEIImFlQ52XCFCekItkA9yggANhlghJCJVNKKwqsUHqNU1Z6kdsNLWK0dZuy6tNfBqsqjG2IU1YiZCrYdRtg1PY9JfIf38ooC8wVryXzCvePAj4+BjEnnWGYnsxHbxoMnGYmd-jZ3DpHaOsd47YETnIzYqceL02DtfA4aZZIGCwDQO4HQ4FpUDPSOMoAADKQgLFBDJqcXmLcg74j4FdM6aZpAiNWPAIE0ISCZjCuQEoBhUbvXDFw0AAjr4LAvNId8t14oA0kCpGgZUmY5mrrXHMYc7GGRVGpfh0B-QhBFqAXIKkiwARzKcIsA46C4HbtwbK+gJyDmDNfb47QgQd20BIX+UhQBQkgABDE7T2iAjLGcS8oQuyv2IP8F8zTWkd2CAZTavpuYvhAnEc+aZugAyRpiTSFJ4k30vEzSgUZoAMGwOESZYVgiILBDHOOCcuAXgsnCbm15YTBC-KlSY5xKyPyUqAp5PjnkrFeRII8kInkDjhAiFGew7pUDoNIXQIASABGjAAkoJBpAdgOCUMBwBL6EoAcAUgsBuCNIAAwlAAOwlEiMAfGARpDAAACIFmIEWVmjLTgkqoLCaAABiUgug1EJzFuKIu6jzhqAADyJmyFIrevt9CJnKvUBRId-jKLYKor5Gik4WHMEg8WUE2XoKKohZCpVULoXqMrXquETZDQYRbUiusbbdRVrNAwdCGqa0YexZhE1g1UNDbVB2kanakJduNG07sU3DQVRo+IWjPSDSXEqnKEgAAcTqeQuqwQrD1Go8GJsIQxItUaA2DAzXrEN3r+r0KdNGy2HbWFFvYZw35AVeFXlCp3HgojN7dIxClS+fRYTUACqPaRtAJGmxzZa04+b1pAA"><strong>Read on flow.org/try/</strong></a></p>

<p>Here we have a type <code>AorB</code> with two variants;</p>

<pre><code class="js">type A = {tag: "A"};
type B = {tag: "B"};
type AorB = A | B;

const fn1 = (x: AorB): string =&gt; {
  if(x.tag === "A"){
    return "In branch A";
  } else {
    return "In branch B";
  }
}
</code></pre>

<p>All well and good, but what if we add a new case?
For example, what if we take the snippet above and add this:</p>

<pre><code class="js">type C = {tag: "C"};
type AorBorC = A | B | C;

const fn2 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else {
    return "In branch B";
  }
}
</code></pre>

<p>Wait a second, it type checks!</p>

<p>That&rsquo;s because we used a catch-all <code>else</code> branch. What if we make each
branch explicit?</p>

<pre><code class="js">// ERROR:                 ‚îå‚îÄ‚ñ∂Ô∏é string. This type is incompatible with an implicitly-returned undefined.
const fn3 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  }
}
</code></pre>

<p>Phew, so it&rsquo;s reminding us that we&rsquo;re not covering all the cases.
Let&rsquo;s add the new <code>C</code> case:</p>

<pre><code class="js">// ERROR:                 ‚îå‚îÄ‚ñ∂Ô∏é string. This type is incompatible with an implicitly-returned undefined.
const fn4 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  }
}
</code></pre>

<p>Hmm: it still thinks that we might return <code>undefined</code>, even though we&rsquo;ve
definitely covered all the cases&hellip; ü§î</p>

<p>What we <strong>can</strong> do is add a default case, but ask Flow to <strong>prove</strong> that
we can&rsquo;t get there, using Flow&rsquo;s <code>empty</code> type:</p>

<pre><code class="js">const fn5 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  } else {
    (x: empty);
    throw new Error('This will never run!');
  }
}
</code></pre>

<p>The <code>throw new Error</code> line above will never run, because it&rsquo;s not
possible to construct a value of type <code>empty</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (&ldquo;There are no
values in the empty set.&rdquo;)</p>

<p>If we adopt this pattern everywhere, we&rsquo;d see this error message if we
forgot to add the new case for <code>C</code>:</p>

<pre><code class="js">const fn6 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    // C. This type is incompatible with empty.
    (x: empty);
    throw new Error('absurd');
  }
}
</code></pre>

<p>Flow tells us &ldquo;Hey, I found a C! So I couldn&rsquo;t prove that this switch
was exhaustive.&rdquo;</p>

<p>But this pattern is slightly annoying to use, because ESLint complains:</p>

<pre><code>no-unused-expressions: Expected an assignment or function call and instead saw an expression.
</code></pre>

<p>We can fix this by factoring that <code>empty ... throw</code> pattern into a
helper function:</p>

<pre><code class="js">// 'absurd' is the name commonly used elsewhere for this function. For example:
// https://hackage.haskell.org/package/void-0.7.1/docs/Data-Void.html#v:absurd
const absurd = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('absurd');
};

const fn7 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else if (x.tag === "C") {
    return "In branch C";
  } else {
    return absurd(x);
  }
}

const fn8 = (x: AorBorC): string =&gt; {
  if(x.tag === "A") {
    return "In branch A";
  } else if (x.tag === "B") {
    return "In branch B";
  } else {
    // C. This type is incompatible with the expected param type of empty.
    return absurd(x);
  }
}
</code></pre>

<p>So there you have it! You can put that helper function (<code>absurd</code>) in a
file somewhere and import it anywhere. You could even give it a
different name if you want! I&rsquo;ve been using this pattern in all the Flow
code I write these days and it&rsquo;s been nice to rely on it when doing
refactors.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Of course, this presumes that Flow&rsquo;s type system is sound, which it isn&rsquo;t. It&rsquo;s possible to accidentally inhabit <code>empty</code> if you use <code>any</code>! Moral of the story: be <em>very</em> diligent about eradicating <code>any</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Review from the Command Line]]></title>
    <link href="https://blog.jez.io/cli-code-review/"/>
    <updated>2018-01-13T13:14:24-08:00</updated>
    <id>https://blog.jez.io/cli-code-review</id>
    <content type="html"><![CDATA[<p>I do the bulk of my code reviews from the command line, especially when
reviewing larger changes. I&rsquo;ve built up a number of tools and config
settings that help me dig into the nuances of the code I&rsquo;m reviewing, so
that I can understand it better than if I were just browsing online.</p>

<!-- more -->


<p>In particular, I&rsquo;ll walk through how I&hellip;</p>

<ul>
<li>check out the code in the first place,</li>
<li>get a feel for what changed,</li>
<li>visualize the relationships between the files that changed,</li>
<li>bring up the code diffs in Vim,</li>
<li>leverage the unique power of the editor and the terminal.</li>
</ul>


<p>But first, let&rsquo;s talk briefly about the point of code review in the
first place.</p>

<h2>Code review philosophy</h2>

<p>When I ask that other people review my code, it&rsquo;s an opportunity for me
to teach them about the change I&rsquo;ve just made. When I review someone
else&rsquo;s code, it&rsquo;s to learn something from them. Some other benefits of
code review include:</p>

<ul>
<li>Team awareness (to keep a pulse on what else is going on within your
team).</li>
<li>Finding alternative solutions (maybe there&rsquo;s a small change that lets
us kill two birds with one stone).</li>
</ul>


<p>If this is different from how you think about code review, <a href="https://www.youtube.com/watch?v=PJjmw9TRB7s">check out
this talk</a>. Code review is a powerful tool for
learning and growing a team.</p>

<p>With that out of the way, let&rsquo;s dive into the tools I use to maximize
benefit I get from code review.</p>

<h2>Checking out the code</h2>

<p>The first step to reviewing code in the terminal is to check out the
code in the first place. One option is to simply to <code>git pull</code> and then
<code>git checkout &lt;branch&gt;</code>. But if you happen to be using GitHub, we can
get this down to just one command:</p>

<pre><code>hub pr checkout &lt;pr-number&gt;
</code></pre>

<p>It works using <a href="https://github.com/github/hub">hub</a>, which is a tool that exposes various features of
GitHub from the command line. If the pull request is from someone else&rsquo;s
fork, <code>hub</code> is even smart enough to add their fork as a remote and fetch
it.</p>

<h2>At first glance</h2>

<p>With the branch checked out locally, usually my next step is to get a
feel for what changed. For this, I&rsquo;ve written a git alias that shows:</p>

<ul>
<li>which files changed</li>
<li>how many lines changed in each file (additions and deletions)</li>
<li>how many lines changed overall</li>
</ul>


<p><a class="image-link" href="/images/git-stat.png"><img class="fullwidth" src="/images/git-stat.png" title="git stat" ></a></p>

<p>Here&rsquo;s the definition of <code>git stat</code> from my <code>~/.gitconfig</code>:</p>

<pre><code class="bash">[alias]
    # list files which have changed since REVIEW_BASE
    # (REVIEW_BASE defaults to 'master' in my zshrc)
    files = !git diff --name-only $(git merge-base HEAD \"$REVIEW_BASE\")

    # Same as above, but with a diff stat instead of just names
    # (better for interactive use)
    stat = !git diff --stat $(git merge-base HEAD \"$REVIEW_BASE\")
</code></pre>

<p>Under the hood, it just works using <code>git diff</code>, <code>git merge-base</code>, and a
personal environment variable <code>REVIEW_BASE</code>.</p>

<p><code>REVIEW_BASE</code> lets us choose which branch to review relative to. Most of
the time, <code>REVIEW_BASE</code> is <code>master</code>, but this isn&rsquo;t always the case! Some
repos branch off of <code>gh-pages</code>. Sometimes I like to review the most
recent commit as if it were its own branch.</p>

<p>To review the code relative so some other base, set <code>REVIEW_BASE</code> before
running <code>git stat</code>:</p>

<pre><code class="bash"># Review between 'gh-pages' and the current branch
REVIEW_BASE=gh-pages git stat

# Review changes made by the last commit of this branch:
REVIEW_BASE=HEAD^ git stat
</code></pre>

<p>I have <code>export REVIEW_BASE=master</code> in my <code>~/.bashrc</code>, because most
projects branch off of <code>master</code>.</p>

<p>Nothing too crazy yet&mdash;GitHub can already do everything we&rsquo;ve seen so
far. Let&rsquo;s start to up the ante.</p>

<h2>Visualizing file change frequency</h2>

<p>I&rsquo;ve written a short script that shows me a visualization of how
frequently the files involved in this branch change over time:</p>

<p><a class="image-link" href="/images/git-heatmap.png"><img class="fullwidth" src="/images/git-heatmap.png" title="git heatmap" ></a></p>

<p>This command identifies two main things:</p>

<ul>
<li><p><strong>Files with lots of changes</strong>.</p>

<p>Files that have changed a lot in the past are likely to change in the
future. I review these files with an eye towards what the <em>next</em>
change will bring.</p>

<p><em>&ldquo;Is this change robust enough to still be useful in the future?
Will we throw this out soon after merging it?&rdquo;</em></p></li>
<li><p><strong>Files with few changes</strong>.</p>

<p>Files that aren&rsquo;t changed frequently are more likely to be brittle.
Alternatively, it&rsquo;s often the case that infrequently changed files
stay unchanged because the change is better made elsewhere.</p>

<p><em>&ldquo;Does this change challenge an implicit assumption so that some other
part of the code was relying on? Is there a better place for this
change?&rdquo;</em></p></li>
</ul>


<p>Those two commands (<code>git stat</code> and <code>git heatmap</code>) are how I kick off my
code review: getting a birds-eye view of the change and some historical
context for what I&rsquo;m dealing with. Next, I drill down into the
relationships between the files that changed.</p>

<h2>Visualizing relationships between files</h2>

<p>At work I review JavaScript files, so I&rsquo;ve built out this next bit of
tooling specifically for JavaScript.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It helps to understand
which files import others, so I have a command that computes the
dependency graph of the files changed on this branch:</p>

<p><a class="image-link" href="/images/git-depgraph.png"><img class="fullwidth" src="/images/git-depgraph.png" title="git depgraph" ></a></p>

<p>This is where we start to see some distinct advantages over what GitHub
provides. As you see above, the <code>git depgraph</code> alias calculates the
dependency graph for files changed by this branch. Why is this useful?</p>

<ul>
<li><p>Maybe we want to start reviewing from <code>Provider.js</code>, since it doesn&rsquo;t
depend on any other files that have changed.</p></li>
<li><p>Maybe we want to work the other way: start with <code>Elements.js</code> so we
know the motivation for why <code>Provider.js</code> had to changed in the first
place.</p></li>
</ul>


<p>In either case, we can see the structure of the change. Three files
depend on <code>Elements.js</code>, so it&rsquo;s serving the needs of many modules.
<code>Element.js</code> only has one dependency, etc. Each branch&rsquo;s dependency
graph shows different information; it can be surprising what turns up.</p>

<p>I have the <code>git depgraph</code> alias defined like this:</p>

<pre><code class="bash">[alias]
    depgraph = !git madge image --webpack-config webpack.config.js --basedir . --style solarized-dark src
</code></pre>

<p>Some notes about this definition:</p>

<ul>
<li><p>It depends on the <code>git-madge</code> command, which you can <a href="https://github.com/jez/git-madge">download
and install here</a>.</p></li>
<li><p>It&rsquo;s using <em>this project&rsquo;s</em> <code>webpack.config.js</code> file, so I&rsquo;ve made
this alias local to the repo, rather than available globally.</p></li>
<li><p>It dumps the image to stdout. Above, we used iTerm2&rsquo;s <a href="https://iterm2.com/documentation-images.html">imgcat</a>
program to pipe stdin and dump a raster image to the terminal.</p>

<p>If you don&rsquo;t use iTerm2 or don&rsquo;t want to install <code>imgcat</code>, you can
pipe it to Preview using open<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (<code>open -f -a Preview</code>) or just
redirect the PNG to a file.</p></li>
</ul>


<p>The <code>git depgraph</code> alias is a game changer. It makes it easier to get spun
up in new code bases, helps make sense of large changes, and just looks
plain cool. But at the end of the day, we came here to review some code,
so let&rsquo;s take a look at how we can actually view the diffs of the files
that changed.</p>

<h2>Reviewing the diffs</h2>

<p>To review the diffs, the simplest option is to just run <code>git diff
master..HEAD</code>. This has a bunch of downsides:</p>

<ul>
<li><p>No syntax highlighting (everything is either green or red).</p></li>
<li><p>No surrounding context (for example, GitHub lets you click to expand
lines above or below a diff hunk).</p></li>
<li><p>The diff is &ldquo;unified,&rdquo; instead of split into two columns.</p></li>
<li><p>No way to exclude a specific file (the 300 line diff to your
<code>yarn.lock</code> file is sometimes nice to hide).</p></li>
</ul>


<p>My solution to all of these problems is to view the diffs in Vim, with
the help of two Vim plugins and two git aliases. Before we get to
that, here&rsquo;s a screenshot:</p>

<p><a class="image-link" href="/images/git-review.png"><img class="fullwidth" src="/images/git-review.png" title="git review" ></a></p>

<p>Looks pretty similar to GitHub&rsquo;s interface, with the added bonus that
it&rsquo;s using my favorite colorscheme! The Vim plugins featured are:</p>

<ul>
<li><a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> for showing the side-by-side diff (<code>:Gdiff</code>).</li>
<li><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> for showing the <code>+/-</code> signs.</li>
<li><a href="https://github.com/jez/vim-colors-solarized">jez/vim-colors-solarized</a> for tweaking the diff highlight
colors.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>And to orchestrate the whole thing, I&rsquo;ve set up these two aliases:</p>

<pre><code class="bash">[alias]
  # NOTE: These aliases depend on the `git files` alias from
  # a few sections ago!

    # Open all files changed since REVIEW_BASE in Vim tabs
    # Then, run fugitive's :Gdiff in each tab, and finally
    # tell vim-gitgutter to show +/- for changes since REVIEW_BASE
    review = !vim -p $(git files) +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"

    # Same as the above, except specify names of files as arguments,
    # instead of opening all files:
    # git reviewone foo.js bar.js
    reviewone = !vim -p +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"
</code></pre>

<p>Here&rsquo;s how they work:</p>

<ul>
<li><p><code>git review</code> opens each file changed by this branch as a tab in Vim.
Then <code>:Gdiff</code> from vim-fugitive shows the diff in each tab.</p></li>
<li><p><code>git reviewone</code> is like <code>git review</code>, but you specify which
files to open (in case you only want to diff a few).</p></li>
</ul>


<p>Like with the <code>git stat</code> alias, these aliases respect the <code>REVIEW_BASE</code>
environment variable I&rsquo;ve set up in my <code>~/.bashrc</code>. (Scroll back up for
a refresher.) For example, to review all files relative to <code>master</code>:</p>

<pre><code class="bash">REVIEW_BASE=master git review
</code></pre>

<p>At this point, you might think that all we&rsquo;ve done is re-create the
GitHub code review experience in Vim. But actually what we&rsquo;ve done is so
much more powerful.</p>

<h2>Interactive Code Review</h2>

<p>When reviewing on GitHub, the code is completely static&mdash;you can&rsquo;t
change it. Also, because the code is coming from GitHub&rsquo;s servers,
it&rsquo;s laggy when you click around to view related files. By switching our
code review to the terminal, we can now edit files, jump to other files,
and run arbitrary commands at no cost.</p>

<p>It might not be obvious how huge of a win this is, so let&rsquo;s see some
examples. Take this screenshot of the <code>requireElement</code> function. It
moved from <em>above</em> the <code>findElement</code> function to <em>below</em> it (probably
because the former calls the latter):</p>

<p><a class="image-link" href="/images/requireElement01.png"><img class="fullwidth" src="/images/requireElement01.png" title="diff" ></a></p>

<p>But is the location of the <code>requireElement</code> function the only thing
that&rsquo;s changed? By editing the file to move the function back to its
original location, vim-fugitive will automatically recompute the diff.
And in fact, we can see that the <em>type of the argument</em> has changed too,
from <code>string</code> to <code>ElementType</code>:</p>

<p><a class="image-link" href="/images/requireElement02.png"><img class="fullwidth" src="/images/requireElement02.png" title="diff" ></a></p>

<p>If we had been viewing this on GitHub, we might have taken for granted
that the function didn&rsquo;t change. But since we&rsquo;re in our editor, we can
interactively play around with our code and discover things we might
have missed otherwise. The advantages of interactive code review go well
beyond this example:</p>

<ul>
<li><p>In a Flow project, we can ask for the type of a variable.</p></li>
<li><p>In a test file, we can change the test and see if it still passes or
if it now fails.</p></li>
<li><p>We can <code>grep</code> the project for all uses of a function (including files
<em>not</em> changed by this branch).</p></li>
<li><p>We can open up related files for cross-referencing.</p></li>
<li><p>We can run the code in a debugger and see how it behaves.</p></li>
</ul>


<p>By having the full power of our editor, we can literally retrace the
steps that the author went through to create the pull request. If our
goal is to understand and learn from code review, there&rsquo;s no better way
than walking in the author&rsquo;s shoes.</p>

<h2>Recap</h2>

<p>To recap, here&rsquo;s a list of the tools I use to review code at the command
line:</p>

<ul>
<li><code>hub pr checkout</code></li>
<li><code>git stat</code> to list files that have changed</li>
<li><code>git heatmap</code> to show how frequently these files change</li>
<li><code>git depgraph</code> to show a graph of which files depend on which</li>
<li><code>git review</code> to open diffs of all the files in Vim</li>
<li><code>git reviewone</code> to open diffs for a specific handful of files</li>
</ul>


<p>If you&rsquo;re having trouble incorporating any of these into your workflow,
feel free to reach out and let me know! I&rsquo;m happy to help.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The techniques here apply to any language that you can statically analyze. In particular, I have a rough prototype of everything JavaScript-specific you see here that works with Standard ML instead. If you can find me the dependency information for your favorite language, I&rsquo;d be happy to help you turn it into a visualization.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The <code>open</code> command is macOS-specific. On Linux, you might want to look at the <code>display</code> command from ImageMagick.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>I&rsquo;ve patched the default Solarized colors for Vim so that lines retain their syntax highlighting in the diff mode, while the backgrounds are highlighted. You can see how this works in this commit: <a href="https://github.com/jez/vim-colors-solarized/commit/bca72cc">https://github.com/jez/vim-colors-solarized/commit/bca72cc</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
