<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/docker/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-06-21T12:34:54-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Docker Tips and Cheatsheet]]></title>
    <link href="https://blog.jez.io/2015/07/12/docker-tips-and-cheatsheet/"/>
    <updated>2015-07-12T22:32:27-04:00</updated>
    <id>https://blog.jez.io/2015/07/12/docker-tips-and-cheatsheet</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been using Docker for a couple side projects lately, but only
intermittently. That means every time I try to get back into things, I spend the
first 15 minutes or so trying to remember all the little tricks I&rsquo;ve picked up
from previous Google searches and hunts through the documentation. Rather than
continue to suffer through this cycle, I&rsquo;ve written them down here to help you
and me ramp up more quickly on our next Docker projects.</p>

<!-- more -->


<h2>Making your Docker experience easier: Docker Compose</h2>

<p>Half the complexity of Docker is wrapped up in its large, verbose set of command
line arguments and flags. Luckily, Docker has a tool called <a href="https://docs.docker.com/compose/">Docker Compose</a>
that lets us translate all our command line flags into a <code>.yml</code> file. This makes
it much easier to remember how to build and run your containers, as well as to
communicate with your teammates; you no longer need to a common &ldquo;setup.sh&rdquo;
script that remembers what obscure Docker commands and flags you used to set
things up. If you&rsquo;ve never heard of it, you might want to <a href="https://docs.docker.com/compose/">check it out
now</a>. I&rsquo;ll be mixing-and-matching my favorite <code>docker</code> and <code>docker-compose</code>
commands through the rest of the post.</p>

<h2>TL;DR</h2>

<p>Here&rsquo;s a quick cheatsheet:</p>

<pre><code class="bash"># Build your whole Docker Compose project...
docker-compose build
# ...or just build one piece of it
docker-compose build [app|db|etc...]

# Start your Docker Compose project
docker-compose up -d
# View the logs for this docker-compose proejct
docker-compose logs
# Stop running containers
docker-compose stop

# remove stopped containers
docker rm $(docker ps -a | grep Exited | awk '{print $1;}')
# or, to remove the stopped containers that were started by Docker Compose
docker-compose rm
# remove untagged images
docker rmi $(docker images -q --filter "dangling=true")
# Clean up dangling volumes
# (see the post below for how to install the python script)
sudo python docker_clean_vfs.py
# Better yet, remove dangling volumes before they're created by using -v
docker-composer rm -v
</code></pre>

<p>Keep in mind that Docker Compose needs to always read your <code>docker-compose.yml</code>
file, so make sure to always run <code>docker-compose</code> commands from the root of your
project.</p>

<h2>Building your app</h2>

<p>Docker Compose&rsquo;s biggest advantage is that it simplifies building your
Dockerized app to just</p>

<pre><code>docker-compose build
</code></pre>

<p>Most apps, though, have a couple Docker Compose targets, like <code>db</code> and <code>app</code> in
this sample <code>docker-compose.yml</code> file:</p>

<pre><code class="yaml docker-compose.yml">db:
  image: postgres
  ...
app:
  build: .
  ...
</code></pre>

<p>If all you&rsquo;ve done is made a simple change to <code>app</code>, you can get by with just</p>

<pre><code>docker-compose build app
</code></pre>

<p>without having to rebuild all of <code>db</code> as well.</p>

<h2>Running your app</h2>

<p>To start a Docker Compose app once you&rsquo;ve built it&rsquo;s constituent images:</p>

<pre><code>docker-compose up -d
</code></pre>

<p>The <code>-d</code> flag is so that Docker Compose runs the command as a &ldquo;daemon&rdquo;, or in
the background. I can&rsquo;t think of any cases where you wouldn&rsquo;t want to use this
flag.</p>

<p>To view the logs from your app&rsquo;s running containers:</p>

<pre><code>docker-compose logs
</code></pre>

<p>This will show all the logs output as one, prefixed with their name as specified
in the <code>docker-compose.yml</code> file so you can keep things straight.</p>

<p>To bring your app down (if you started it with <code>-d</code>, otherwise just use <code>^C</code>):</p>

<pre><code>docker-compose stop
</code></pre>

<h2>Getting rid of what Docker left behind</h2>

<p>You&rsquo;ll find after using Docker for a while that your disk usage seems to be
creeping upwards. This annoyed me at first, so I investigated. There are three
places Docker leaves junk behind.</p>

<h3>Stopped Docker containers</h3>

<p>Once you&rsquo;ve stopped your Docker containers, they remain on disk. If you&rsquo;re using
Docker Compose, you can just run the following to get rid of any containers
started by Docker Compose that have now stopped:</p>

<pre><code>docker-compose rm
</code></pre>

<p>If you&rsquo;re not using Docker Compose, you&rsquo;ll have to find them and manually prune
them:</p>

<pre><code class="bash"># find all exited containers (docker ps ...),
# and remove these containers (docker rm)
docker rm $(docker ps -a | grep Exited | awk '{print $1;}')
</code></pre>

<h3>Un-tagged Docker images</h3>

<p>When you&rsquo;re using Docker for developing an app, every time you change and
rebuild your Docker images, you&rsquo;ll leave behind an old, un-tagged image. This is
actually a &ldquo;feature&rdquo; of Docker: all images that you build are cached so that
subsequently builds are instantaneous. However, when we&rsquo;re developing and
generating new images frequently, previous image builds only take up space.</p>

<pre><code># find all un-tagged images (docker images ...),
# and remove these images (docker rmi)
docker rmi $(docker images -q --filter "dangling=true")
</code></pre>

<p>You can always tag one of these images if you don&rsquo;t want it to get garbage
collected by the above command.</p>

<h3>Dangling volumes</h3>

<p>Every time you create and mount a volume into a docker container, Docker leaves
behind some state for managing that volume. Unfortunately (and infuriatingly),
the Docker CLI doesn&rsquo;t offer a way to clean these up natively. Luckily, there&rsquo;s
a super handy script online that uses the Docker Python API to handle it.</p>

<pre><code># Install Python dependencies (do this only once)
pip install docker-py

# Download the script
wget https://raw.githubusercontent.com/dummymael/dotfiles/1859a36/tools/docker_clean_vfs.py

# Run the script
sudo python docker_clean_vfs.py
</code></pre>

<p>You can circumvent this madness if you make sure to remove your volumes before
they become dangling by using the following when your Docker Compose project
uses volumes:</p>

<pre><code>docker-compose rm -v
</code></pre>

<h2>General Docker Wisdom</h2>

<p>Apart from that (small?) set of commands, the only other way I use Docker is
just writing <code>Dockerfile</code>s and <code>docker-compose.yml</code> files. Most of what you need
to know here comes from experience or looking at example files. I do, though,
have some tidbits of extra advice related to things that tripped me up in my
first Docker experiences.</p>

<p>You have to run <code>docker-compose build web</code> if you change the underlying
Dockerfile and you want the image to be rebuilt. Otherwise, <code>docker-compose up
-d</code> will happily use the old, cached image.</p>

<p>If a command failed, whether it was a one-off <code>docker run</code> command, an image
build, etc., it probably left its intermediate cruft around. See <a href="#getting-rid-of-what-docker-left-behind">Getting rid of
what Docker left behind</a> for more info.</p>

<p>Add an alias for <code>docker-compose</code>. That&rsquo;s far too long to be typing out all the
time. I use <code>alias fig="docker-compose"</code> remembering <a href="https://fig.sh">Docker Compose&rsquo;s
roots</a>.</p>

<p>Once I&rsquo;ve gotten my build environment to the point where I can just change my
core app (i.e., I&rsquo;ve set up the <code>Dockerfile</code> and <code>docker-compose.yml</code> file), I
basically just run</p>

<pre><code>fig up -d

fig logs
# observe my project, fix what's wrong
^C &lt;-- quits the logs
fig stop &amp;&amp; fig rm -v &amp;&amp; fig build web &amp;&amp; fig up -d

fig logs
# observe my project, fix what's wrong
^C
fig stop &amp;&amp; fig rm -v &amp;&amp; fig build web &amp;&amp; fig up -d

...
</code></pre>

<p>It helps to understand the difference between &ldquo;images&rdquo; and &ldquo;containers&rdquo;. There
are plenty of ways to remember the difference between the two, but I like the
object-oriented programming analogy: &ldquo;images&rdquo; are to classes like &ldquo;containers&rdquo;
are to objects. The analogy isn&rsquo;t quite perfect, but it&rsquo;s close enough. We
create a new container (object) every time we run (instantiate) the image
(class). Images come with an understanding of what&rsquo;s common to all containers
(like the root file system, software dependencies, and app files), just like
classes know their constructor and member methods.</p>

<h2>More Tips</h2>

<p>Two blog posts were particularly helpful in compiling this list of commands; I&rsquo;d
be remiss to not acknowledge their wonderful work:</p>

<ul>
<li><a href="http://www.carlboettiger.info/2014/08/29/docker-notes.html">Docker tricks of the trade and best practices thoughts</a></li>
<li><a href="http://odino.org/spring-cleaning-of-your-docker-containers/">Spring cleaning of your Docker containers</a></li>
</ul>


<p>I&rsquo;ve entirely focused on the commands you can use to build, run, and manage your
Docker app in this post. The rest is just a matter of getting your <code>Dockerfile</code>
and <code>docker-compose.yml</code> to where you need them to be. For this, I&rsquo;d recommend</p>

<ul>
<li>the Docker documentation on <a href="https://docs.docker.com/articles/dockerfile_best-practices/">Dockerfile best practices</a>, as well as</li>
<li><a href="http://anandmanisankar.com/posts/docker-container-nginx-node-redis-example/">this walkthrough</a> for Dockerizing a sample app (in Node.js, but
the principles are generally applicable)</li>
</ul>


<p>Apart from that, try to find examples of these files that you can adapt to your
needs.</p>
]]></content>
  </entry>
  
</feed>
