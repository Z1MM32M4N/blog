<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/haskell/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-12-29T12:19:22-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Profiling in Haskell for a 10x Speedup]]></title>
    <link href="https://blog.jez.io/profiling-in-haskell/"/>
    <updated>2019-05-20T03:13:34+08:00</updated>
    <id>https://blog.jez.io/profiling-in-haskell</id>
    <content type="html"><![CDATA[<p>I wrote up a toy project in Haskell and profiled it to learn about
Haskell&rsquo;s profiling tools and about profiling code in general.
Profiling in Haskell with Stack is super easy; to prove it I&rsquo;ll walk
through the problem I was trying to solve, my slow first solution, and
how I used Haskell&rsquo;s profiling tools to find and fix some egregiously
slow parts of the code.</p>

<!-- more -->


<p>I had three takeaways from this little project:</p>

<ul>
<li>Guessing at how to make code faster works sometimes, but:</li>
<li>profiling in Haskell is actually super painless, and is a way better
use of my time than guessing at what&rsquo;s slow.</li>
<li>With repeated profiling it&rsquo;s definitely possible to make reasonably
fast Haskell.</li>
</ul>


<p>The source code and profiling data for this project is all available
<a href="https://github.com/jez/bingo-sim">on GitHub</a>. Also the Appendix below has a bunch of links to
help you find the interesting parts of the code.</p>

<h2>Problem: simulating probabilities</h2>

<p>The problem I wanted to solve was to simulate the probability of winning
one carnival game I got to play while on vacation recently. The game
itself is super simple and purely luck-based. The rules:</p>

<ol>
<li>There&rsquo;s a 6 √ó 6 grid, each with a special character identifying it.</li>
<li>There are 36 tiles, each with a character matching one grid space
(and there are no duplicates, so all characters are accounted for).</li>
<li>Initially, all tiles are placed face down.</li>
<li>To play, a contestant chooses 15 of the 36 tiles and flips them
over.</li>
<li>The contestant then places the flipped tiles onto the correct spots.</li>
<li>If placing the 15 tiles forms a bingo in any row, column, or full
diagonal, it&rsquo;s a win. Otherwise, it&rsquo;s a loss.</li>
</ol>


<p>The game setup in real life looked something like this:</p>

<p><a href="/images/taiwan-carnival-bingo.jpg"><img src="/images/taiwan-carnival-bingo.jpg" alt="Taiwan Carnival Bingo" /></a></p>

<p>(<a href="https://www.b-kyu.com/2014/07/hua-yuan-night-market-tainan-taiwan.html">Image credit</a>)</p>

<p>My question was: how lucky should we considider ourselves if we win?
I&rsquo;m sure I could have answered this exactly with some combinatorics, but
that seemed boring. Instead, I wanted to write a program solve it:
generate random boards, and check how many of them have bingos.</p>

<h2>Naive solution</h2>

<p>In the course of playing around with this problem, I implemented a bunch
of different solutions‚Äîabout 5 in total, each one faster than the last.
At a high level, each solution followed this pattern:</p>

<ul>
<li>generate a board uniformly at random</li>
<li>count how many of the generated boards had bingos</li>
</ul>


<p>All the solutions exploited the fact that we don&rsquo;t care where the
characters on the board are nor what characters are on the tiles. The
only thing that matters is whether a tile ends up on a specific grid
space, which means boards can just be vectors of bits.</p>

<p><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> was <em>really</em> slow, so we won&rsquo;t talk about it üòÖ</p>

<p><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was a little bit faster (but not by much, which made me
disappointed‚Äîmore on this later). The solution looked like this:</p>

<ul>
<li><p>Our 6 √ó 6 grids are represented as bit-matrices in row-major order, so
we can store them in a 64-bit unsigned int (<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64"><code>Word64</code></a>) and only use
the 36 least significant bits. A <code>1</code> on our board means &ldquo;one of the 15
tiles we picked matched this grid spot.&rdquo;</p></li>
<li><p>To generate a random board, we start with a board of 15 consecutive
<code>1</code>&rsquo;s (<code>0x7fff</code>) and then use the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> to shuffle
the bits amongst the 36 available bits.</p>

<p>Fisher-Yates shuffle is actually really simple, which is nice.
Here&rsquo;s the <a href="https://github.com/jez/bingo-sim/blob/8886a66/src/BingoSim/Simulation.hs#L111-L126">six lines</a> to implement it in Haskell
on a bit vector:</p></li>
</ul>


<pre><code class="haskell">shuffleBits :: RandomGen g =&gt; g -&gt; Board -&gt; Int -&gt; (Board, g)
shuffleBits gen board 1 = (board, gen)
shuffleBits gen (Board bs) n =
  -- (Maybe) swap the current MSB with one of the lesser bits
  let (i, gen') = randomR (0, n - 1) gen
      bs'       = swapBits bs (n - 1) i
  -- Recurse on the lesser bits
  in  shuffleBits gen' (Board bs') (n - 1)
</code></pre>

<ul>
<li>With the above method, we generate 100,000 random boards using and
check how many boards have at least one bingo.</li>
</ul>


<h2>Clever, but not in the right ways</h2>

<p>All told, I thought the approach in <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was pretty clever. It
used a single <code>Word64</code> (instead of a larger structure like a list) to
represent the board, so it shouldn&rsquo;t have had needed many allocations.
And because it was just a <code>Word64</code>, it could use bit operations to
manipulate the board and check for bingos, avoiding the need to walk a
large structure.</p>

<p>But when I ran this on my 2017 MacBook Pro (i7-7920HQ CPU @ 3.10GHz, 16
GB memory), it was still really slow:</p>

<pre><code>‚ùØ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
Trials:   100000
Bingos:   3529
Hit rate: 0.03529
  0.71s user  0.02s system  98% cpu  0.738 total
</code></pre>

<p>(Note that we&rsquo;re running <code>time</code> on the compiled binary directly, instead
of running with <code>stack exec --</code>; we don&rsquo;t care for the overhead from
running via Stack).</p>

<p>So even after using a bit vector for the board, it took 738ms. To be
clear, these results for <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> were an improvement over my even
slower <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>, but not by much‚Äîmaybe by 200ms. 700ms+ seemed
excessive.</p>

<h2>How to profile Haskell code</h2>

<p>Determined to make it faster, at this point I resigned myself from
guessing and looked up how to profile Haskell code. Turns out, with
Stack it&rsquo;s <strong>super</strong> simple:</p>

<pre><code class="bash"># Rebuild with profiling information
‚ùØ stack build --profile

# Run the code with runtime profiling enabled
‚ùØ stack exec -- bingo-sim 100000 +RTS -p -RTS
</code></pre>

<p>That&rsquo;s all it took, and it generated a <code>bingo-sim.prof</code> file that had a
bunch of lines that <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">looked like this</a>:</p>

<pre><code>COST CENTRE              MODULE  SRC  no.  entries  %time %alloc   %time %alloc
...
  randomR                ...     ...  ...  ...       0.8    0.0    84.9   83.5
  randomIvalIntegral     ...     ...  ...  ...       6.9   13.4    84.1   83.5
   randomIvalInteger     ...     ...  ...  ...      21.3   29.2    77.2   70.1
    randomIvalInteger.f  ...     ...  ...  ...      11.0    2.4    41.5   31.5
</code></pre>

<p>There&rsquo;s a bunch of extra information in the actual <code>.prof</code> file (which
you can <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">see on GitHub</a>) but the important parts for
me were the four columns at the end. The first two are the proporion of
execution time and allocated memory attributable to this cost center
specifically. The last two are the same, but summed over all child cost
centers.</p>

<p>(I found the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">GHC User Guide</a> <em>super</em> helpful to learn everything I
wanted to know: what the columns mean, what a cost center is, and some
tips for profiling in general).</p>

<p>So the glaring realization in the data: we&rsquo;re spending 85% of our 738ms
running time <strong>generating random numbers</strong>. All my effort spent
optimizing memory, but it was the PRNG that was slow the whole time. üò£</p>

<h2>Fast PRNG in Haskell</h2>

<p>738ms √ó 0.849 ‚âà 600ms+ spent generating random numbers seemed like an
absurd abount of time. Non-cryptographically secure pseudo random number
generation shouldn&rsquo;t take this long. And indeed, after a bit of
searching I came across <a href="https://www.reddit.com/r/haskell/comments/7ma9rd/in_your_professional_experience_how_suitable_is/">this reddit thread</a> complaining about how slow
<code>System.Random</code> in Haskell is for PRNG, and then moments later I found
<a href="https://nullprogram.com/blog/2017/09/21/">this article</a> from Chris Wellons comparing various PRNGs for
performance&hellip; Exactly what I was looking for üëå</p>

<p>So for <a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a>, I took his <a href="http://xoshiro.di.unimi.it/">suggested PRNG</a> and ported it from
<a href="http://xoshiro.di.unimi.it/xoshiro256starstar.c">C</a> to <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs">Haskell</a>.</p>

<p>And lo and behold, it was faster. A lot faster:</p>

<pre><code>‚ùØ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
Trials:   100000
Bingos:   3670
Hit rate: 0.0367
  0.11s user  0.01s system  90% cpu  0.126 total
</code></pre>

<p>Yep. That just went from 738ms to 126ms, for a 5.8x speedup ü§Ø</p>

<p>With a result this good, we might ask ourselves what we had to give up
in the process‚Äîthings this good usually come at a price. The biggest one
that I notice is that the API I provide for random number generation is
far less generic.</p>

<p>My <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> is a direct translation of the C to Haskell. It
only generates 64-bit unsigned ints. <code>System.Random</code> has an arguably
nicer API, using type classes to generate random ints, characters, etc.,
allowing users to implement generators for their custom types, and
having helpers for generating random values within a range and sequences
of random numbers.</p>

<p>It&rsquo;s possible we could prune some of the fat from <code>System.Random</code>&rsquo;s
default implementations (without also changing the underlying random
number generator) and see a considerable speedup. It&rsquo;s also possible we
could make <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> export instances of the appropriate type
classes, and again see a speedup.</p>

<p>But considering that I wasn&rsquo;t using any of that extra stuff, I figured
I&rsquo;d just keep it simple. The code to generate random boards hardly
changed:</p>

<pre><code class="haskell">shuffleBits :: Prng.State -&gt; Board -&gt; Int -&gt; (Board, Prng.State)
shuffleBits gen board 1 = (board, gen)
shuffleBits gen (Board bs) n =
  let n'           = n - 1
      (rand, gen') = next gen
      -- Uses `mod` instead of `randomR` to generate within a range
      i            = rand `mod` (fromIntegral n)
      bs'          = swapBits bs n' (fromIntegral i)
  in  shuffleBits gen' (Board bs') n'
</code></pre>

<h2>Further speedups</h2>

<p>Spurred on by the thrill of the previous speedup, I kept going. By this
time I&rsquo;d learned the value in following the <code>.prof</code> output. The output
led me to <a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a>, which refactored the PRNG into CPS avoid
allocating a tuple, and then <a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a>, where I added some
<code>BangPatterns</code>.</p>

<p>At the end of it all, my simulation ran in just 70ms!</p>

<pre><code>‚ùØ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
Trials:   100000
Bingos:   3670
Hit rate: 0.0367
  0.06s user   0.01s system   92% cpu   0.070 total
</code></pre>

<p>This is a 10x speedup over my dissapointing <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a>, and a 12.8x
speedup over my super naive <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>. Not bad for a first attempt at
profiling in Haskell!</p>

<p>I found this super encouraging. Given how easy the tooling is to get
started with, how well documented things are, and my satisfaction with
the results, I&rsquo;m very likely to reach for profiling tools in the future.</p>

<h2>Appendix: Links</h2>

<p>The entire source is <a href="https://github.com/jez/bingo-sim">on GitHub</a>.</p>

<p>I wrote up all five of my attepts as separate GitHub commits, so if you
want to compare and constrast the approaches feel free:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> (899ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> (738ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a> (126ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a> (101ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a> (70ms)</li>
</ul>


<p>I also had never used Haddock before, so I used this project as an
opportunity to learn how to build and write Haddock. I published the
docs on GitHub pages if you want to browse them:</p>

<ul>
<li><a href="https://jez.io/bingo-sim/">Docs</a></li>
</ul>


<p>And I also put the source for all the <code>.prof</code> files I generated for each
attempt:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.1.prof"><code>bingo-sim.1.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof"><code>bingo-sim.2.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.3.prof"><code>bingo-sim.3.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.4.prof"><code>bingo-sim.4.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.5.prof"><code>bingo-sim.5.prof</code></a></li>
</ul>


<p>If you have any questions about anything, feel free to <a href="https://jez.io/">reach out</a>!</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lenses & Composition]]></title>
    <link href="https://blog.jez.io/lens-composition/"/>
    <updated>2018-02-05T23:07:37-08:00</updated>
    <id>https://blog.jez.io/lens-composition</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>A lens is really just a function <code>a -&gt; b</code> that we represent
backwards<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and with an extra <code>Functor f</code> parameter lying
around:</p>

<pre><code>type Lens' a b = Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
</code></pre>

<p><strong>What does this mean for function composition?</strong></p>

<!-- more -->


<p>Normal function composition looks like this:</p>

<pre><code class="haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)

f :: a -&gt; b
g :: b -&gt; c

g . f :: (a -&gt; c)
</code></pre>

<p>We often have to read code that looks like this:</p>

<pre><code class="haskell">g . f $ x
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then run <code>f</code> on it, and run <code>g</code> after that.&rdquo;
This sentence reads opposite from how the code reads!</p>

<p>What about for lenses? Here we have <code>f'</code> and <code>g'</code> which behave similarly
in some sense to <code>f</code> and <code>g</code> from before:</p>

<pre><code class="haskell">f' :: Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
--  ‚âà a -&gt; b
g' :: Functor f =&gt; (c -&gt; f c) -&gt; (b -&gt; f b)
--  ‚âà b -&gt; c

f' . g' :: Functor f =&gt; (c -&gt; f c) -&gt; (a -&gt; f a)
--       ‚âà a -&gt; c
</code></pre>

<p>In the lens world, <code>^.</code> behaves kind of like a flipped <code>$</code> that turns
lenses into getters, which lets us write code like this:</p>

<pre><code class="haskell">x ^. f' . g'
</code></pre>

<p>This means &ldquo;start with <code>x</code>, then get <code>f'</code> from it, then get <code>g'</code> after
that.&rdquo; The sentence reads just like the code!</p>

<p>This is pretty cool, because it means that lenses (which are
&ldquo;functional&rdquo; getters) read almost exactly like property access (which
are &ldquo;imperative&rdquo; getters). Same concise syntax, but with an elegant
semantics.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m exaggerating a bit here üòÖ To see what I <em>really</em> mean, see <a href="/lens-intuition">this post</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Intuition on Lenses]]></title>
    <link href="https://blog.jez.io/lens-intuition/"/>
    <updated>2018-02-05T21:09:43-08:00</updated>
    <id>https://blog.jez.io/lens-intuition</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been working on a small project in Haskell recently that uses the
<a href="https://hackage.haskell.org/package/wreq">wreq</a> library. It&rsquo;s an HTTP client library that exposes most of its
functionality through lenses. Using this library is my first time really
using lenses pervasively, so I&rsquo;ve spent some time trying to understand
how lenses really work.</p>

<!-- more -->


<p>Lenses try to bring the concept of getters and setters into a functional
setting. Here, &ldquo;functional&rdquo; means that lenses prioritize composition
(chaining one lens after another) and immutability (returning a new
data structure<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> instead of mutating the old one in place).</p>

<p>In a functional setting, if we have a type <code>s</code> and we want to get some
field of type <code>a</code> from it, a getter is just a function <code>s -&gt; a</code>.</p>

<p>Similarly, a setter that updates that field has the type <code>s -&gt; a -&gt; s</code>
which takes the old <code>s</code> and slots the <code>a</code> into it, giving us back a new
<code>s</code>.</p>

<p>Let&rsquo;s see if we can build up some intuition, starting with these types
and ending with the type of <code>Lens'</code> from the lens library:</p>

<pre><code class="haskell">type Lens' s a = forall f. Functor f =&gt; (a -&gt; f a) -&gt; (s -&gt; f s)
</code></pre>

<p>In particular, let&rsquo;s start with our getter:</p>

<pre><code class="haskell">fn :: s -&gt; a
</code></pre>

<p>The first thing we can do is convert it to continuation-passing style
(CPS). In CPS form, a function throws it&rsquo;s return value to a
user-specified callback function (or continuation) instead of returning
its value directly. So our <code>s -&gt; a</code> becomes:</p>

<pre><code class="haskell">fn :: (a -&gt; r) -&gt; s -&gt; r
</code></pre>

<p>After we&rsquo;re done computing an <code>a</code> from the <code>s</code> we were given, we throw
it to the continuation of type <code>a -&gt; r</code>. We then take <strong>that</strong> result and
return it. I like to put parens around the second function:</p>

<pre><code class="haskell">fn :: (a -&gt; r) -&gt; (s -&gt; r)
</code></pre>

<p>But it&rsquo;s kind of hard to do anything with this, because <code>r</code> is
completely arbitrary. It&rsquo;s chosen by whoever calls us, so we have no
information about what can be done on an <code>r</code>. What if we instead require
that the continuation result be a Functor?</p>

<pre><code class="haskell">fn :: Functor f =&gt; (a -&gt; f r) -&gt; (s -&gt; f r)
</code></pre>

<p>And while we&rsquo;re at it, it was kind an arbitrary stipulation that the <code>f
r</code> of the continuation&rsquo;s callback be the same as the <code>f r</code> of our
function&rsquo;s result type, so let&rsquo;s relax that:</p>

<pre><code class="haskell">fn :: Functor f =&gt; (a -&gt; f b) -&gt; (s -&gt; f t)
</code></pre>

<p>This relaxation makes sense as long as we know of some function with
type <code>b -&gt; t</code>, because then we could</p>

<ul>
<li>take the <code>s</code>,</li>
<li>apply our <code>s -&gt; a</code> getter to get an <code>a</code>,</li>
<li>throw this to the <code>a -&gt; f b</code> continuation to get an <code>f b</code>, and</li>
<li><code>fmap</code> our <code>b -&gt; t</code> function over this to get an <code>f t</code>.</li>
</ul>


<p>In general, we might not know of some <code>b -&gt; t</code> function. But remember
that we do have our <code>s -&gt; a -&gt; s</code> function! So if we choose <code>b = a</code> and
<code>s = t</code>, then we get:</p>

<pre><code class="haskell">fn :: Functor f =&gt; (a -&gt; f a) -&gt; (s -&gt; f s)
</code></pre>

<p>With a function like this, we can</p>

<ul>
<li>take the <code>s</code>,</li>
<li>apply our <code>s -&gt; a</code> getter to get an <code>a</code>,</li>
<li>throw our <code>a</code> to the <code>a -&gt; f a</code> continuation to get an <code>f a</code>,</li>
<li>partially apply our <code>s -&gt; a -&gt; s</code> setter with the <code>s</code> we were given,

<ul>
<li>(so we have an <code>a -&gt; s</code> now)</li>
</ul>
</li>
<li><code>fmap</code> this <code>a -&gt; s</code> function over the <code>f a</code> to get an <code>f s</code></li>
</ul>


<p>And we&rsquo;ve arrived at the type of <code>Lens'</code>! What really happened here was
we marked the interesting<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> part of our data structure with
a Functor. So if we choose an interesting Functor instance, it&rsquo;ll act on
that point.</p>

<p>What if the Functor we choose is <code>Const a</code>? Well, then it&rsquo;s on us to
provide an <code>a -&gt; f a</code> continuation. Since we&rsquo;ve chosen <code>f = Const a</code> we
have to come up with a function with type <code>a -&gt; Const a a</code>. This is a
special case of the <code>Const</code> constructor:</p>

<pre><code class="haskell">Const :: forall b. a -&gt; Const a b
</code></pre>

<p>So our continuation remembers the <code>a</code> it was given. After the last step,
we&rsquo;ll have a <code>Const a s</code>, which we can call <code>getConst</code> on to give us
the <code>a</code> we stashed. So by choosing <code>Const</code>, our lens acts like a getter!</p>

<p>What if the Functor we choose is <code>Identity</code>? Now we have to provide a
function <code>a -&gt; Identity a</code>. At this point, you probably guessed this
makes our lens a setter. If we&rsquo;re trying to use a setter, then we&rsquo;ll
also have access to some new <code>y :: a</code> that we want to use to slot into
our <code>s</code>. Let&rsquo;s see what happens if we make this our continuation:</p>

<pre><code class="haskell">inj :: a -&gt; Identity a
inj x = Identity y
</code></pre>

<p>The <code>x :: a</code> is the old value of <code>x</code>. By dropping <code>x</code> on the floor and
returning <code>y</code> instead, we&rsquo;ve slotted <code>y</code> into our <code>s</code>. Remember
that above we took the <code>f a</code> and our setter <code>s -&gt; a -&gt; s</code>, partially
applied it to get <code>a -&gt; s</code>, and <code>fmap</code>&rsquo;d this over the <code>f a</code>. Since our
continuation now holds a wrapped up <code>y :: a</code>, we&rsquo;ll reconstruct a new
<code>s</code> using <code>y</code>. Great!</p>

<h2>More Resources</h2>

<p>These are some resources that helped make lenses less intimidating for
me:</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=cefnmjtAolY">Lenses, Folds, and
Traversals</a> (video)

<ul>
<li>by Edward Kmett, the author of the lens library</li>
<li>highly technical, long, exhaustive</li>
</ul>
</li>
<li><a href="https://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-Getter.html">Control.Lens.Getter</a> (hackage)

<ul>
<li>in particular, the first few lines of the intro paragraph</li>
<li>also: <code>(^.)</code> to see where the <code>f</code> becomes <code>Const a</code></li>
</ul>
</li>
<li><code>#haskell</code> on Freenode

<ul>
<li>Special thanks to <code>johnw_</code> and <code>dminuoso</code>!</li>
</ul>
</li>
</ul>


<p>Lenses seem intimidating at first, but in the end they&rsquo;re just a really
cool uses of functions. We use nothing more exotic here than the Functor
type class and a couple of Functor instances, and in return we get such
concise code!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>It&rsquo;s common to think that &ldquo;immutable&rdquo; means &ldquo;copy the entire thing&rdquo; and then change the parts you care about. But if you start with <strong>all data</strong> being immutable, then you only need to allocate new memory for the subcomponents of your data structure that <strong>actually</strong> changed. Everything else can be shared by the old and the new.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In the same way that glass lenses focus light on a point, functional lenses focus a data structure on a point! Isn&rsquo;t it neat how that name works out? It&rsquo;s certainly a cooler name than &ldquo;generalized getter/setter <a href="https://www.youtube.com/watch?v=pD_imYhNoQ4">wombo combo</a>&rdquo; (video, language warning).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABTs in Haskell]]></title>
    <link href="https://blog.jez.io/abts-in-haskell/"/>
    <updated>2017-11-11T22:31:41-08:00</updated>
    <id>https://blog.jez.io/abts-in-haskell</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning and using Haskell on-and-off for the past couple
of years. One of my early complaints was that I couldn&rsquo;t find a good
library for working with variables and binding that used locally
nameless terms. Recently though, I found <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which
checks all my previously unfilled boxes.</p>

<p>Abstract binding trees (or ABTs) are abstract syntax trees (ASTs)
augmented with the ability to capture the binding structure of a
program. ABTs are one of the first topics we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles
of Programming Languages</a> because variables show up in every
interesting feature of a programming language.</p>

<p>I recently wrote at length about the various strategies for dealing with
<a href="/variables-and-binding/">variables and binding</a> and their implementations. While it&rsquo;s a good
exercise<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to implement ABTs from scratch, in most cases I&rsquo;d
rather just use a library. In school we used <a href="https://github.com/robsimmons/abbot"><code>abbot</code></a>, which is an ABT
library for Standard ML. For tinkering with Haskell, I recently found
<a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which provides a similar API.</p>

<p>I gave it a test drive while learning how to implement type inference
for the simply-typed lambda calculus (STLC) and was rather pleased. The
source code for my STLC inference program is <a href="https://github.com/jez/stlc-infer">on GitHub</a> if
you&rsquo;re looking for an example of <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a> in action.</p>

<p>To pluck a few snippets out, here&rsquo;s the definition of STLC terms:</p>

<pre><code class="haskell">data Term
  = Tvar Tvar
  | Tlam (Bind Tvar Term)
  | Tapp Term Term
  | Tlet Term (Bind Tvar Term)
  | Tz
  | Ts Term
  | Tifz Term Term (Bind Tvar Term)
  | Tbool Bool
  | Tif Term Term Term
  deriving (Show, Generic, Typeable)
</code></pre>

<p><code>Bind</code> is the abstract type for locally nameless terms that bind a
variable. It&rsquo;s cool in Haskell (compared to SML) because the compiler
can automatically derive the locally nameless representation from this
data type definition (with help from the <code>unbound-generics</code> library).</p>

<p>Here&rsquo;s what it looks like in use:</p>

<pre><code class="haskell">-- (This is a snippet from the type inference code)
constraintsWithCon ctx (Tlam bnd) = do
  -- 'out' the ABT to get a fresh variable
  -- (x used to be "locally nameless", but now has a globally unique name)
  (x, e) &lt;- unbind bnd
  -- Generate fresh type variable to put into the context
  t1 &lt;- Cvar &lt;$&gt; fresh (string2name "t1_")
  let ctx' = Map.insert x t1 ctx
  t2 &lt;- constraintsWithCon ctx' e
  return $ Carrow t1 t2
</code></pre>

<p>Apart from <code>out</code> being called <code>unbind</code> and <code>into</code> being called <code>bind</code>,
the API is pretty similar. Also, unlike <code>abbot</code>, which required a
standalone build step to generate SML code, <code>unbound-generics</code> uses the
Haskell&rsquo;s <code>derive Generic</code> to bake the code generation for capture
avoiding substitution and alpha equivalence right into the compiler. All
in all, <code>unbound-generics</code> is really pleasant to use!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In fact, it&rsquo;s hw1 for 15-312! If you&rsquo;re curious, check out the <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/hws/assn1.pdf">handout</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Development with Neovim]]></title>
    <link href="https://blog.jez.io/haskell-development-with-neovim/"/>
    <updated>2017-07-16T13:45:31-05:00</updated>
    <id>https://blog.jez.io/haskell-development-with-neovim</id>
    <content type="html"><![CDATA[<p>Configuring an editor for a new language is a double-edged sword: it&rsquo;s intensely
satisfying when done, but takes time away from diving into the language itself!
After using Haskell for a little over a year, I&rsquo;ve settled on a high-quality set
of editor plugins. They&rsquo;re simple, powerful, and all play nicely together.</p>

<!-- more -->


<h2>Requirements</h2>

<p>I use <a href="https://www.haskellstack.org/">Haskell Stack</a> exclusively. Stack&rsquo;s goal is reproducible builds,
which means that in general, things Just Work.</p>

<p>I also use <a href="https://github.com/neovim/neovim">Neovim</a>, rather than normal Vim. Usually, my justification
is ideological rather than technical. However, for Haskell my setup <strong>requires</strong>
Neovim. Fear not! Neovim is feature-packed and also very stable. I love Neovim,
and I&rsquo;ll be writing more about why in a future post.</p>

<p>By the way, new to Vim plugins? I happen to have <a href="https://github.com/jez/vim-as-an-ide">just the post for
you</a>!</p>

<!-- TODO(jez): Update with link to Neovim post -->


<h2>Overview</h2>

<p>We&rsquo;re going to move in order of increasing complexity. That said, even the most
&ldquo;complex&rdquo; plugin here is actually quite painless to set up. By the end, we&rsquo;ll
have a complete development experience! Coming up:</p>

<ul>
<li>syntax highlighting &amp; indentation (<strong><a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a></strong>)</li>
<li>auto-formatting &amp; style (<strong><a href="https://github.com/commercialhaskell/hindent">hindent</a>, <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a></strong>)</li>
<li>quickfix and sign column support (<strong>using <a href="https://github.com/w0rp/ale">ale</a></strong>) for:

<ul>
<li>linter style suggestions (<strong>hlint</strong>)</li>
<li>compiler errors and warnings (<strong>ghc-mod</strong>)</li>
</ul>
</li>
<li>Type inspection, REPL integration, and more! (<strong><a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></strong>)</li>
</ul>


<p>To keep things concise, I&rsquo;ve moved all the relevant configuration to the end of
the post. For now, let&rsquo;s start at the top.</p>

<!-- TODO(jez) Demonstrate everything with an asciicast -->


<h2>Syntax Highlighting &amp; Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
</ul>


<p>Vim&rsquo;s default Haskell filetype plugin is pretty lack luster. Everything is blue,
except for strings which are colored like comments, and keywords which are
colored like constants. Indentation is wonky in some cases, and isn&rsquo;t
configurable.</p>

<p>This plugin corrects all that. It&rsquo;s the filetype plugin for Haskell that
<strong>should</strong> ship with Vim.</p>

<p>Not only does it come with saner defaults, it also comes with more config
options, especially for indentation. This is important because it lets me
tweak the automatic indentation to my own personal style.</p>

<p>(Remember: all the config is at the end of the post.)</p>

<h2>Auto-formatting and Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/alx741/vim-hindent">vim-hindent</a></li>
<li><strong>Tool</strong>: <code>stack install hindent</code></li>
<li><strong>Tool</strong>: <code>stack install stylish-haskell</code></li>
</ul>


<p>For small projects, I have an idea of what style I like best. However, for
larger projects it&rsquo;s unfair to ask contributors that they learn the ins and outs
of my style. Situations like these call for automated solutions.</p>

<p><code>go fmt</code> famously solved this problem for Golang by building the formatting tool
into the compiler. For Haskell, there&rsquo;s <a href="https://github.com/commercialhaskell/hindent">hindent</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. <code>hindent</code> can be
installed through Stack, and <code>vim-hindent</code> is a Vim plugin that shims it.</p>

<p>But I said I&rsquo;m partial to my own style in personal projects. There&rsquo;s another
Haskell formatter that&rsquo;s much less invasive: <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>. It basically
only reformats <code>import</code>s, <code>case</code> branches, and record fields, aligning them
vertically. And in fact, it&rsquo;s possible to use this alongside <code>hindent</code>.</p>

<p>With these three tools, I can pick the right tool for the job:</p>

<ul>
<li><strong>Hand saw</strong>: let <code>haskell-vim</code> config control the indentation</li>
<li><strong>Table saw</strong>: run <code>stylish-haskell</code> only</li>
<li><strong>Chainsaw</strong>: run <code>hindent</code> only</li>
<li><strong>Chainsaw, then sand paper</strong>: run <code>hindent</code>, then <code>stylish-haskell</code></li>
</ul>


<p>Getting them to play together requires a bit of config, so I&rsquo;ve included mine at
the end of the post.</p>

<h2>Quickfix &amp; Sign Columns</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/w0rp/ale">ale</a></li>
<li><strong>Tool</strong>: <code>stack install hlint</code></li>
<li><strong>Tool</strong>: <code>stack build ghc-mod</code>

<ul>
<li>N.B.: This is <em>build</em> not <em>install</em> here<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</li>
</ul>
</li>
</ul>


<p>This step requires <em>either</em> Neovim or Vim 8; ALE stands for &ldquo;Asynchronous Lint
Engine,&rdquo; so it&rsquo;s using the new asynchronous job control features of these two
editors. It&rsquo;s like an asynchronous Syntastic<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>ALE ships with a number of Haskell integrations by default. For example, it can
show errors if only Stack is installed. I prefer enabling two of ALE&rsquo;s Haskell
integrations: <code>hlint</code> and <code>ghc-mod</code>.</p>

<ul>
<li><code>hlint</code> is a linter for Haskell. It warns me when I try to do silly things
like <code>if x then True else False</code>.</li>
<li><code>ghc-mod</code> is a tool that can check files for compiler errors.</li>
</ul>


<p>The beauty of ALE is that it works almost entirely out of the box. The only real
setup is to tell ALE to use only these two integrations explicitly. I&rsquo;ve
included the one-liner to do this in the config at the bottom.</p>

<h2>Intero: The Pi√®ce de R√©sistance</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></li>
</ul>


<p>Intero is a complete development program for Haskell. It started as an Emacs
package, but has been ported almost entirely to Neovim. Probably the best way to
introduce it is with this asciicast:</p>

<p align="center">
  <a href="https://asciinema.org/a/128416">
    <img
      width="700px"
      alt="Intero for Neovim asciicast"
      src="https://asciinema.org/a/128416.png">
  </a>
</p>


<p>Intero is designed for stack, sets itself up automatically, has point-and-click
type information, and lets me jump to identifier definitions. On top of it all,
it uses Neovim to communicate back and forth with a terminal buffer so that I
get a GHCi buffer <strong>right inside Neovim</strong>. For Emacs users, this is nothing new
I&rsquo;m sure. But having the REPL in my editor continues to blow my mind üòÆ.</p>

<p>Developing with the REPL in mind helps me write better code. Only top-level
bindings are exposed in the REPL, so I write more small, testable functions.
See here for more reasons <a href="http://chrisdone.com/posts/haskell-repl">why the REPL is awesome</a>.</p>

<p>On top of providing access to the REPL, Intero provides about a dozen
convenience commands that shell out to the REPL backend asynchronously. Being
able to reload my code in the REPL&mdash;from Vim, with a single keystroke!&mdash;is a
huge boon when developing.</p>

<p>Intero takes a little getting used to, so be sure to read the docs for some
sample workflows. Intero also sets up no mappings by default, so I&rsquo;ve included
my settings below.</p>

<h2>The Eagerly-Awaited Config</h2>

<p>And without further ado&hellip;</p>

<pre><code class="vim">" ----- neovimhaskell/haskell-vim -----

" Align 'then' two spaces after 'if'
let g:haskell_indent_if = 2
" Indent 'where' block two spaces under previous body
let g:haskell_indent_before_where = 2
" Allow a second case indent style (see haskell-vim README)
let g:haskell_indent_case_alternative = 1
" Only next under 'let' if there's an equals sign
let g:haskell_indent_let_no_in = 0

" ----- hindent &amp; stylish-haskell -----

" Indenting on save is too aggressive for me
let g:hindent_on_save = 0

" Helper function, called below with mappings
function! HaskellFormat(which) abort
  if a:which ==# 'hindent' || a:which ==# 'both'
    :Hindent
  endif
  if a:which ==# 'stylish' || a:which ==# 'both'
    silent! exe 'undojoin'
    silent! exe 'keepjumps %!stylish-haskell'
  endif
endfunction

" Key bindings
augroup haskellStylish
  au!
  " Just hindent
  au FileType haskell nnoremap &lt;leader&gt;hi :Hindent&lt;CR&gt;
  " Just stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hs :call HaskellFormat('stylish')&lt;CR&gt;
  " First hindent, then stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hf :call HaskellFormat('both')&lt;CR&gt;
augroup END

" ----- w0rp/ale -----

let g:ale_linters.haskell = ['stack-ghc-mod', 'hlint']

" ----- parsonsmatt/intero-neovim -----

" Prefer starting Intero manually (faster startup times)
let g:intero_start_immediately = 0
" Use ALE (works even when not using Intero)
let g:intero_use_neomake = 0

augroup interoMaps
  au!

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;io :InteroOpen&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iov :InteroOpen&lt;CR&gt;&lt;C-W&gt;H
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ih :InteroHide&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;is :InteroStart&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ik :InteroKill&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;wr :w \| :InteroReload&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;il :InteroLoadCurrentModule&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;if :InteroLoadCurrentFile&lt;CR&gt;

  au FileType haskell map &lt;leader&gt;t &lt;Plug&gt;InteroGenericType
  au FileType haskell map &lt;leader&gt;T &lt;Plug&gt;InteroType
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;it :InteroTypeInsert&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;jd :InteroGoToDef&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iu :InteroUses&lt;CR&gt;
  au FileType haskell nnoremap &lt;leader&gt;ist :InteroSetTargets&lt;SPACE&gt;
augroup END
</code></pre>

<h2>Wrap Up</h2>

<p>With these tools, I feel empowered (rather than hindered) when I sit down to
work with Haskell.</p>

<ul>
<li>The entire setup uses Stack, so things Just Work.

<ul>
<li>As a consequence, everything works with the implicit global Stack project!</li>
</ul>
</li>
<li>It scales up in power:

<ul>
<li>From simple syntax highlighting and manual indentation&hellip;</li>
<li>to an indentation chainsaw and a <strong>REPL embeded in the editor</strong>!</li>
</ul>
</li>
<li>I can take full advantage of all my tools working together, leading to cleaner
code and fewer frustrations.</li>
</ul>


<p>Now that I&rsquo;m finally at a point where I can stop fretting about my Haskell
setup, I&rsquo;ll have more time to explore the language and write about my
experience.</p>

<p>Haskell-the-language isn&rsquo;t quite on the same level as SML-the-language, but it&rsquo;s
far and above when comparing by tooling support. I&rsquo;m looking forward to taking
advantage of that!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>While listed under &ldquo;neovimhaskell&rdquo; on GitHub, this plugin works with normal Vim, too.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Chris Done explains the appeal of solving style issues with tooling for Haskell well. The moral of the story is that hindent version 5 ships with only the most popular style formatter in an effort to arrive at a singular Haskell style: <a href="http://chrisdone.com/posts/hindent-5">http://chrisdone.com/posts/hindent-5</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>We want to install <code>ghc-mod</code> once in every project. It can be done globally, but it might get out of sync with the current project.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Some people are familiar with Neomake for this task. However, Neomake is much more minimal than ALE. Neomake basically only builds, whereas ALE is more configurable and hackable.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
