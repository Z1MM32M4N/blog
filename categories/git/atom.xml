<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/git/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2020-01-05T04:04:29-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code Review from the Command Line]]></title>
    <link href="https://blog.jez.io/cli-code-review/"/>
    <updated>2018-01-13T13:14:24-08:00</updated>
    <id>https://blog.jez.io/cli-code-review</id>
    <content type="html"><![CDATA[<p>I do the bulk of my code reviews from the command line, especially when
reviewing larger changes. I&rsquo;ve built up a number of tools and config
settings that help me dig into the nuances of the code I&rsquo;m reviewing, so
that I can understand it better than if I were just browsing online.</p>

<!-- more -->


<p>In particular, I&rsquo;ll walk through how I&hellip;</p>

<ul>
<li>check out the code in the first place,</li>
<li>get a feel for what changed,</li>
<li>visualize the relationships between the files that changed,</li>
<li>bring up the code diffs in Vim,</li>
<li>leverage the unique power of the editor and the terminal.</li>
</ul>


<p>But first, let&rsquo;s talk briefly about the point of code review in the
first place.</p>

<h2>Code review philosophy</h2>

<p>When I ask that other people review my code, it&rsquo;s an opportunity for me
to teach them about the change I&rsquo;ve just made. When I review someone
else&rsquo;s code, it&rsquo;s to learn something from them. Some other benefits of
code review include:</p>

<ul>
<li>Team awareness (to keep a pulse on what else is going on within your
team).</li>
<li>Finding alternative solutions (maybe there&rsquo;s a small change that lets
us kill two birds with one stone).</li>
</ul>


<p>If this is different from how you think about code review, <a href="https://www.youtube.com/watch?v=PJjmw9TRB7s">check out
this talk</a>. Code review is a powerful tool for
learning and growing a team.</p>

<p>With that out of the way, let&rsquo;s dive into the tools I use to maximize
benefit I get from code review.</p>

<h2>Checking out the code</h2>

<p>The first step to reviewing code in the terminal is to check out the
code in the first place. One option is to simply to <code>git pull</code> and then
<code>git checkout &lt;branch&gt;</code>. But if you happen to be using GitHub, we can
get this down to just one command:</p>

<pre><code>hub pr checkout &lt;pr-number&gt;
</code></pre>

<p>It works using <a href="https://github.com/github/hub">hub</a>, which is a tool that exposes various features of
GitHub from the command line. If the pull request is from someone else&rsquo;s
fork, <code>hub</code> is even smart enough to add their fork as a remote and fetch
it.</p>

<h2>At first glance</h2>

<p>With the branch checked out locally, usually my next step is to get a
feel for what changed. For this, I&rsquo;ve written a git alias that shows:</p>

<ul>
<li>which files changed</li>
<li>how many lines changed in each file (additions and deletions)</li>
<li>how many lines changed overall</li>
</ul>


<p><a class="image-link" href="/images/git-stat.png"><img class="fullwidth" src="/images/git-stat.png" title="git stat" ></a></p>

<p>Here&rsquo;s the definition of <code>git stat</code> from my <code>~/.gitconfig</code>:</p>

<pre><code class="bash">[alias]
    # list files which have changed since REVIEW_BASE
    # (REVIEW_BASE defaults to 'master' in my zshrc)
    files = !git diff --name-only $(git merge-base HEAD \"$REVIEW_BASE\")

    # Same as above, but with a diff stat instead of just names
    # (better for interactive use)
    stat = !git diff --stat $(git merge-base HEAD \"$REVIEW_BASE\")
</code></pre>

<p>Under the hood, it just works using <code>git diff</code>, <code>git merge-base</code>, and a
personal environment variable <code>REVIEW_BASE</code>.</p>

<p><code>REVIEW_BASE</code> lets us choose which branch to review relative to. Most of
the time, <code>REVIEW_BASE</code> is <code>master</code>, but this isn&rsquo;t always the case! Some
repos branch off of <code>gh-pages</code>. Sometimes I like to review the most
recent commit as if it were its own branch.</p>

<p>To review the code relative so some other base, set <code>REVIEW_BASE</code> before
running <code>git stat</code>:</p>

<pre><code class="bash"># Review between 'gh-pages' and the current branch
REVIEW_BASE=gh-pages git stat

# Review changes made by the last commit of this branch:
REVIEW_BASE=HEAD^ git stat
</code></pre>

<p>I have <code>export REVIEW_BASE=master</code> in my <code>~/.bashrc</code>, because most
projects branch off of <code>master</code>.</p>

<p>Nothing too crazy yet&mdash;GitHub can already do everything we&rsquo;ve seen so
far. Let&rsquo;s start to up the ante.</p>

<h2>Visualizing file change frequency</h2>

<p>I&rsquo;ve written a short script that shows me a visualization of how
frequently the files involved in this branch change over time:</p>

<p><a class="image-link" href="/images/git-heatmap.png"><img class="fullwidth" src="/images/git-heatmap.png" title="git heatmap" ></a></p>

<p>This command identifies two main things:</p>

<ul>
<li><p><strong>Files with lots of changes</strong>.</p>

<p>Files that have changed a lot in the past are likely to change in the
future. I review these files with an eye towards what the <em>next</em>
change will bring.</p>

<p><em>&ldquo;Is this change robust enough to still be useful in the future?
Will we throw this out soon after merging it?&rdquo;</em></p></li>
<li><p><strong>Files with few changes</strong>.</p>

<p>Files that aren&rsquo;t changed frequently are more likely to be brittle.
Alternatively, it&rsquo;s often the case that infrequently changed files
stay unchanged because the change is better made elsewhere.</p>

<p><em>&ldquo;Does this change challenge an implicit assumption so that some other
part of the code was relying on? Is there a better place for this
change?&rdquo;</em></p></li>
</ul>


<p>Those two commands (<code>git stat</code> and <code>git heatmap</code>) are how I kick off my
code review: getting a birds-eye view of the change and some historical
context for what I&rsquo;m dealing with. Next, I drill down into the
relationships between the files that changed.</p>

<h2>Visualizing relationships between files</h2>

<p>At work I review JavaScript files, so I&rsquo;ve built out this next bit of
tooling specifically for JavaScript.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It helps to understand
which files import others, so I have a command that computes the
dependency graph of the files changed on this branch:</p>

<p><a class="image-link" href="/images/git-depgraph.png"><img class="fullwidth" src="/images/git-depgraph.png" title="git depgraph" ></a></p>

<p>This is where we start to see some distinct advantages over what GitHub
provides. As you see above, the <code>git depgraph</code> alias calculates the
dependency graph for files changed by this branch. Why is this useful?</p>

<ul>
<li><p>Maybe we want to start reviewing from <code>Provider.js</code>, since it doesn&rsquo;t
depend on any other files that have changed.</p></li>
<li><p>Maybe we want to work the other way: start with <code>Elements.js</code> so we
know the motivation for why <code>Provider.js</code> had to changed in the first
place.</p></li>
</ul>


<p>In either case, we can see the structure of the change. Three files
depend on <code>Elements.js</code>, so it&rsquo;s serving the needs of many modules.
<code>Element.js</code> only has one dependency, etc. Each branch&rsquo;s dependency
graph shows different information; it can be surprising what turns up.</p>

<p>I have the <code>git depgraph</code> alias defined like this:</p>

<pre><code class="bash">[alias]
    depgraph = !git madge image --webpack-config webpack.config.js --basedir . --style solarized-dark src
</code></pre>

<p>Some notes about this definition:</p>

<ul>
<li><p>It depends on the <code>git-madge</code> command, which you can <a href="https://github.com/jez/git-madge">download
and install here</a>.</p></li>
<li><p>It&rsquo;s using <em>this project&rsquo;s</em> <code>webpack.config.js</code> file, so I&rsquo;ve made
this alias local to the repo, rather than available globally.</p></li>
<li><p>It dumps the image to stdout. Above, we used iTerm2&rsquo;s <a href="https://iterm2.com/documentation-images.html">imgcat</a>
program to pipe stdin and dump a raster image to the terminal.</p>

<p>If you don&rsquo;t use iTerm2 or don&rsquo;t want to install <code>imgcat</code>, you can
pipe it to Preview using open<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (<code>open -f -a Preview</code>) or just
redirect the PNG to a file.</p></li>
</ul>


<p>The <code>git depgraph</code> alias is a game changer. It makes it easier to get spun
up in new code bases, helps make sense of large changes, and just looks
plain cool. But at the end of the day, we came here to review some code,
so let&rsquo;s take a look at how we can actually view the diffs of the files
that changed.</p>

<h2>Reviewing the diffs</h2>

<p>To review the diffs, the simplest option is to just run <code>git diff
master..HEAD</code>. This has a bunch of downsides:</p>

<ul>
<li><p>No syntax highlighting (everything is either green or red).</p></li>
<li><p>No surrounding context (for example, GitHub lets you click to expand
lines above or below a diff hunk).</p></li>
<li><p>The diff is &ldquo;unified,&rdquo; instead of split into two columns.</p></li>
<li><p>No way to exclude a specific file (the 300 line diff to your
<code>yarn.lock</code> file is sometimes nice to hide).</p></li>
</ul>


<p>My solution to all of these problems is to view the diffs in Vim, with
the help of two Vim plugins and two git aliases. Before we get to
that, here&rsquo;s a screenshot:</p>

<p><a class="image-link" href="/images/git-review.png"><img class="fullwidth" src="/images/git-review.png" title="git review" ></a></p>

<p>Looks pretty similar to GitHub&rsquo;s interface, with the added bonus that
it&rsquo;s using my favorite colorscheme! The Vim plugins featured are:</p>

<ul>
<li><a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> for showing the side-by-side diff (<code>:Gdiff</code>).</li>
<li><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> for showing the <code>+/-</code> signs.</li>
<li><a href="https://github.com/jez/vim-colors-solarized">jez/vim-colors-solarized</a> for tweaking the diff highlight
colors.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>And to orchestrate the whole thing, I&rsquo;ve set up these two aliases:</p>

<pre><code class="bash">[alias]
  # NOTE: These aliases depend on the `git files` alias from
  # a few sections ago!

    # Open all files changed since REVIEW_BASE in Vim tabs
    # Then, run fugitive's :Gdiff in each tab, and finally
    # tell vim-gitgutter to show +/- for changes since REVIEW_BASE
    review = !vim -p $(git files) +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"

    # Same as the above, except specify names of files as arguments,
    # instead of opening all files:
    # git reviewone foo.js bar.js
    reviewone = !vim -p +\"tabdo Gdiff $REVIEW_BASE\" +\"let g:gitgutter_diff_base = '$REVIEW_BASE'\"
</code></pre>

<p>Here&rsquo;s how they work:</p>

<ul>
<li><p><code>git review</code> opens each file changed by this branch as a tab in Vim.
Then <code>:Gdiff</code> from vim-fugitive shows the diff in each tab.</p></li>
<li><p><code>git reviewone</code> is like <code>git review</code>, but you specify which
files to open (in case you only want to diff a few).</p></li>
</ul>


<p>Like with the <code>git stat</code> alias, these aliases respect the <code>REVIEW_BASE</code>
environment variable I&rsquo;ve set up in my <code>~/.bashrc</code>. (Scroll back up for
a refresher.) For example, to review all files relative to <code>master</code>:</p>

<pre><code class="bash">REVIEW_BASE=master git review
</code></pre>

<p>At this point, you might think that all we&rsquo;ve done is re-create the
GitHub code review experience in Vim. But actually what we&rsquo;ve done is so
much more powerful.</p>

<h2>Interactive Code Review</h2>

<p>When reviewing on GitHub, the code is completely static&mdash;you can&rsquo;t
change it. Also, because the code is coming from GitHub&rsquo;s servers,
it&rsquo;s laggy when you click around to view related files. By switching our
code review to the terminal, we can now edit files, jump to other files,
and run arbitrary commands at no cost.</p>

<p>It might not be obvious how huge of a win this is, so let&rsquo;s see some
examples. Take this screenshot of the <code>requireElement</code> function. It
moved from <em>above</em> the <code>findElement</code> function to <em>below</em> it (probably
because the former calls the latter):</p>

<p><a class="image-link" href="/images/requireElement01.png"><img class="fullwidth" src="/images/requireElement01.png" title="diff" ></a></p>

<p>But is the location of the <code>requireElement</code> function the only thing
that&rsquo;s changed? By editing the file to move the function back to its
original location, vim-fugitive will automatically recompute the diff.
And in fact, we can see that the <em>type of the argument</em> has changed too,
from <code>string</code> to <code>ElementType</code>:</p>

<p><a class="image-link" href="/images/requireElement02.png"><img class="fullwidth" src="/images/requireElement02.png" title="diff" ></a></p>

<p>If we had been viewing this on GitHub, we might have taken for granted
that the function didn&rsquo;t change. But since we&rsquo;re in our editor, we can
interactively play around with our code and discover things we might
have missed otherwise. The advantages of interactive code review go well
beyond this example:</p>

<ul>
<li><p>In a Flow project, we can ask for the type of a variable.</p></li>
<li><p>In a test file, we can change the test and see if it still passes or
if it now fails.</p></li>
<li><p>We can <code>grep</code> the project for all uses of a function (including files
<em>not</em> changed by this branch).</p></li>
<li><p>We can open up related files for cross-referencing.</p></li>
<li><p>We can run the code in a debugger and see how it behaves.</p></li>
</ul>


<p>By having the full power of our editor, we can literally retrace the
steps that the author went through to create the pull request. If our
goal is to understand and learn from code review, there&rsquo;s no better way
than walking in the author&rsquo;s shoes.</p>

<h2>Recap</h2>

<p>To recap, here&rsquo;s a list of the tools I use to review code at the command
line:</p>

<ul>
<li><code>hub pr checkout</code></li>
<li><code>git stat</code> to list files that have changed</li>
<li><code>git heatmap</code> to show how frequently these files change</li>
<li><code>git depgraph</code> to show a graph of which files depend on which</li>
<li><code>git review</code> to open diffs of all the files in Vim</li>
<li><code>git reviewone</code> to open diffs for a specific handful of files</li>
</ul>


<p>If you&rsquo;re having trouble incorporating any of these into your workflow,
feel free to reach out and let me know! I&rsquo;m happy to help.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The techniques here apply to any language that you can statically analyze. In particular, I have a rough prototype of everything JavaScript-specific you see here that works with Standard ML instead. If you can find me the dependency information for your favorite language, I&rsquo;d be happy to help you turn it into a visualization.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The <code>open</code> command is macOS-specific. On Linux, you might want to look at the <code>display</code> command from ImageMagick.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>I&rsquo;ve patched the default Solarized colors for Vim so that lines retain their syntax highlighting in the diff mode, while the backgrounds are highlighted. You can see how this works in this commit: <a href="https://github.com/jez/vim-colors-solarized/commit/bca72cc">https://github.com/jez/vim-colors-solarized/commit/bca72cc</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Noteworthy Dotfile Hacks]]></title>
    <link href="https://blog.jez.io/noteworthy-dotfile-hacks/"/>
    <updated>2015-03-10T00:22:33-05:00</updated>
    <id>https://blog.jez.io/noteworthy-dotfile-hacks</id>
    <content type="html"><![CDATA[<p>I have hundreds of files and folders in my dotfiles repo, and nearly 1000
commits&mdash;there are quite a few hidden gems buried in there that generally don&rsquo;t
get to see the light of day. Rather than wander aimlessly through them, let me
give you the guided tour.</p>

<!-- more -->


<p>I often tell people &ldquo;oh, and you can also go check out my dotfiles repository
for more cool configurations&rdquo; when I&rsquo;m giving out dotfiles advice. If someone
gave me this advice, I know I wouldn&rsquo;t follow up, even if I had the utmost awe
for the recommender. Drudging through config files isn&rsquo;t all that fun, even
though they can do fun things. Why not get rid of the drudgery?</p>

<p>This post is designed to bring the coolest parts of my dotfiles to the top. It&rsquo;s
organized by topic, so feel free to skip around.</p>

<p><strong>Note</strong>: throughout this post, I&rsquo;ll be linking to my dotfiles <em>at a specific
commit</em> on GitHub. While this solves the problem of line-level links breaking on
updates, it means that you&rsquo;ll almost certainly be looking at out-dated code.
Make sure to check out the corresponding file on the <code>master</code> branch for the
most up-to-date version.</p>

<p>Also, I <a href="/2015/03/09/getting-started-with-rcm/">just wrote</a> about one of my biggest dotfile hacks: using rcm
to keep my dotfiles in sync across machines. Be sure to give it a read if you&rsquo;re
running into that problem.</p>

<h2><code>tmux</code></h2>

<p>I have a lot of cool stuff going on in my <code>.tmux.conf</code></p>

<ul>
<li>I <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L1-L4">bind the prefix key to <code>C-f</code></a>, something which I haven&rsquo;t seen
many people do.  I&rsquo;ve never had a problem with it conflicting with commonly
used shortcuts, and it&rsquo;s incredibly easy to press (compared with the common
options of <code>C-a</code> and <code>C-b</code>)</li>
<li>I integrate with two Vim plugins:

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L18-L27">vim-tmux-navigator</a>, which lets you jump between vim
splits and tmux splits as if they were the same thing</li>
<li><a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/tmux.conf#L48-L49">tmuxline</a>, which makes my tmux status bar look just like Vim with
vim-airline (it even pulls down the colors from your Vim configuration!).</li>
</ul>
</li>
</ul>


<h2><code>dircolors</code></h2>

<p>I use the GNU <code>dircolors</code> command to change the colors output by the <code>ls</code>
program. After running <code>brew install coreutils</code> on OS X, I&rsquo;m able to see the
colors thanks to <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/dircolors">this file</a> and <a href="https://github.com/jez/dotfiles/blob/0ca7dfb042e8d0e6790e7142487812517b5a4209/host-Jacobs-MacBook-Air/util/host.sh#L19-L21">this snippet</a> in my zshrc.</p>

<p><a class="image-link" href="href="https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png">https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png</a>&#8221;><img class="<a" src="href="https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png">https://raw.githubusercontent.com/huyz/dircolors-solarized/master/img/screen-dircolors-in-iTerm2-solarized_dark.png</a>&#8221;></a></p>

<p>(image from the <a href="https://github.com/seebi/dircolors-solarized">dircolors-solarized</a> repository on GitHub)</p>

<h2><code>gitconfig</code></h2>

<p>I talked about this <a href="/2015/01/16/mastering-git-log-for-collaboration/">in a previous post</a>, but I have some <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/gitconfig#L20-L24">special
settings</a> in my global gitconfig for adding colored decoration to git
log commands. Here&rsquo;s a screenshot from that post:</p>

<p><a class="image-link" href="/images/glla-tartanhacks.png"><img src="/images/glla-tartanhacks.png"></a></p>

<h2><code>aklog cs.cmu.edu</code></h2>

<p>For my friends at CMU, I have <code>aklog cs.cmu.edu</code> in <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-andrew/util/host.zshenv#L1">my ~/.zshenv</a>,
which gets run even when you log in interactively (like what happens when you
<code>scp</code> something), so that I can copy files from my local machine to the SCS AFS
space, which is useful for doing things like making handins. Note that the file
linked to above is a host-specific file that only &ldquo;exists&rdquo; for me on Andrew
machines. You can read more about my setup <a href="/2015/03/09/getting-started-with-rcm/">in my
previous post</a>.</p>

<h2>zsh-syntax-highlighting</h2>

<p>I use a <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/misc.zsh#L79-L80">zsh plugin</a> to syntax highlight my commands as I type them
on the command line, similar to how the fish shell does it. It does various
things, like coloring the command red or green based on whether it exists,
underlines filenames that exist, highlights filenames that might be misspelled
in yellow, highlights built-ins like <code>if</code> and <code>for</code> in orange, etc.</p>

<p>Here are some examples from my setup:</p>

<p><a class="image-link" href="/images/zsh-syntax-highlighting-for-loop.png"><img src="/images/zsh-syntax-highlighting-for-loop.png"></a></p>

<p><a class="image-link" href="/images/zsh-syntax-highlighting.png"><img src="/images/zsh-syntax-highlighting.png"></a></p>

<h2>Automatic Dotfile Updates</h2>

<p>I wrote a pretty robust script that reminds me to update my dotfiles and my
system regularly. All it does is remind me to check for system updates once
every 24 hours, but it works so well that I had updated my system <code>bash</code> version
before I even read about Shell Shock!</p>

<p>The relevant links are <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/auto-update.sh">here</a> for the core script that I <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/zshrc#L44-L45">source in
my zshrc</a>, and then the following host specific links:</p>

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/util/host.sh#L69-L86">here</a> for my MacBook</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-ghost.zimmerman.io/util/host.sh#L24-L31">here</a> for my Ubuntu VPS</li>
</ul>


<h2>Shell aliases</h2>

<p>I&rsquo;d like to think that my whole <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh"><code>aliases.sh</code></a> file is golden, but if
you&rsquo;re looking for some specific things I like about it, check out my <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh#L75-L86"><code>git log</code></a>
aliases, which I wrote about <a href="/2015/01/16/mastering-git-log-for-collaboration/">here</a>, and my <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/util/aliases.sh#L44-L45"><code>chromemem</code></a> alias, which I wrote about <a href="/2014/12/29/google-chrome-a-memory-hog/">here</a>.</p>

<h2>Ruby Virtualenvs</h2>

<p>I wrote about how I use <a href="/2014/12/22/ruby-virtualenvs/">Python Virtualenvs to sandbox Ruby
gems</a>, a post in which I dropped some snippets that you can
use to configure virtualenvwrapper to work with Ruby projects. I actually went
ahead and <a href="https://github.com/jez/dotfiles/tree/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/virtualenvs">fed those files right into rcm</a>, so they&rsquo;ll always be available if I
ever get a new laptop.</p>

<h2><code>ssh</code></h2>

<p>My username on every machine I ssh to for school is <code>jezimmer</code>, but there are
countless servers I can ssh into (7 for <code>unix.andrew.cmu.edu</code>, 99+ for
<code>ghc*.ghc.andrew.cmu.edu</code>, 10 for 15-213, the list goes on). <a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/host-Jacobs-MacBook-Air/ssh/config#L7-L19">These
lines</a> enable me to ssh to any of those machines with just a
hostname, and the username is assumed to be <code>jezimmer</code>.</p>

<h2>iTerm2</h2>

<p>There&rsquo;s not much to show for this one, but in Preferences > General of iTerm2,
you can opt to load your iTerm2 preferences from a specific location. I&rsquo;ve set
this to <code>/Users/jake/.dotfiles</code>, which means that my iTerm2 settings are always
written to my <code>.dotfiles/</code> directory. If I ever make changes to iTerm2, they get
propagated as changes that Git picks up on and which I subsequently check into
Git history.</p>

<h2>Vim</h2>

<p>I&rsquo;m in love with my Vim setup. If you&rsquo;re looking for help getting started
configuring Vim, you should checkout the <a href="https://github.com/jez/vim-as-an-ide">Vim plugins workshop I put
together</a>, which gets you started with a &ldquo;fully-configured&rdquo; Vim
setup. Once you think you&rsquo;ve &ldquo;mastered&rdquo; that and you&rsquo;re ready for more, here are
a list of things I&rsquo;m proud of in my <code>.vimrc</code>:</p>

<ul>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L65-L67"><code>set breakindent</code></a> A feature new in Vim 7.4, this allows you to
align wrapped text at the same indentation level as the preceding text.</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L100-L106">these mappings</a>, which let me move around (move up and down in
particular) in long lines just as if they were short.</li>
<li><a href="https://github.com/jez/dotfiles/blob/eba0202443de6bcc171dbe6bc133fa9fe02357f7/vimrc#L90-L91">this mapping</a>, which lets me open Vim help pages in new tabs</li>
</ul>


<h2>Other</h2>

<p>I&rsquo;ve only highlighted a fraction of my configuration files, but I think I&rsquo;ve
managed to capture a good portion of them. If you thought that one of these
snippets was useful, are having trouble getting something to work, or have
something interesting to share, leave a comment below!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New GitHub Username]]></title>
    <link href="https://blog.jez.io/2015/02/03/new-github-username/"/>
    <updated>2015-02-03T04:01:04-05:00</updated>
    <id>https://blog.jez.io/2015/02/03/new-github-username</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve changed my GitHub username from Z1MM32M4N to jez (hopefully it&rsquo;ll be a
little easier to type now!). Make sure you update any remote URLs for repos of
mine that you&rsquo;ve cloned.</p>

<!-- more -->


<h2>Updating your Git remotes</h2>

<p>If you&rsquo;ve cloned one of my repositories, you can update it&rsquo;s URL by running</p>

<pre><code class="bash">$ git remote -v
</code></pre>

<p>to check the current remote URL, which should look something like
<code>https://github.com/Z1MM32M4N/&lt;repo name&gt;</code>. Then, you can run</p>

<pre><code class="bash">$ git remote set-url origin https://github.com/jez/&lt;repo name&gt;
</code></pre>

<p>to actually change the URL.</p>

<p>Because of the way that GitHub handles username changes, you should be able to
continue using the current URLs at least for the time being, but any time you
pull you&rsquo;ll get a message from GitHub asking to update the remote URLs.</p>

<p>I tried to update all links referencing Z1MM32M4N to use the new username, but
I&rsquo;m sure I&rsquo;ve missed a few. If you find a &ldquo;broken&rdquo; link, shoot me a message
letting me know!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mastering git log for Collaboration]]></title>
    <link href="https://blog.jez.io/git-log/"/>
    <updated>2015-01-16T20:57:01-05:00</updated>
    <id>https://blog.jez.io/git-log</id>
    <content type="html"><![CDATA[<p>One of the first Git commands people learn is <code>git status</code>. It&rsquo;s a great command
to understand the state of your personal repository, but it tells you nothing
about the structure of your teammates&#8217; branches or remotes. Luckily, <code>git log</code>
visualises the state of a Git repository at any time, so we can collaborate
seamlessly.</p>

<!-- more -->


<p>This post is going to focus on this one, amazing command. Behold:</p>

<pre><code class="bash">git log --graph --oneline --abbrev-commit --decorate --all

# That's borderlying fearsome! Let's make an alias:
alias gll="git log --graph --oneline --abbrev-commit --decorate --all"
</code></pre>

<p>Don&rsquo;t worry about what all the flags are; if you&rsquo;re really curious, <code>git help
log</code> explains them. What we care about is what information this gives us, and
how we can leverage it to collaborate with confidence in a Git repo.</p>

<p>Have you copied the alias into your <code>~/.bashrc</code> yet? There&rsquo;s no time like the
present.</p>

<h2>Using This Alias</h2>

<p>When collaborating on a Git repo, it&rsquo;s important to know how the branch you&rsquo;re
working on relates to <code>master</code>, and all your teammates&#8217; branches. I might want
to preview their code, combine the feature I&rsquo;m working on with theirs, take over
on a certain branch, etc. There are &ldquo;black magic&rdquo; Git incantations that will
solve these problems for you. The trick is knowing which one you need.</p>

<p>That&rsquo;s where <code>git log</code> comes in. Git is really just a big directed graph of
commits, each one pointing to the one that came before. At the top of the graph,
sometimes these directed chains of commits break off from one another. When this
happens, we say that two branches have &ldquo;diverged.&rdquo; Understanding where divergent
branches are pretty much the only trick to collaborating on Git repos.</p>

<p>So what does our <code>gll</code> alias do for us? It visualizes the commit structure. In
particular, if there are divergent branches, we&rsquo;ll see them:</p>

<p><a class="image-link" href="/images/gll-ale.png"><img src="/images/gll-ale.png"></a></p>

<p>Some points about what we&rsquo;re seeing here:</p>

<ul>
<li><p>Each <code>*</code> represents a commit.</p>

<ul>
<li>We can see information like commit hash and message next to it.</li>
</ul>
</li>
<li><p>The commits start with most recent at the top, and get older going down.</p></li>
<li><p>Git is helpful enough to draw quaint little ASCII art lines connecting
commits.</p></li>
<li><p>Each commit is &ldquo;decorated&rdquo; with any references that point to that commit.</p>

<ul>
<li>For example, ref <code>origin/master</code> is equal to commit <code>80c7fbc</code> here.</li>
</ul>
</li>
</ul>


<p>And most importantly: with just a glance, we can see where the divergent
branches are. Our <code>smlnj-cm-files</code> forked off from <code>master</code>. In the mean time,
since we branched off, there were three commits to master. This means we can
expect some sort of merge or rebase before including our code into <code>master</code>.</p>

<p>I find this command nothing less than miraculous when working with Git. Between
<code>git status</code> and <code>gll</code>, I can figure out what command I need, or make a
well-informed Google search with what I&rsquo;d like to do&mdash;these two commands answer
all of my questions nearly without fail.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h2>Go Forth and Git</h2>

<p>To recap: whenever you&rsquo;re stuck: <code>git status</code> first,<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> and <code>gll</code> if
needed. I&rsquo;d recommend running these commands even when you&rsquo;re convinced you
don&rsquo;t need them just to start learning to recognize &ldquo;normal&rdquo; and &ldquo;weird&rdquo; graph
shapes.</p>

<p>Want to learn more about how to leverage Git branches? There&rsquo;s an <strong><a href="http://pcottle.github.io/learnGitBranching/">excellent
interactive tutorial</a></strong> that visualizes Git branches basically
the same way we covered in this post (but simpler), and even has fancy
animations. For a taste of how it works, there&rsquo;s also a <a href="http://pcottle.github.io/learnGitBranching/?demo">non-interactive
demo</a>. After I ran through this tutorial, I felt for the first time like I
<em>really</em> knew Git. I&rsquo;m a huge fan&mdash;give it a look!</p>

<p>And if you&rsquo;re hungry for more handy Git aliases or just some general ways to
beef up your terminal experience, you can find these four aliases and more in
the <strong><a href="https://github.com/jez/dotfiles/blob/5cda64644a5ef9400851c9ea5f0fe9719a4649eb/util/aliases.sh">aliases.sh</a></strong> file in my <strong><a href="https://github.com/jez/dotfiles">dotfiles repository</a></strong>
on GitHub.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Many people I know who are quite competent at Git manage to use it without <code>gll</code>. For me, <code>gll</code> is indispensible. My theory here is that these poor people have such intense muscle memory that they rarely, if ever, get their Git repository into a state they&rsquo;re unsure of. Rather than suffer through that learning curve, here&rsquo;s hoping that <code>gll</code> works as well for you as it has for me!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Why don&rsquo;t I go in depth into <code>git status</code> as well? Because <code>git status</code> almost always tells you the command you want to run next! It&rsquo;s actually pretty smart at this. Have you read your <code>git status</code> output carefully recently?<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Multiple Git Remotes]]></title>
    <link href="https://blog.jez.io/2014/11/01/using-more-than-one-git-remote/"/>
    <updated>2014-11-01T18:12:35-04:00</updated>
    <id>https://blog.jez.io/2014/11/01/using-more-than-one-git-remote</id>
    <content type="html"><![CDATA[<p>Quite often when using git, you only need to use one remote: <code>origin</code>. All your pushes and pulls communicate with this one host. However, there are many occasions when using multiple Git remotes is incredibly handy.</p>

<!-- more -->


<h2>Quick Overview: Remotes</h2>

<p>If you haven&rsquo;t already, I strongly recommend that you check out these two Git resources in your free time:</p>

<ul>
<li><a href="http://pcottle.github.io/learnGitBranching/"><strong>Learn Git Branching</strong></a>, an interactive walkthrough of some powerful Git features</li>
<li><a href="https://wildlyinaccurate.com/a-hackers-guide-to-git"><strong>A Hacker&rsquo;s Guide to Git</strong></a>, an explanation of Git by &ldquo;taking a peek under the hood&rdquo;</li>
</ul>


<p>In this article, I&rsquo;ll only be talking about remotes. Remotes are basically &ldquo;mirrors&rdquo; of a branch that you have locally, but on a different computer.</p>

<h2>Scenario: Working with Code in 15-150</h2>

<p>At CMU, the class 15-150 distributes its starter code in a beautiful way: using Git! This opens up a number of things we can take advantage of, but there&rsquo;s one thing in particular we can do using multiple git remotes.</p>

<p>In 15-150, the code is distribute in a read-only Git repo. If we want a place where we can push and pull our changes, we&rsquo;ll need to create our own <em>bare repo</em> (a repo that&rsquo;s used just for pushing and pulling). You&rsquo;ll note that I said push <em>and pull</em>. The reason why I want to be able to pull is because I want to have 2 clones of this repo: one on the CMU Andrew Unix servers (where the 15-150 code is hosted), and one on my laptop, where there&rsquo;s no network latency to edit files in Vim.</p>

<p>To achieve this setup, the first thing we&rsquo;ll do is set up the bare repo. The best place to put a bare repo is on a server so that you can always access your code. So from Andrew, I&rsquo;ll run the commands:</p>

<pre><code class="bash Initialize the Bare Repo"># (unix.andrew.cmu.edu)
#
# `git clone --bare` is basically GitHub's "Fork" feature,
# if you're familiar with that
$ git clone --bare ~/private/gitrepos/15150
# make sure you clone this into your private folder!
</code></pre>

<p>This creates a bare repo initialized with all the 15-150 content which I can clone in two different ways: one for if I&rsquo;m on Andrew, one if I&rsquo;m on my laptop.</p>

<pre><code class="bash Clone New Remote"># (unix.andrew.cmu.edu)
#
# Clone over Unix file path to new folder ~/private/15150
$ git clone ~/private/gitrepos/15150 ~/private/15150

# -- and/or --

# (my laptop)
#
# Clone over ssh (using ssh alias, i.e., if you use `ssh andrew`)
$ git clone ssh://andrew:/afs/andrew/usr/jezimmer/private/15150
# -- or --
# Clone over ssh (without ssh alias,
#            i.e., if you use `ssh jezimmer@unix.andrew.cmu.edu`)
$ git clone ssh://jezimmer@unix.andrew.cmu.edu:/afs/andrew/usr/jezimmer/private/15150
</code></pre>

<p>To throw in a few graphics, our setup looks like this right now:</p>

<p><a class="image-link" href="/images/multiple-remotes-1.svg"><img src="/images/multiple-remotes-1.svg"></a></p>

<p>I&rsquo;m representing bare repos as clouds and clones of those repos as squares, with arrows representing whether code can flow from one place to the next. As you can see, to send code back and forth between Andrew and my laptop, I can just push in one place and pull in the other.</p>

<p>The one thing missing from our picture is the original handout repo. How will we get updates as the homeworks are released? The last piece involves setting this up.</p>

<pre><code class="bash Add Handout Remote"># Add the 15-150 handout remote so we can get starter code, etc.
# (unix.andrew.cmu.edu)
#
# A common name for the second remote is "upstream", though you could also
# call this remote "handout" if that would be easier to keep straight
$ cd ~/private/15150
$ git remote add upstream /afs/andrew/course/15/150/handout

# -- and/or --

# (my laptop)
#
# Add remote over ssh with alias
$ git remote add upstream ssh://andrew:/afs/andrew/course/15/150/handout
# -- or --
# Add remote over ssh without alias
$ git remote add upstream ssh://jezimmer@unix.andrew.cmu.edu:/afs/andrew/course/15/150/handout
</code></pre>

<p>Once we run those two lines, our setup looks like this, where arrows point in
the direction data can flow:</p>

<p><a class="image-link" href="/images/multiple-remotes-2.svg"><img src="/images/multiple-remotes-2.svg"></a></p>

<p>After this, we&rsquo;re able to run <code>git pull upstream master</code> to get the 15-150 starter code as it&rsquo;s released. I find this model particularly useful for all my classes, even the ones that don&rsquo;t distribute their code using Git. Having code both on Andrew and on my local machine is a generally handy configuration, and using Git to push the code around to the right places makes my workflow simple.</p>

<p>As always, let me know if something was unclear or incorrect in the comments!</p>

<h2>More Applications</h2>

<p>There are plenty other applications of using multiple remotes with Git. Perhaps the most common is to use them with the <a href="https://help.github.com/articles/fork-a-repo/"><strong>GitHub forking model</strong></a>, which is useful when collaborating on a software development project with others. You can use multiple remotes to do things like resolve merge conflicts in pull requests and to keep your fork up to date with the original repo.</p>
]]></content>
  </entry>
  
</feed>
