<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: osx | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/osx/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2020-01-02T23:55:47-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Haskell Stack Setup on OS X]]></title>
    <link href="https://blog.jez.io/troubleshooting-haskell-stack-setup-on-os-x/"/>
    <updated>2016-08-02T21:04:08-07:00</updated>
    <id>https://blog.jez.io/troubleshooting-haskell-stack-setup-on-os-x</id>
    <content type="html"><![CDATA[<p>Stephen Diehl&rsquo;s article <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in 2016</a> does a great
job of outlining the quickest way to get a quality Haskell development
experience. I ran into a simple issue when I followed it due to a bit of an
idiosyncrasy on OS X El Capitan. I also document a few of the extra steps I took
which aren&rsquo;t mentioned explicitly in his original article.</p>

<!-- more -->


<p>This post wouldn&rsquo;t actually be necessary if it weren&rsquo;t for one thing: <a href="https://support.apple.com/en-us/HT204899">System
Integrity Protection</a> in OS X El Capitan, also known as &ldquo;rootless&rdquo;
mode. It affects Haskell&rsquo;s build and install step in a subtle (but solved) way,
and the rest of the article will cover what to watch out for when installing on
OS X.</p>

<p>If you don&rsquo;t follow these instructions and you&rsquo;re on OS X El Capitan, you&rsquo;ll
likely run into an issue that looks like <code>/usr/bin/ar: permission denied</code>. The
Stack installation instructions call this out specifically:</p>

<blockquote><p>If you are on OS X 10.11 (&ldquo;El Capitan&rdquo;) or later, GHC 7.8.4 is incompatible
with System Integrity Protection (a.k.a. &ldquo;rootless&rdquo;). GHC 7.10.2 includes a
fix, so this only affects users of GHC 7.8.4.</p></blockquote>

<p>At the risk of spoiling the surprise, we&rsquo;re going to set up Stack while taking
care to make sure that we get GHC >= 7.10. So let&rsquo;s do just that!</p>

<h2>Environment Prep (optional)</h2>

<p>Note that this step is optional and has nothing to do with OS X; I just wanted
to point it out quickly.</p>

<p>Under <a href="http://www.stephendiehl.com/posts/vim_2016.html#dev-environment">Dev Environment</a> on <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in
2016</a>, Stephen Diehl writes:</p>

<blockquote><p>Times have changed quite a bit, and the new preferred way of installing GHC in
2016 is to forgo using the system package manager for installing ghc and use
Stack to manage the path to the compiler executable and sandboxes.</p></blockquote>

<p>Stack stores it&rsquo;s metadata in the <code>~/.stack</code> folder by default. If you&rsquo;re not a
huge fan of things cluttering up your home folder, set the <code>STACK_ROOT</code> variable
in you bashrc or zshrc:</p>

<pre><code class="bash Set STACK_ROOT to avoid clutter">export XDG_DATA_HOME="$HOME/.local/share"

# Have Haskell Stack use XDG Base Directory spec
export STACK_ROOT="$XDG_DATA_HOME/stack"
</code></pre>

<p>Of course, the choice of location is up to you. In particular I&rsquo;ve chosen to
adhere to the <a href="https://wiki.archlinux.org/index.php/XDG_Base_Directory_support">XDG Base Directory specification</a> here, which you may want
to take a peek at if you&rsquo;re unfamiliar. That&rsquo;s why you see references to
<code>XDG_DATA_HOME</code>.</p>

<p>Make sure you restart your terminal to pick up the new variables before
continuing.</p>

<h2>Install Stack from Homebrew</h2>

<p>If you&rsquo;re like me, you&rsquo;ll want to take a second to purge anything
Haskell-related from previous botched setup attempts:</p>

<pre><code class="bash Wipe the slate clean"># If you had GHC installed
$ brew uninstall ghc

# If you tried and failed at installing Stack already
$ brew uninstall haskell-stack
$ rm -r ~/.stack
# If you happened to also set STACK_ROOT
$ rm -r $STACK_ROOT
</code></pre>

<p>With that out of the way, we can actually get our hands on Stack. For OS X,
we&rsquo;ll install through Homebrew:</p>

<pre><code class="console Install Stack">$ brew install haskell-stack
</code></pre>

<h2>Configure Stack, avoiding &ldquo;rootless&rdquo; issues</h2>

<p>Here&rsquo;s the trick. We need to run <code>stack setup</code> for the first time to let Stack
configure itself. But remember: we want to make sure that Stack doesn&rsquo;t set
itself up with version 7.8.4 of GHC. We can get around this by specifying an
explicit resolver to the <code>stack</code> command (you can find more information on
&ldquo;resolvers&rdquo; elsewhere):</p>

<pre><code class="bash Side-step rootless issue in setup"># Change the resolver to the most up-to-date one. This is a hack to ensure that
# get GHC version &gt; 7.8, because there's an issue with El Capitan's rootless
# mode.
stack --resolver=lts-6.10 setup
</code></pre>

<p>You&rsquo;ll notice we use the <code>--resolver=...</code> flag to force Stack to use a specific
resolver. This post will be out of date as soon as it&rsquo;s written, so check
<a href="https://www.stackage.org/snapshots">Stackage</a> to find the latest LTS snapshot.</p>

<h2>Return to Vim and Haskell in 2016</h2>

<p>That&rsquo;s it for the environment setup! Now you&rsquo;ll want to turn your attention to
configuring Vim.</p>

<p>The steps to set up Vim are platform independent, so now that we&rsquo;ve set up Stack
correctly, you can head over to <a href="http://www.stephendiehl.com/posts/vim_2016.html">Vim and Haskell in 2016</a> to
finish things out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SML Dev Setup]]></title>
    <link href="https://blog.jez.io/sml-dev-setup/"/>
    <updated>2016-03-09T20:06:15-06:00</updated>
    <id>https://blog.jez.io/sml-dev-setup</id>
    <content type="html"><![CDATA[<p>When it comes right down to it, SML is a pretty great language. It&rsquo;s clear that
extensive thought has gone into its design and implementation. I quite enjoy
programming in SML, due in no small part to my collection of workflow hacks that
make editing and developing with SML responsive and interactive.</p>

<!-- more -->


<p>We&rsquo;re going to be walking through a couple easy steps to make developing SML
feel more fluid. I have a slight preference for Vim (Neovim) on macOS, but many
of these steps are platform agnostic.</p>

<p><strong>Note</strong>: I updated this post to more accurately reflect my SML dev setup in
December 2019.</p>

<h2>Installing SML Locally</h2>

<p>While developing SML in a remote environment like the shared Andrew Unix
machines makes it easy to dive right in, I prefer doing development on my
laptopâ€”it doesn&rsquo;t get slow when there are many people logged in, there&rsquo;s no
nightly reboots, and it doesn&rsquo;t matter whether I have a strong WiFi connection.</p>

<p>On macOS and Ubuntu, the two most popular implementations of SML are already
packaged. Take the time to install a version of SML right now:</p>

<ul>
<li><p>At CMU we use <a href="http://smlnj.org/">SML/NJ</a>, which is convenient because it has a REPL that
for playing around with SML interactively.</p></li>
<li><p>To play around with releasing programs written in SML to other people, install
<a href="http://www.mlton.org/">MLton</a>. It has better support for compiling SML programs to standalone
executables which can be shared from one machine to another. (I have a
separate post on <a href="/sml-travis-ci/">using SML to release software publically</a>
with more details).</p></li>
</ul>


<pre><code class="bash Install SML from your package manager"># macOS -- one or both of:
brew install smlnj
brew install mlton

# Ubuntu -- one or both of:
sudo apt-get install smlnj
sudo apt-get install mlton
</code></pre>

<p>Feel free to install both; they&rsquo;ll play nicely with each other, and each offers
advantages over the other.</p>

<p>Note for macOS users: if you&rsquo;ve never used <a href="http://brew.sh">Homebrew</a> before, you&rsquo;ll need
to <a href="http://brew.sh">install it first</a>.</p>

<p>Note for Ubuntu users: the versions of these two that ship in the default
package distribution are frequently out of date. If that matters to you,
consider following the the <a href="http://smlnj.org/">SML/NJ</a> and <a href="http://www.mlton.org/">MLton</a> installation
instructions directly.</p>

<h2>Getting Comfortable with SML/NJ</h2>

<p>The rest of these steps should apply regardless of whether you&rsquo;re working on SML
locally or remotely.</p>

<p>One thing that I&rsquo;ve seen far too many times from course documentation is that
they tell students to run their code like this:</p>

<ol>
<li>Run <code>sml</code></li>
<li>Type <code>use "foo.sml";</code> or <code>CM.make "sources.cm";</code> at the REPL</li>
</ol>


<p>Don&rsquo;t get me wrong; this works, but there&rsquo;s a better way. Being responsible
CLI-citizens, we should always be looking for ways to tab-complete. We can
easily get tab-completion on the filename by changing our workflow:</p>

<ol>
<li>Run <code>sml foo.sml</code> or <code>sml -m sources.cm</code></li>
</ol>


<p>Look at that! We&rsquo;ve,</p>

<ul>
<li>dropped a step (having to launch the REPL first), and</li>
<li>introduced tab completion (because the shell has filename completion)</li>
</ul>


<p>It&rsquo;s the little things, but they add up.</p>

<h2>Enhancing the REPL</h2>

<p>Speaking of the little things, when using the SML REPL, you don&rsquo;t have access to
all the usual command line niceties like command history and access to arrow
keys for editing, let alone Vi-like keybindings. To get started, you&rsquo;ll have to
change how you launch the SML/NJ REPL. In particular, we&rsquo;re going to preface our
commands with <code>rlwrap</code>:</p>

<pre><code class="bash"># instead of this...
$ sml

# use this:
$ rlwrap sml
</code></pre>

<p><code>rlwrap</code> stands for &ldquo;readline wrap.&rdquo; Readline is a library that adds all the
features mentioned above to any REPL program:</p>

<ul>
<li>Command history tracking (up arrow keys)</li>
<li>Line editing with arrow keys</li>
<li>Configuration through the <code>~/.inputrc</code> file

<ul>
<li>We can use this to get fancy features like Vi keybindings</li>
</ul>
</li>
</ul>


<p>For more information, see <a href="https://github.com/jez/dotfiles/blob/ed8e531eebe43a8aef05fc4cb768157d03408cea/inputrc#L12-L14">these lines</a> of my inputrc, a small part of
my <a href="https://github.com/jez/dotfiles">dotfiles repo</a> on GitHub.</p>

<h2>Setting Up Vim</h2>

<p>Programming is so much more enjoyable when you&rsquo;re not fighting your editor. For
me, this means striving to get the most out of Vim. In this section, I&rsquo;ll
outline all the cool tips and tricks I have for developing SML in Vim.</p>

<p>But first, if you&rsquo;ve never taken a look into how to configure Vim, I suggest you
start out by walking through this quick workshop called <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>. It&rsquo;ll teach you where to start when configuring Vim and get
you set up with a bunch of standard plugins that improve on the standard Vim
experience tenfold.</p>

<p>No actually, take a second and <a href="https://github.com/jez/vim-as-an-ide">walk through it</a>. We&rsquo;ll still be
here when you&rsquo;re done, and you&rsquo;ll appreciate Vim more when you&rsquo;re done.</p>

<h3>ALE</h3>

<p><a href="https://github.com/dense-analysis/ale">ALE</a> is a Vim plugin that provides what it calls &ldquo;asynchronous linting.&rdquo;
That&rsquo;s a fancy way of saying that it can show little red x&rsquo;s on all the lines
that have errors. It works for many languages out of the box, including Standard
ML.</p>

<p>It&rsquo;s super simple to set up. The <a href="https://github.com/dense-analysis/ale">ALE homepage</a> should have all the
instructions.</p>

<p>With ALE set up, try writing this into a file called <code>test.sml</code>:</p>

<pre><code class="sml test.sml">val foo : string = 42
</code></pre>

<p>While typing, any errors should appear as markers to the left of the line
numbers. Super handy!</p>

<p>If nothing shows up, check <code>:ALEInfo</code> which dumps a bunch of information
about whether ALE was set up correctly. In particular, SML support requires
having <a href="http://smlnj.org/">SML/NJ</a> installed (i.e., installing it on your laptop or working
on a server where it&rsquo;s already installed).</p>

<h3>Extra ALE Setup</h3>

<p>While the default settings for ALE work well enough, there&rsquo;s plenty of reasons
to tweak them. For example, here are <a href="https://github.com/jez/dotfiles/blob/b942b6336ee968c9d94a9ea363c1cbcdb44b9846/vim/plug-settings.vim#L227-L239">all my ALE settings</a>.</p>

<p>The key changes I make:</p>

<ul>
<li>I ask ALE to show a list of all errors if there were any.</li>
<li>I ask ALE to only run when the file was saved (not when it was opened or
edited).</li>
</ul>


<p>(You&rsquo;ll also see a bunch of settings for other languages, but you won&rsquo;t find any
SML-specific config&hellip; it&rsquo;s not needed!)</p>

<p>Also, a tip for those who&rsquo;ve never used Vim&rsquo;s location list: you can close the
list of errors with <code>:lclose</code>.</p>

<h3>Using ALE with CM files</h3>

<p>Sometimes a single SML file is self-contained enough to type check on it&rsquo;s own.
But most of the time, we&rsquo;re working with multi-file SML projects. With SML/NJ,
multi-file SML projects are managed using CM files (<code>*.cm</code> files) which declare
groups of SML files that must be compiled together to make sense.</p>

<p>ALE&rsquo;s support for SML handles both of these scenarios. When opening an SML file,
ALE will search up the folder hierarchy for any <code>*.cm</code> file, stopping when it
finds the first one. When there are multiple in a single folder, it takes the
alphabetically first option.</p>

<p>Usually this works fine but sometimes ALE picks the wrong one. There are
instructions for how to manually fix this by setting some variables in the ALE
help:</p>

<pre><code>:help ale-sml-options
</code></pre>

<h3><code>vim-better-sml</code></h3>

<p>After all that, I still wasn&rsquo;t satisfied with developing SML in Vim, so I wrote
a plugin to make it even better: <a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>. Here&rsquo;s a
quick rundown of its features:</p>

<ul>
<li>It supports for embedding a REPL directly inside Vim.</li>
<li>It supports asking for the type of a variable under the cursor.</li>
<li>It supports jump to definition, even into the Standard Basis Library.</li>
<li><code>*.sig</code> files are properly detected as SML signature files.</li>
<li>Many small annoyances with syntax highlighting and indentation are fixed.</li>
</ul>


<p>For more information, including how to install it, check out the homepage:
<a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>. For the most part, the plugin itself will
guide you through the installation, declaring any dependencies that might be
missing.</p>

<p>I recorded a screencast of all those features above in action, which you might
want to check out:</p>

<p><a href="https://youtu.be/Z5FsPZ5cm8Y"><img src="/images/vim-better-sml-demo-thumbnail.png" alt="thumbnail" /></a></p>

<h2>General Vim Settings</h2>

<p>As a quick addendum, one common complaint people have when editing SML is that
it forces the line to wrap if it extends past 80 characters. Some people don&rsquo;t
like that, and others don&rsquo;t like that it doesn&rsquo;t do it frequently enough
(namely, it only wraps the line if your <strong>cursor</strong> extends past 80 characters,
not the end of the line).</p>

<p>If you don&rsquo;t want Vim to do any of this wrapping, run this:</p>

<pre><code class="vim Disable hard line wrapping">setlocal textwidth=0
</code></pre>

<p>If you&rsquo;d like this change to persist between Vim sessions, add it to
<code>~/.vim/after/ftplugin/sml.vim</code>. These folders and file likely don&rsquo;t exist
yet; you&rsquo;ll have to create them. The <code>after</code> folder in Vim is used to override
settings loaded from plugins.</p>

<p>Alternatively, if you&rsquo;d like a little better idea when Vim&rsquo;s going to hard wrap
your line, you can add one of these lines to your vimrc:</p>

<pre><code class="vim Show a color column">" Always draw the line at 80 characters
set colorcolumn=80

" Draw the line at whatever the current value of textwidth is
set colorcolumn+=0
</code></pre>

<p>That way, it&rsquo;s easier to see when a line is getting long.</p>

<h2>TL;DR</h2>

<p>We covered a lot, so here&rsquo;s a quick recap:</p>

<ul>
<li>Install SML locally. It&rsquo;s super easy to do on macOS and Linux (use your
package manager), and means you don&rsquo;t have to have a Wi-Fi connection to
develop SML.</li>
<li>Invest time into learning Vim. Here&rsquo;s a reference: <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>.</li>
<li>Install <a href="https://github.com/dense-analysis/ale">ALE</a>. It tells you what lines your errors are on.</li>
<li>Install <a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>. It includes a whole host of added
power features.</li>
</ul>


<p>And as always, you can see even more Vim settings in my <a href="https://github.com/jez/dotfiles">dotfiles
repo</a> on GitHub.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Offline LaTeX Development - Part 2]]></title>
    <link href="https://blog.jez.io/2015/01/10/offline-latex-development-part-2/"/>
    <updated>2015-01-10T16:00:00-06:00</updated>
    <id>https://blog.jez.io/2015/01/10/offline-latex-development-part-2</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve already written about how I develop LaTeX offline in Vim using GNU Make.
Recently, though, I found a tool that implements another feature that GUI
editors had to themselves: splitting panes.</p>

<!-- more -->


<h2><a href="/2014/10/06/offline-latex-development/">Offline LaTeX Development</a></h2>

<p>If you missed it, check out my previous post here before reading on. There&rsquo;s a
lot of handy stuff there!</p>

<h2>Split Panes</h2>

<p>Out of the box, tools like ShareLaTeX and TeXShop feature split pane editing:
you can have your LaTeX on one half of the screen and the PDF on the other.
Previously, I justified not having this feature with the reasoning that the
<code>:WV</code> binding (something I explained <a href="/2014/10/06/offline-latex-development/">here</a>) immediately opened up the
PDF and the windows switched.</p>

<p>However, I read about a tool called <a href="http://ianyh.com/amethyst/">Amethyst</a> on Hacker News the
other day and immediately realized it&rsquo;s potential for improving my LaTeX setup.
Amethyst is a tool that strives to be a tiling window manager like xmonad for OS
X. At times it falls short of this goal, but for the most part it works really
well. Just open up two apps, like MacVim and Preview, and it&rsquo;ll show them
side-by-side with no added effort. There are also plenty of keybindings to
manipulate the window arrangements.</p>

<p>Here&rsquo;s a screenshot of what the new setup looks like:</p>

<p><a class="image-link" href="/images/latex-amethyst.png"><img src="/images/latex-amethyst.png"></a></p>

<p>After looking into it a little more, it looks like there are other OS X tools
for spitting the screen into two panes, like <a href="http://www.bettertouchtool.net/">BetterTouchTool</a>, though I
haven&rsquo;t actually tried any of them out.</p>
]]></content>
  </entry>
  
</feed>
