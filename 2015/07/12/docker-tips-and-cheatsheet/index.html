
<!DOCTYPE html>

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Docker Tips and Cheatsheet - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="A list of commands I use (and keep forgetting) every time I use Docker.">

<meta name="keywords" content="docker ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->

  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://blog.jez.io/touch-icon.png">
  <meta name="twitter:title" content="Docker Tips and Cheatsheet">
  <meta name="twitter:description" content="A list of commands I use (and keep forgetting) every time I use Docker.">
  <meta name="twitter:creator" content="@jez_io">


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/2015/07/12/docker-tips-and-cheatsheet">
<meta property="og:title" content="Docker Tips and Cheatsheet">
<meta property="og:description" content="A list of commands I use (and keep forgetting) every time I use Docker.">
<meta property="og:image" content="https://blog.jez.io/touch-icon.png">
<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/2015/07/12/docker-tips-and-cheatsheet">
<link href="/touch-icon.png" rel="apple-touch-icon-precomposed">
<link href="/favicon@2x.png" rel="icon" sizes="32x32">
<link href="/favicon.png" rel="icon" sizes="16x16">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">




</head>

<body id="post" class="">

<nav class="Navigation">
  <ul class="Tags">
    
      <li class="Tag">
        
          <a href="/">Home</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="/categories/">Categories</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="https://jez.io">About</a>
        
      </li>
    
  </ul>
</nav>





<div class="EntryHeader">
  <h1 class="EntryHeader-title">Docker Tips and Cheatsheet</h1>
  <h2 class="EntryHeader-subtitle">July 12, 2015</h2>

  <ul class="Tags">
    
  </ul>
</div>



<div id="main" role="main">
  <article class="Post-content">
    <p>I&rsquo;ve been using Docker for a couple side projects lately, but only
intermittently. That means every time I try to get back into things, I spend the
first 15 minutes or so trying to remember all the little tricks I&rsquo;ve picked up
from previous Google searches and hunts through the documentation. Rather than
continue to suffer through this cycle, I&rsquo;ve written them down here to help you
and me ramp up more quickly on our next Docker projects.</p>

<!-- more -->


<h2>Making your Docker experience easier: Docker Compose</h2>

<p>Half the complexity of Docker is wrapped up in its large, verbose set of command
line arguments and flags. Luckily, Docker has a tool called <a href="https://docs.docker.com/compose/">Docker Compose</a>
that lets us translate all our command line flags into a <code>.yml</code> file. This makes
it much easier to remember how to build and run your containers, as well as to
communicate with your teammates; you no longer need to a common &ldquo;setup.sh&rdquo;
script that remembers what obscure Docker commands and flags you used to set
things up. If you&rsquo;ve never heard of it, you might want to <a href="https://docs.docker.com/compose/">check it out
now</a>. I&rsquo;ll be mixing-and-matching my favorite <code>docker</code> and <code>docker-compose</code>
commands through the rest of the post.</p>

<h2>TL;DR</h2>

<p>Here&rsquo;s a quick cheatsheet:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Build your whole Docker Compose project...</span>
</span><span class='line'>docker-compose build
</span><span class='line'><span class="c"># ...or just build one piece of it</span>
</span><span class='line'>docker-compose build <span class="o">[</span>app|db|etc...]
</span><span class='line'>
</span><span class='line'><span class="c"># Start your Docker Compose project</span>
</span><span class='line'>docker-compose up -d
</span><span class='line'><span class="c"># View the logs for this docker-compose proejct</span>
</span><span class='line'>docker-compose logs
</span><span class='line'><span class="c"># Stop running containers</span>
</span><span class='line'>docker-compose stop
</span><span class='line'>
</span><span class='line'><span class="c"># remove stopped containers</span>
</span><span class='line'>docker rm <span class="k">$(</span>docker ps -a | grep Exited | awk <span class="s1">'{print $1;}'</span><span class="k">)</span>
</span><span class='line'><span class="c"># or, to remove the stopped containers that were started by Docker Compose</span>
</span><span class='line'>docker-compose rm
</span><span class='line'><span class="c"># remove untagged images</span>
</span><span class='line'>docker rmi <span class="k">$(</span>docker images -q --filter <span class="s2">"dangling=true"</span><span class="k">)</span>
</span><span class='line'><span class="c"># Clean up dangling volumes</span>
</span><span class='line'><span class="c"># (see the post below for how to install the python script)</span>
</span><span class='line'>sudo python docker_clean_vfs.py
</span><span class='line'><span class="c"># Better yet, remove dangling volumes before they're created by using -v</span>
</span><span class='line'>docker-composer rm -v</span></code></pre></td></tr></table></div></figure>


<p>Keep in mind that Docker Compose needs to always read your <code>docker-compose.yml</code>
file, so make sure to always run <code>docker-compose</code> commands from the root of your
project.</p>

<h2>Building your app</h2>

<p>Docker Compose&rsquo;s biggest advantage is that it simplifies building your
Dockerized app to just</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose build</span></code></pre></td></tr></table></div></figure>


<p>Most apps, though, have a couple Docker Compose targets, like <code>db</code> and <code>app</code> in
this sample <code>docker-compose.yml</code> file:</p>

<figure class='code'><figcaption><span>docker-compose.yml</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='yaml'><span class='line'><span class="na">db</span><span class="pi">:</span>
</span><span class='line'>  <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
</span><span class='line'>  <span class="s">...</span>
</span><span class='line'><span class="na">app</span><span class="pi">:</span>
</span><span class='line'>  <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
</span><span class='line'>  <span class="s">...</span></span></code></pre></td></tr></table></div></figure>


<p>If all you&rsquo;ve done is made a simple change to <code>app</code>, you can get by with just</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose build app</span></code></pre></td></tr></table></div></figure>


<p>without having to rebuild all of <code>db</code> as well.</p>

<h2>Running your app</h2>

<p>To start a Docker Compose app once you&rsquo;ve built it&rsquo;s constituent images:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose up -d</span></code></pre></td></tr></table></div></figure>


<p>The <code>-d</code> flag is so that Docker Compose runs the command as a &ldquo;daemon&rdquo;, or in
the background. I can&rsquo;t think of any cases where you wouldn&rsquo;t want to use this
flag.</p>

<p>To view the logs from your app&rsquo;s running containers:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose logs</span></code></pre></td></tr></table></div></figure>


<p>This will show all the logs output as one, prefixed with their name as specified
in the <code>docker-compose.yml</code> file so you can keep things straight.</p>

<p>To bring your app down (if you started it with <code>-d</code>, otherwise just use <code>^C</code>):</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose stop</span></code></pre></td></tr></table></div></figure>


<h2>Getting rid of what Docker left behind</h2>

<p>You&rsquo;ll find after using Docker for a while that your disk usage seems to be
creeping upwards. This annoyed me at first, so I investigated. There are three
places Docker leaves junk behind.</p>

<h3>Stopped Docker containers</h3>

<p>Once you&rsquo;ve stopped your Docker containers, they remain on disk. If you&rsquo;re using
Docker Compose, you can just run the following to get rid of any containers
started by Docker Compose that have now stopped:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose rm</span></code></pre></td></tr></table></div></figure>


<p>If you&rsquo;re not using Docker Compose, you&rsquo;ll have to find them and manually prune
them:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># find all exited containers (docker ps ...),</span>
</span><span class='line'><span class="c"># and remove these containers (docker rm)</span>
</span><span class='line'>docker rm <span class="k">$(</span>docker ps -a | grep Exited | awk <span class="s1">'{print $1;}'</span><span class="k">)</span></span></code></pre></td></tr></table></div></figure>


<h3>Un-tagged Docker images</h3>

<p>When you&rsquo;re using Docker for developing an app, every time you change and
rebuild your Docker images, you&rsquo;ll leave behind an old, un-tagged image. This is
actually a &ldquo;feature&rdquo; of Docker: all images that you build are cached so that
subsequently builds are instantaneous. However, when we&rsquo;re developing and
generating new images frequently, previous image builds only take up space.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'># find all un-tagged images (docker images ...),
</span><span class='line'># and remove these images (docker rmi)
</span><span class='line'>docker rmi $(docker images -q --filter "dangling=true")</span></code></pre></td></tr></table></div></figure>


<p>You can always tag one of these images if you don&rsquo;t want it to get garbage
collected by the above command.</p>

<h3>Dangling volumes</h3>

<p>Every time you create and mount a volume into a docker container, Docker leaves
behind some state for managing that volume. Unfortunately (and infuriatingly),
the Docker CLI doesn&rsquo;t offer a way to clean these up natively. Luckily, there&rsquo;s
a super handy script online that uses the Docker Python API to handle it.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'># Install Python dependencies (do this only once)
</span><span class='line'>pip install docker-py
</span><span class='line'>
</span><span class='line'># Download the script
</span><span class='line'>wget https://raw.githubusercontent.com/dummymael/dotfiles/1859a36/tools/docker_clean_vfs.py
</span><span class='line'>
</span><span class='line'># Run the script
</span><span class='line'>sudo python docker_clean_vfs.py</span></code></pre></td></tr></table></div></figure>


<p>You can circumvent this madness if you make sure to remove your volumes before
they become dangling by using the following when your Docker Compose project
uses volumes:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>docker-compose rm -v</span></code></pre></td></tr></table></div></figure>


<h2>General Docker Wisdom</h2>

<p>Apart from that (small?) set of commands, the only other way I use Docker is
just writing <code>Dockerfile</code>s and <code>docker-compose.yml</code> files. Most of what you need
to know here comes from experience or looking at example files. I do, though,
have some tidbits of extra advice related to things that tripped me up in my
first Docker experiences.</p>

<p>You have to run <code>docker-compose build web</code> if you change the underlying
Dockerfile and you want the image to be rebuilt. Otherwise, <code>docker-compose up
-d</code> will happily use the old, cached image.</p>

<p>If a command failed, whether it was a one-off <code>docker run</code> command, an image
build, etc., it probably left its intermediate cruft around. See <a href="#getting-rid-of-what-docker-left-behind">Getting rid of
what Docker left behind</a> for more info.</p>

<p>Add an alias for <code>docker-compose</code>. That&rsquo;s far too long to be typing out all the
time. I use <code>alias fig="docker-compose"</code> remembering <a href="https://fig.sh">Docker Compose&rsquo;s
roots</a>.</p>

<p>Once I&rsquo;ve gotten my build environment to the point where I can just change my
core app (i.e., I&rsquo;ve set up the <code>Dockerfile</code> and <code>docker-compose.yml</code> file), I
basically just run</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>fig up -d
</span><span class='line'>
</span><span class='line'>fig logs
</span><span class='line'># observe my project, fix what's wrong
</span><span class='line'>^C &lt;-- quits the logs
</span><span class='line'>fig stop && fig rm -v && fig build web && fig up -d
</span><span class='line'>
</span><span class='line'>fig logs
</span><span class='line'># observe my project, fix what's wrong
</span><span class='line'>^C
</span><span class='line'>fig stop && fig rm -v && fig build web && fig up -d
</span><span class='line'>
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>It helps to understand the difference between &ldquo;images&rdquo; and &ldquo;containers&rdquo;. There
are plenty of ways to remember the difference between the two, but I like the
object-oriented programming analogy: &ldquo;images&rdquo; are to classes like &ldquo;containers&rdquo;
are to objects. The analogy isn&rsquo;t quite perfect, but it&rsquo;s close enough. We
create a new container (object) every time we run (instantiate) the image
(class). Images come with an understanding of what&rsquo;s common to all containers
(like the root file system, software dependencies, and app files), just like
classes know their constructor and member methods.</p>

<h2>More Tips</h2>

<p>Two blog posts were particularly helpful in compiling this list of commands; I&rsquo;d
be remiss to not acknowledge their wonderful work:</p>

<ul>
<li><a href="http://www.carlboettiger.info/2014/08/29/docker-notes.html">Docker tricks of the trade and best practices thoughts</a></li>
<li><a href="http://odino.org/spring-cleaning-of-your-docker-containers/">Spring cleaning of your Docker containers</a></li>
</ul>


<p>I&rsquo;ve entirely focused on the commands you can use to build, run, and manage your
Docker app in this post. The rest is just a matter of getting your <code>Dockerfile</code>
and <code>docker-compose.yml</code> to where you need them to be. For this, I&rsquo;d recommend</p>

<ul>
<li>the Docker documentation on <a href="https://docs.docker.com/articles/dockerfile_best-practices/">Dockerfile best practices</a>, as well as</li>
<li><a href="http://anandmanisankar.com/posts/docker-container-nginx-node-redis-example/">this walkthrough</a> for Dockerizing a sample app (in Node.js, but
the principles are generally applicable)</li>
</ul>


<p>Apart from that, try to find examples of these files that you can adapt to your
needs.</p>

    <footer class="entry-meta">
      <span class="entry-tags">
        <ul class="Tags">
          
            <li class="Tag">
              <a href="/categories/#docker" title="Pages tagged docker">docker</a>
            </li>
          
        </ul>
      </span>
      <span class="entry-date date published updated"><time datetime="2015-07-12T21:32:27-05:00">July 12, 2015</time></span>
      
    </footer>
  </div>
  
  <div class="read-more">
    
      <div class="read-more-header">
        <a href="/sorbet-pipeline-overview/" class="Button">Read More</a>
      </div><!-- /.read-more-header -->
      <div class="read-more-content">
        <h3><a href="/sorbet-pipeline-overview/" title="How Sorbet Works: An Overview">How Sorbet Works: An Overview</a></h3>
      <p>TODO <a href="/sorbet-pipeline-overview/"> Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/ruby-mutation/" title="What makes type checking Ruby hard?">What makes type checking Ruby hard?</a></h4>
            <span>Published on December 29, 2019</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/surgery-on-code/" title="Surgery on Code from the Command Line">Surgery on Code from the Command Line</a></h4>
            <span>Published on July 30, 2019</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
  </div><!-- /.read-more -->


</div>

<div class="footer-wrapper">
  Blog source on <a href="https://github.com/jez/blog">GitHub</a>.

</div>

</body>
</html>
