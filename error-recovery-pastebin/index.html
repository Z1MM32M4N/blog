<nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#understand-bisons-error-recovery-algorithm">Understand Bison’s error recovery algorithm</a></li>
  <li><a href="#using-the-error-token-well">Using the <code>error</code> token well</a></li>
  <li><a href="#try-actually-reading-the-generated-parser">Try actually reading the generated parser</a></li>
  <li><a href="#the-problem-might-be-the-lexer">The problem might be the lexer</a></li>
  <li><a href="#take-a-program-that-parses-delete-one-token-make-it-parse">Take a program that parses, delete one token, make it parse</a></li>
  </ul>
</nav>

<main>
<!-- vim:tw=90
-->
<p>Notably, Sorbet is the first project in this lineage of parsers to care excessively about error recovery. Sorbet prizes editor integration highly, and if the parser produces no parse result for an invalid Ruby file, no downstream editor functionality works (like completion, jump to definition, and hover).</p>
<p>Now let’s dive into the tips.</p>
<h1 id="understand-bisons-error-recovery-algorithm">Understand Bison’s error recovery algorithm</h1>
<!--
TODO(jez) Also worth noting that if you're using location information, the location of the
error token expands as it decides to throw things away (it's not just the location of the
lookahead token at the time a synatx error was encountered).
-->
<p>There’s a vague description of this algorithm <a href="https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery">in the docs</a>, but I found that I had to make it more explicit before I could use it well. At a high level, this is what Bison does:</p>
<ul>
<li>Encounter an error (i.e., it doesn’t expected the current lookahead token).</li>
<li>Report an error by calling the (user-defined) <code>parser::error</code> function.
<ul>
<li>This function is always called, and called even before attempting to shift the <code>error</code> token and recover from the error. This can be either a blessing (you know that adding <code>error</code> to a production rule will never prevent an error from being reported), or a curse (you don’t get an easy way to customize the error message in context once an <code>error</code> rule is matched).</li>
</ul></li>
<li>Leave the lookahead token untouched, and immediately shift the <code>error</code> token.</li>
<li>Check whether we can reduce. If we can’t, <em>completely discard</em> the object on the stack immediately before the error token (i.e., whatever we had most recently shifted or reduced before encountering the syntax error).
<ul>
<li>If we can, reduce, and continue. Remember that the lookahead token will still be set to whatever it was when the error occurred.</li>
<li>If we can’t, repeat. Keep discarding until we’ve matched a rule that consumed the <code>error</code> token or discarded everything, then continue reading new tokens.</li>
</ul></li>
</ul>
<p>It’s conceptually very simple, which is convenient, but has a few gotchas:</p>
<ul>
<li>It’s very easy to throw away important stuff. For example, Sorbet has a generic “attempt to recover from anything” rule for <code>stmts</code>:</li>
</ul>
<pre><code>stmts: // nothing
        {
          $$ = driver.alloc.node_list();
        }
    | stmt
        {
          $$ = driver.alloc.node_list($1);
        }
    | stmts terms stmt
        {
          $1-&gt;emplace_back($3);
          $$ = $1;
        }
    | error
        {
          $$ = driver.alloc.node_list();
        }</code></pre>
<p>This says that a list of statements is either empty, a single <code>stmt</code>, a <code>stmt</code> after a list of <code>stmts</code> and any number of terminators (<code>:</code> or <code>\n</code>), or <strong>any error</strong>. But consider how that interacts with this program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> foo</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span><span class="at">.times</span> <span class="kw">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>What happens here is that at the point where the error is encountered (the <code>end</code> token on the third line), it will happily discard <strong>all</strong> previous objects, even the <code>def foo</code>, before matching the <code>| error</code> rule. So even though we have an error recovery rule, in this case, our parse is going to be empty anyways. Which bring us to our next tip.</p>
<h1 id="using-the-error-token-well">Using the <code>error</code> token well</h1>
<p>I’ve found these tips for using Bison’s <code>error</code> token useful, in light of how the error recovery algorithm works:</p>
<ul>
<li><p>Whenever possible, add as much preceding context to the production using the <code>error</code> token. Like in the example above, we added the <code>error</code> token up in the <code>f_arg:</code> rule so that we could write the rule like <code>| f_arg tCOMMA error</code>, instead of adding it to the rule for <code>f_norm_arg</code> with no preceding context, like <code>| error</code>.</p>
<p>Adding the prefix has given me the best results for recovering from the error on my first attempted grammar edit without having to reason through conflicts, and also means that little to none of the already-parsed program has to be discarded.</p></li>
<li><p>Figure out what are the most common edits, and make every prefix of the stack along that edit have an <code>error</code> production. For example, consider inserting a new keyword arg:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>foo(a, <span class="wa">y: </span>y) <span class="co"># contents before edit</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>foo(a, x <span class="wa">y: </span>y)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>foo(a, <span class="wa">x: y: </span>y)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>foo(a, <span class="wa">x: </span>x <span class="wa">y: </span>y)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>foo(a, <span class="wa">x: </span>x, <span class="wa">y: </span>y) <span class="co"># edit finished</span></span></code></pre></div>
<p>Ideally there’s an <code>error</code> production for every intermediate state here, because adding a keyword argument to a method call is common. Probably method calls and variable assignments will be the most commonly edited constructs in all languages.</p></li>
</ul>
<h1 id="try-actually-reading-the-generated-parser">Try actually reading the generated parser</h1>
<h1 id="the-problem-might-be-the-lexer">The problem might be the lexer</h1>
<ul>
<li>sorbet’s lexer has states, sometimes will emit a <code>tNL</code>, sometimes it won’t</li>
<li>again: use trace diffs to figure out why it won’t take a production rule you</li>
</ul>
<h1 id="take-a-program-that-parses-delete-one-token-make-it-parse">Take a program that parses, delete one token, make it parse</h1>
<ul>
<li>This is very similar to how people make edits (renames, replaces)</li>
</ul>
<!--

- Enable traces
- Make the traces good (printers for tokens)
- Read the traces to get a sense for how the error recovery algorithm works
- Look at the generated `txt` file to learn what the states mean
  - idea: show an annotated trace file in the blog post? (what all the numbers mean)
  - will also show you which states have conflicts
  - (rules in `[...]` are the conflicts, the one in `[...]` is not taken)
- Compare successful parses with unsuccessful parses (vimdiff)
- Go to the place where the two diverge, and add an error case
- Almost all the rules you add are going to end with `error`, but some might not
- Make special error nodes/error names
- You can use `@1`, ... to access the location information of the error token (you have to
  change the parser to thread this information through it)
- The error token's location will be set to the location of the lookahead token that
  caused the syntax error to be discovered.
- Rule of thumb (in my experience) for resolving conflicts is that I want as many tokens
  in from of the `error` token in a rule as possible
  - going to throw away less of the program, but also going to make it less likely to
    conflict
  - most of my conflicts come from attempting to put `| error [...]` in two adjacent
    productions.
- Figure out what are the most common edits, and make every incremental edit along that
  path recover. PRs can show you the kinds of edits people show up with, if you need a
  starting point--imagine someone typed out every character of a PR's diff serially.
- Probably method calls and variable assignments are the most important (that's where
  people are most likely to be editing)

- Have some sort of fallback rule
- Know that the fallback rule is going to conflict with some of the things you'll want
  to build.
- Midrule actions are real rules. Just give a name to the midrule, then use that rule in
  the place where you wanted to.
- Can do tricks to get better error messages too
- Note: yyerror is going to be called every time (you can check the generated code to see
  that yyerror is called well before the error token is even shifted)
- Sometimes you might want to change the lexer to make things easier to detect
- Rants about ruby (keyword method names, def/end instead of curly braces)
- Don't be afraid to read the the generated parser's source. One way to do this is to set
  a breakpoint on a line in your parser file. Another way is to grep for your actions'
  code in the generated file.

-->
</main>
