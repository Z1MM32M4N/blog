<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-04-17 19:27:29 -0400">
<meta name="description" content="TODO">
<title>Parse Error Recovery in Sorbet: Part 4 – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  




</head>
<body>
  




  <header>
    <h1 class="title">Parse Error Recovery in Sorbet: Part 4</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2022-04-17 19:27:29 -0400">April 17, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<p>This is the fourth post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” With the last post, I talked about some tools and techniques that I’ve found useful while hacking on Sorbet’s <a href="https://www.gnu.org/software/bison/">Bison</a>-based parser. This post is going to continue that theme by explaining in a little more detail the primary tool Bison has for adding error recovery to a parser: the special <code>error</code> token.</p>
<p>You don’t <em>really</em> need to read the previous posts for this post to be useful, but if in case you want to queue them up to read later, here’s the list:</p>
<!-- more -->
<ul>
<li><a href="/error-recovery-part-1/">Part 1: Why Recover from Syntax Errors</a></li>
<li><a href="/error-recovery-part-2/">Part 2: What I Didn’t Do</a></li>
<li><a href="/error-recovery-part-3/">Part 3: Tools and Techniques for Debugging a (Bison) Parser</a></li>
<li><strong><a href="/error-recovery-part-4/">Part 4: Bison’s <code>error</code> Token</a></strong></li>
<li>(<em>coming soon</em>) Part 5: Backtracking, aka Lexer Hacks</li>
<li>(<em>coming soon</em>) Part 6: Falling Back on Indentation, aka More Lexer Hacks</li>
</ul>
<p>That being said, if you’re also trying to hack on a Bison parser to make it recover from errors, I hate to say it but this post is not going to be a substitute for the <a href="https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery">official docs on Error Recovery</a>, so you’re going to want to spend some time skimming that section of the docs if you haven’t already.</p>
<p><br></p>
<p>Bison doesn’t automatically recover from errors. When specifying a language’s grammar in Bison, it needs explicit annotations in various places to inform how it should recover from errors. This is unlike some parser tools like tree-sitter, which automatically generate the error recovery for for you, but which you don’t have a huge amount of control over. (Don’t let that trick you though, Bison still places substantial limitations on how you can recover from errors. a hand-written recursive descent parser is maximally flexible, though it’s also pretty for it to backfire. bison’s error recovery at least still checks for conflicts automatically (which means checking for ambiguities automatically))</p>
<p style="width: 50%; float: left; text-align: left;">
<a href="/error-recovery-part-3/">← Part 3: Tools and Techniques for Debugging a (Bison) Parser</a>
</p>
<p style="width: 50%; float: right; text-align: right;">
(<em>coming soon</em>) Part 5: Backtracking, aka Lexer Hacks →
</p>
<p><br></p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#TODO">TODO</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

