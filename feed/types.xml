<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/feed/types.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2022-12-31T18:25:31-05:00</updated><id>https://blog.jez.io/feed/types.xml</id><title type="html">Jake Zimmerman | Types</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Sorbet’s weird approach to exception handling</title><link href="https://blog.jez.io/sorbet-rescue-control-flow/" rel="alternate" type="text/html" title="Sorbet’s weird approach to exception handling" /><published>2022-09-04T23:12:12-04:00</published><updated>2022-09-04T23:12:12-04:00</updated><id>https://blog.jez.io/sorbet-rescue-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A quick post explaining why exception handling in Sorbet is weird, by way of a buggy program and some pretty pictures.]]></summary></entry><entry><title type="html">Control Flow in Sorbet is Syntactic</title><link href="https://blog.jez.io/syntactic-control-flow/" rel="alternate" type="text/html" title="Control Flow in Sorbet is Syntactic" /><published>2022-08-24T17:30:43-04:00</published><updated>2022-08-24T17:30:43-04:00</updated><id>https://blog.jez.io/syntactic-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[An exploration of why Sorbet lets control flow affect variables' types, but not methods' types.]]></summary></entry><entry><title type="html">Typed Errors in Sorbet</title><link href="https://blog.jez.io/typed-errors-sorbet/" rel="alternate" type="text/html" title="Typed Errors in Sorbet" /><published>2021-06-05T01:12:37-04:00</published><updated>2021-06-05T01:12:37-04:00</updated><id>https://blog.jez.io/typed-errors-sorbet</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Sorbet's union types in method returns provide a low-friction, high value way to model how methods can fail.]]></summary></entry><entry><title type="html">Sorbet Does Not Have Checked Exceptions</title><link href="https://blog.jez.io/union-types-checked-exceptions/" rel="alternate" type="text/html" title="Sorbet Does Not Have Checked Exceptions" /><published>2021-05-29T04:21:41-04:00</published><updated>2021-05-29T04:21:41-04:00</updated><id>https://blog.jez.io/union-types-checked-exceptions</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Sorbet does not support checked exceptions, and I don't think it ever should.]]></summary></entry><entry><title type="html">Mimicking Opaque Types in Sorbet</title><link href="https://blog.jez.io/mimicking-opaque-types-in-sorbet/" rel="alternate" type="text/html" title="Mimicking Opaque Types in Sorbet" /><published>2020-12-12T20:45:47-05:00</published><updated>2020-12-12T20:45:47-05:00</updated><id>https://blog.jez.io/mimicking-opaque-types-in-sorbet</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[I saw a neat trick the other day for how to combine a handful of Sorbet's existing features to mimic opaque types.]]></summary></entry><entry><title type="html">Singletons and Flow-Sensitive Typing</title><link href="https://blog.jez.io/singletons-and-flow-sensitive-typing/" rel="alternate" type="text/html" title="Singletons and Flow-Sensitive Typing" /><published>2020-09-25T22:00:58-04:00</published><updated>2020-09-25T22:00:58-04:00</updated><id>https://blog.jez.io/singletons-and-flow-sensitive-typing</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A look at how two type system features overlap in a surprising way.]]></summary></entry><entry><title type="html">Sorbet Does Not Have FixMe Comments</title><link href="https://blog.jez.io/sorbet-fixme-comment/" rel="alternate" type="text/html" title="Sorbet Does Not Have FixMe Comments" /><published>2020-02-12T02:18:40-05:00</published><updated>2020-02-12T02:18:40-05:00</updated><id>https://blog.jez.io/sorbet-fixme-comment</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html"><![CDATA[Sorbet has no way to ignore an error on a specific line with a magic comment, which makes things simple.]]></summary></entry><entry><title type="html">Intersection Types in Sorbet are Surprisingly Common</title><link href="https://blog.jez.io/intersection-types-common/" rel="alternate" type="text/html" title="Intersection Types in Sorbet are Surprisingly Common" /><published>2020-01-04T20:50:32-05:00</published><updated>2020-01-04T20:50:32-05:00</updated><id>https://blog.jez.io/intersection-types-common</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html"><![CDATA[Conventional knowledge is that union types are common and intersection types are rare. But actually that's not the case—intersection types show up in nearly every program Sorbet type checks thanks to control flow.]]></summary></entry><entry><title type="html">What makes type checking Ruby hard?</title><link href="https://blog.jez.io/ruby-mutation/" rel="alternate" type="text/html" title="What makes type checking Ruby hard?" /><published>2019-12-29T02:29:52-05:00</published><updated>2019-12-29T02:29:52-05:00</updated><id>https://blog.jez.io/ruby-mutation</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Mutation makes typechecking Ruby harder than many other programming languages. Most people will immediately think I mean mutation in the sense of `x += 1` or something—that's not what I'm referring to. In fact, that's the easy kind of mutation to model in a type system.]]></summary></entry><entry><title type="html">Notes on Continuations</title><link href="https://blog.jez.io/continuations-notes/" rel="alternate" type="text/html" title="Notes on Continuations" /><published>2019-06-18T21:03:13-04:00</published><updated>2019-06-18T21:03:13-04:00</updated><id>https://blog.jez.io/continuations-notes</id><author><name>Jake Zimmerman</name></author><category term="recitation" /><category term="plt" /><category term="types" /><summary type="html"><![CDATA[Some recitation notes on continuations from when I was a teaching assistant for 15-312 at CMU.]]></summary></entry></feed>