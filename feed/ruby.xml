<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/feed/ruby.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2024-02-15T13:51:08-05:00</updated><id>https://blog.jez.io/feed/ruby.xml</id><title type="html">Jake Zimmerman | Ruby</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Abstract singleton class methods are an abomination</title><link href="https://blog.jez.io/abstract-singleton-methods/" rel="alternate" type="text/html" title="Abstract singleton class methods are an abomination" /><published>2024-01-01T19:25:23-05:00</published><updated>2024-01-01T19:25:23-05:00</updated><id>https://blog.jez.io/abstract-singleton-methods</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Abstract singleton class methods do not belong in a well-behaved type system. Sorbet allows them anyways, which causes problems. Here's why they're bad and what to do instead.]]></summary></entry><entry><title type="html">Why don’t constructors have override checking?</title><link href="https://blog.jez.io/constructor-override-checking/" rel="alternate" type="text/html" title="Why don’t constructors have override checking?" /><published>2023-12-31T00:14:09-05:00</published><updated>2023-12-31T00:14:09-05:00</updated><id>https://blog.jez.io/constructor-override-checking</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A discussion of how constructors in typical typed object-oriented languages get away with not having to solve a problem that plagues Sorbet.]]></summary></entry><entry><title type="html">Inheritance in Ruby, in pictures</title><link href="https://blog.jez.io/inheritance-in-ruby/" rel="alternate" type="text/html" title="Inheritance in Ruby, in pictures" /><published>2023-12-28T15:31:20-05:00</published><updated>2023-12-28T15:31:20-05:00</updated><id>https://blog.jez.io/inheritance-in-ruby</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><category term="in-pictures" /><summary type="html"><![CDATA[A solid grasp of the tools Ruby provides for inheritance, like include and extend, helps write better code. But the concepts are often learned hastily—this post revisits them in depth.]]></summary></entry><entry><title type="html">A trick for generic constructors in Sorbet</title><link href="https://blog.jez.io/generic-constructor-trick/" rel="alternate" type="text/html" title="A trick for generic constructors in Sorbet" /><published>2023-10-28T16:09:02-04:00</published><updated>2023-10-28T16:09:02-04:00</updated><id>https://blog.jez.io/generic-constructor-trick</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><summary type="html"><![CDATA[There's a bit of a clever trick with T.all and T.attached_class that allows Sorbet to infer better types for constructors of generic classes.]]></summary></entry><entry><title type="html">Only return nil if given nil</title><link href="https://blog.jez.io/sorbet-nil-if-nil/" rel="alternate" type="text/html" title="Only return nil if given nil" /><published>2023-09-15T18:28:50-04:00</published><updated>2023-09-15T18:28:50-04:00</updated><id>https://blog.jez.io/sorbet-nil-if-nil</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><summary type="html"><![CDATA[A quick post showing how to write a type that people commonly want to be able to write, where the return type is only nil if the input was nilable.]]></summary></entry><entry><title type="html">Ruby’s Conditional Send is not Safe Navigation</title><link href="https://blog.jez.io/conditional-send/" rel="alternate" type="text/html" title="Ruby’s Conditional Send is not Safe Navigation" /><published>2023-09-03T11:06:27-04:00</published><updated>2023-09-03T11:06:27-04:00</updated><id>https://blog.jez.io/conditional-send</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="javascript" /><category term="programming" /><summary type="html"><![CDATA[A brief explanation of why Ruby calls x&.foo "conditional send" and not "safe navigation."]]></summary></entry><entry><title type="html">ActiveSupport’s Concern, in pictures</title><link href="https://blog.jez.io/concern-inheritance/" rel="alternate" type="text/html" title="ActiveSupport’s Concern, in pictures" /><published>2023-08-26T15:43:12-04:00</published><updated>2023-08-26T15:43:12-04:00</updated><id>https://blog.jez.io/concern-inheritance</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="in-pictures" /><summary type="html"><![CDATA[A series of pictures which show how Rails's ActiveSupport::Concern works to redefine what inheritance means in Ruby.]]></summary></entry><entry><title type="html">Why Sorbet needs T.let(…, T::Boolean)</title><link href="https://blog.jez.io/t-let-boolean/" rel="alternate" type="text/html" title="Why Sorbet needs T.let(…, T::Boolean)" /><published>2023-05-13T19:31:29-04:00</published><updated>2023-05-13T19:31:29-04:00</updated><id>https://blog.jez.io/t-let-boolean</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A short explanation of why Sorbet sometimes requires an explicit type annotation when initializing a variable whose type is changed in a loop.]]></summary></entry><entry><title type="html">Typing klass.new in Ruby with Sorbet</title><link href="https://blog.jez.io/typing-klass-new/" rel="alternate" type="text/html" title="Typing klass.new in Ruby with Sorbet" /><published>2023-02-19T22:34:27-05:00</published><updated>2023-02-19T22:34:27-05:00</updated><id>https://blog.jez.io/typing-klass-new</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html"><![CDATA[The straightforward attempt at writing a Sorbet signature for a method that calls `klass.new` doesn't work. The strategy that does work uses abstract methods, and so I'd like to walk through an extended example showing how to get such code to typecheck.]]></summary></entry><entry><title type="html">Ruby’s private keyword is weird</title><link href="https://blog.jez.io/ruby-private/" rel="alternate" type="text/html" title="Ruby’s private keyword is weird" /><published>2023-02-13T13:58:43-05:00</published><updated>2023-02-13T13:58:43-05:00</updated><id>https://blog.jez.io/ruby-private</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="scala" /><summary type="html"><![CDATA[Ruby's `private` keyword means something different compared to basically all other object-oriented languages. Most other languages don't even have a feature matching what Ruby calls `private`, but incredibly, Scala does, which it calls `protected[this]` (meaning "object-protected", as opposed to the normal `protected` keyword which is called "class-protected"). First let's review what `private` normally means, and then discuss what `private` in Ruby means (which will also amount to an explanation of what `protected[this]` means in Scala).]]></summary></entry></feed>