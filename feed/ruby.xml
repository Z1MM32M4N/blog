<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/feed/ruby.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2023-04-24T00:37:27-04:00</updated><id>https://blog.jez.io/feed/ruby.xml</id><title type="html">Jake Zimmerman | Ruby</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Typing klass.new in Ruby with Sorbet</title><link href="https://blog.jez.io/typing-klass-new/" rel="alternate" type="text/html" title="Typing klass.new in Ruby with Sorbet" /><published>2023-02-19T22:34:27-05:00</published><updated>2023-02-19T22:34:27-05:00</updated><id>https://blog.jez.io/typing-klass-new</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html"><![CDATA[The straightforward attempt at writing a Sorbet signature for a method that calls `klass.new` doesn't work. The strategy that does work uses abstract methods, and so I'd like to walk through an extended example showing how to get such code to typecheck.]]></summary></entry><entry><title type="html">Ruby’s private keyword is weird</title><link href="https://blog.jez.io/ruby-private/" rel="alternate" type="text/html" title="Ruby’s private keyword is weird" /><published>2023-02-13T13:58:43-05:00</published><updated>2023-02-13T13:58:43-05:00</updated><id>https://blog.jez.io/ruby-private</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="scala" /><summary type="html"><![CDATA[Ruby's `private` keyword means something different compared to basically all other object-oriented languages. Most other languages don't even have a feature matching what Ruby calls `private`, but incredibly, Scala does, which it calls `protected[this]` (meaning "object-protected", as opposed to the normal `protected` keyword which is called "class-protected"). First let's review what `private` normally means, and then discuss what `private` in Ruby means (which will also amount to an explanation of what `protected[this]` means in Scala).]]></summary></entry><entry><title type="html">Problems typing equality in Ruby</title><link href="https://blog.jez.io/problems-typing-ruby-equality/" rel="alternate" type="text/html" title="Problems typing equality in Ruby" /><published>2023-01-24T16:12:15-05:00</published><updated>2023-01-24T16:12:15-05:00</updated><id>https://blog.jez.io/problems-typing-ruby-equality</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="types" /><category term="ruby" /><summary type="html"><![CDATA[TypeScript has this really handy error that flags when it looks like two values of unrelated types are getting compared. I would love to build the same error into Sorbet, but there are two features which make that hard: custom overrides of `==` and subtyping. Here are some heuristics we might consider building in Sorbet, and why they don't work.]]></summary></entry><entry><title type="html">Sorbet’s weird approach to exception handling</title><link href="https://blog.jez.io/sorbet-rescue-control-flow/" rel="alternate" type="text/html" title="Sorbet’s weird approach to exception handling" /><published>2022-09-04T23:12:12-04:00</published><updated>2022-09-04T23:12:12-04:00</updated><id>https://blog.jez.io/sorbet-rescue-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A quick post explaining why exception handling in Sorbet is weird, by way of a buggy program and some pretty pictures.]]></summary></entry><entry><title type="html">Control Flow in Sorbet is Syntactic</title><link href="https://blog.jez.io/syntactic-control-flow/" rel="alternate" type="text/html" title="Control Flow in Sorbet is Syntactic" /><published>2022-08-24T17:30:43-04:00</published><updated>2022-08-24T17:30:43-04:00</updated><id>https://blog.jez.io/syntactic-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[An exploration of why Sorbet lets control flow affect variables' types, but not methods' types.]]></summary></entry><entry><title type="html">What would a type-aware Rubocop look like?</title><link href="https://blog.jez.io/type-aware-rubocop/" rel="alternate" type="text/html" title="What would a type-aware Rubocop look like?" /><published>2022-05-16T16:17:20-04:00</published><updated>2022-05-16T16:17:20-04:00</updated><id>https://blog.jez.io/type-aware-rubocop</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="rubocop" /><summary type="html"><![CDATA[From time to time, someone asks, "Would Sorbet ever allow defining some sort of type-aware lint rules?" My answer has usually been "no," for a couple of reasons.]]></summary></entry><entry><title type="html">Sorbet, Generics, and Parametricity</title><link href="https://blog.jez.io/sorbet-parametricity/" rel="alternate" type="text/html" title="Sorbet, Generics, and Parametricity" /><published>2022-02-18T02:59:55-05:00</published><updated>2022-02-18T02:59:55-05:00</updated><id>https://blog.jez.io/sorbet-parametricity</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="plt" /><summary type="html"><![CDATA[There's an interesting property in programming languages with generic types called "parametricity" that says all functions with a given generic type have to behave similarly, which is a powerful tool for understanding generic code.]]></summary></entry><entry><title type="html">Typed Errors in Sorbet</title><link href="https://blog.jez.io/typed-errors-sorbet/" rel="alternate" type="text/html" title="Typed Errors in Sorbet" /><published>2021-06-05T01:12:37-04:00</published><updated>2021-06-05T01:12:37-04:00</updated><id>https://blog.jez.io/typed-errors-sorbet</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Sorbet's union types in method returns provide a low-friction, high value way to model how methods can fail.]]></summary></entry><entry><title type="html">Sorbet Does Not Have Checked Exceptions</title><link href="https://blog.jez.io/union-types-checked-exceptions/" rel="alternate" type="text/html" title="Sorbet Does Not Have Checked Exceptions" /><published>2021-05-29T04:21:41-04:00</published><updated>2021-05-29T04:21:41-04:00</updated><id>https://blog.jez.io/union-types-checked-exceptions</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Sorbet does not support checked exceptions, and I don't think it ever should.]]></summary></entry><entry><title type="html">perf, Rinse, Repeat: Making the Sorbet Compiler faster</title><link href="https://blog.jez.io/perf-rinse-repeat/" rel="alternate" type="text/html" title="perf, Rinse, Repeat: Making the Sorbet Compiler faster" /><published>2021-05-23T20:43:22-04:00</published><updated>2021-05-23T20:43:22-04:00</updated><id>https://blog.jez.io/perf-rinse-repeat</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="debugging" /><category term="sorbet-compiler" /><summary type="html"><![CDATA[TODO]]></summary></entry></feed>