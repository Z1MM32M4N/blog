<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/feed/sorbet.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2023-02-13T14:21:46-05:00</updated><id>https://blog.jez.io/feed/sorbet.xml</id><title type="html">Jake Zimmerman | Sorbet</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Problems typing equality in Ruby</title><link href="https://blog.jez.io/problems-typing-ruby-equality/" rel="alternate" type="text/html" title="Problems typing equality in Ruby" /><published>2023-01-24T16:12:15-05:00</published><updated>2023-01-24T16:12:15-05:00</updated><id>https://blog.jez.io/problems-typing-ruby-equality</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="types" /><category term="ruby" /><summary type="html"><![CDATA[TypeScript has this really handy error that flags when it looks like two values of unrelated types are getting compared. I would love to build the same error into Sorbet, but there are two features which make that hard: custom overrides of `==` and subtyping. Here are some heuristics we might consider building in Sorbet, and why they don't work.]]></summary></entry><entry><title type="html">Making Sorbet more incremental</title><link href="https://blog.jez.io/making-sorbet-more-incremental/" rel="alternate" type="text/html" title="Making Sorbet more incremental" /><published>2023-01-09T09:19:36-05:00</published><updated>2023-01-09T09:19:36-05:00</updated><id>https://blog.jez.io/making-sorbet-more-incremental</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="language-servers" /><summary type="html"><![CDATA[← Return home My main focus last year was improving the Sorbet editor experience: making Sorbet feel snappier while powering language-aware editor features. The biggest improvements came from making Sorbet more incremental. By being smarter about skipping redundant work, we slashed the time it takes for Sorbet to do things like update the list of errors, populate autocompletion suggestions, and jump between definitions and usages.]]></summary></entry><entry><title type="html">Runtime type checking is great</title><link href="https://blog.jez.io/runtime-type-checking/" rel="alternate" type="text/html" title="Runtime type checking is great" /><published>2023-01-03T13:15:03-05:00</published><updated>2023-01-03T13:15:03-05:00</updated><id>https://blog.jez.io/runtime-type-checking</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[Checking type annotations at runtime—in addition to statically—is a net win in a gradual type system. In many cases runtime checking only _seems_ like it comes with more costs, when in fact they're the same costs, paid earlier. When there are net-new costs, there are ways to minimize them, and runtime-checked type annotations come with some key benefits that makes working in a gradually-typed codebase easier.]]></summary></entry><entry><title type="html">Some Old Sorbet Compiler Notes</title><link href="https://blog.jez.io/old-compiler-notes/" rel="alternate" type="text/html" title="Some Old Sorbet Compiler Notes" /><published>2022-12-10T17:38:00-05:00</published><updated>2022-12-10T17:38:00-05:00</updated><id>https://blog.jez.io/old-compiler-notes</id><author><name>Jake Zimmerman</name></author><category term="meta" /><category term="sorbet" /><category term="sorbet-compiler" /><summary type="html"><![CDATA[Today I'm publshing a few of my old, internal-facing notes about the Sorbet Compiler here to my blog.]]></summary></entry><entry><title type="html">Sorbet’s weird approach to exception handling</title><link href="https://blog.jez.io/sorbet-rescue-control-flow/" rel="alternate" type="text/html" title="Sorbet’s weird approach to exception handling" /><published>2022-09-04T23:12:12-04:00</published><updated>2022-09-04T23:12:12-04:00</updated><id>https://blog.jez.io/sorbet-rescue-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A quick post explaining why exception handling in Sorbet is weird, by way of a buggy program and some pretty pictures.]]></summary></entry><entry><title type="html">Control Flow in Sorbet is Syntactic</title><link href="https://blog.jez.io/syntactic-control-flow/" rel="alternate" type="text/html" title="Control Flow in Sorbet is Syntactic" /><published>2022-08-24T17:30:43-04:00</published><updated>2022-08-24T17:30:43-04:00</updated><id>https://blog.jez.io/syntactic-control-flow</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[An exploration of why Sorbet lets control flow affect variables' types, but not methods' types.]]></summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 4</title><link href="https://blog.jez.io/error-recovery-part-4/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 4" /><published>2022-06-06T01:56:49-04:00</published><updated>2022-06-06T01:56:49-04:00</updated><id>https://blog.jez.io/error-recovery-part-4</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html"><![CDATA[This is the fourth post in a series about things I've learned while making improvements to Sorbet's parser. With the last post, I talked about some tools and techniques that I've found useful while hacking on Sorbet's Bison-based parser. This post is going to continue that theme by explaining in a little more detail the primary tool Bison has for adding error recovery to a parser—the special `error` token.]]></summary></entry><entry><title type="html">With types, seeing is believing</title><link href="https://blog.jez.io/seeing-is-believing/" rel="alternate" type="text/html" title="With types, seeing is believing" /><published>2022-06-04T23:31:51-04:00</published><updated>2022-06-04T23:31:51-04:00</updated><id>https://blog.jez.io/seeing-is-believing</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="devprod" /><summary type="html"><![CDATA[You don't first convince everyone that types are good, and then start adopting types. Instead, you adopt types first and then let people see for themselves what types do for them.]]></summary></entry><entry><title type="html">What would a type-aware Rubocop look like?</title><link href="https://blog.jez.io/type-aware-rubocop/" rel="alternate" type="text/html" title="What would a type-aware Rubocop look like?" /><published>2022-05-16T16:17:20-04:00</published><updated>2022-05-16T16:17:20-04:00</updated><id>https://blog.jez.io/type-aware-rubocop</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="rubocop" /><summary type="html"><![CDATA[From time to time, someone asks, "Would Sorbet ever allow defining some sort of type-aware lint rules?" My answer has usually been "no," for a couple of reasons.]]></summary></entry><entry><title type="html">T::Enum Pros &amp;amp; Cons</title><link href="https://blog.jez.io/tenum-pro-con/" rel="alternate" type="text/html" title="T::Enum Pros &amp;amp; Cons" /><published>2022-03-17T19:13:16-04:00</published><updated>2022-03-17T19:13:16-04:00</updated><id>https://blog.jez.io/tenum-pro-con</id><author><name>Jake Zimmerman</name></author><category term="fragment" /><category term="sorbet" /><summary type="html"><![CDATA[A short note about why T::Enum is not great but also kinda great.]]></summary></entry></feed>