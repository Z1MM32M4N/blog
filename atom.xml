<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2022-06-06T16:50:21-04:00</updated><id>https://blog.jez.io/atom.xml</id><title type="html">Jake Zimmerman</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Parse Error Recovery in Sorbet: Part 4</title><link href="https://blog.jez.io/error-recovery-part-4/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 4" /><published>2022-06-06T01:56:49-04:00</published><updated>2022-06-06T01:56:49-04:00</updated><id>https://blog.jez.io/error-recovery-part-4</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-4/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bisons-error-recovery-algorithm&quot;&gt;Bison’s error recovery algorithm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#figure-out-the-most-common-edit-paths&quot;&gt;Figure out the most common edit paths&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-error-token-is-usually-last&quot;&gt;The &lt;code&gt;error&lt;/code&gt; token is usually last&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#consider-using-yyclearin&quot;&gt;Consider using &lt;code&gt;yyclearin&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#invent-a-special-ast-node-for-errors&quot;&gt;Invent a special AST node for errors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#read-the-generated-parsers-source&quot;&gt;Read the generated parser’s source&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the fourth post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” With the last post, I talked about some tools and techniques that I’ve found useful while hacking on Sorbet’s &lt;a href=&quot;https://www.gnu.org/software/bison/&quot;&gt;Bison&lt;/a&gt;-based parser. This post is going to continue that theme by explaining in a little more detail the primary tool Bison has for adding error recovery to a parser: the special &lt;code&gt;error&lt;/code&gt; token.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;You don’t &lt;em&gt;really&lt;/em&gt; need to read the previous posts for this post to be useful, but if in case you want to queue them up to read later, here’s the list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That being said, if you’re also trying to hack on a Bison parser to make it recover from errors, I hate to say it but this post is not going to be a substitute for the &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery&quot;&gt;official docs on Error Recovery&lt;/a&gt;. You’re going to want to spend some time skimming that section of the docs if you haven’t already.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Bison needs explicit annotations within a grammar to provide syntax error recovery. This is in contrast with parser tools like &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt;,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;If you’re curious, I’ve written some assorted &lt;a href=&quot;/categories/#tree-sitter&quot;&gt;thoughts on tree-sitter&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; which automatically include error recovery. Concretely, Bison requires inserting special &lt;code&gt;error&lt;/code&gt; tokens in production rules that should participate in error recovery.&lt;/p&gt;
&lt;p&gt;To get the most out of Bison’s error recovery mode, it’s crucial to understand what it’s actually doing with those &lt;code&gt;error&lt;/code&gt; tokens.&lt;/p&gt;
&lt;h1 id=&quot;bisons-error-recovery-algorithm&quot;&gt;Bison’s error recovery algorithm&lt;/h1&gt;
&lt;p&gt;There’s a vague description of the algorithm &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery&quot;&gt;in the docs&lt;/a&gt;, but I found that I had to make the algorithm more explicit before I could understand what was and wasn’t possible.&lt;/p&gt;
&lt;p&gt;At a high level, this is what Bison does:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;It encounters an error. By which we mean: neither shifting the lookahead token nor reducing the current stack is a valid action given the current lookahead token).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It reports the error by calling the (user-defined) &lt;code&gt;yyerror&lt;/code&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;In C++ parsers, this is called &lt;code&gt;parser::error&lt;/code&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; function.&lt;/p&gt;
&lt;p&gt;Importantly, this function is &lt;strong&gt;always&lt;/strong&gt; called.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Other parser generators, for example &lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;Happy&lt;/a&gt; for Haskell do not necessarily report an error when an &lt;code&gt;error&lt;/code&gt; token is produced.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Even if a production rule eventually consumes the error token and successfully recovers from the parse error, an error will have been reported.&lt;/p&gt;
&lt;p&gt;Also note that it’s impossible&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Sorbet gets around this limitation by appending parse errors to a temporary queue, only flushing them to the user once parsing has completed. Sorbet sometimes &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1976-L1981&quot;&gt;mutates&lt;/a&gt; the last element of the queue inside semantic actions to improve the error message with specific information about the parse failure.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to delay calling &lt;code&gt;yyerror&lt;/code&gt; until it’s clear that no production rule matched the &lt;code&gt;error&lt;/code&gt; token, since the &lt;code&gt;yyerror&lt;/code&gt; function is called even before attempting to &lt;strong&gt;shift&lt;/strong&gt; the &lt;code&gt;error&lt;/code&gt; token, less reduce a rule that uses it. For similar reasons, this makes it more complicated to allow the eventual error rule to provide extra context on the error message.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, Bison looks to see it can shift the &lt;code&gt;error&lt;/code&gt; token, given what the current stack contents and parser state are. It leaves the current lookahead token untouched for the time being.&lt;/p&gt;
&lt;p&gt;If it can shift the &lt;code&gt;error&lt;/code&gt; token, it does so. Bison has finished recovering from the syntax error. The parse continues, using the untouched lookahead token.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If it &lt;strong&gt;can’t&lt;/strong&gt; shift the &lt;code&gt;error&lt;/code&gt; token, Bison &lt;strong&gt;completely discards&lt;/strong&gt; the object on the top of the stack.&lt;/p&gt;
&lt;p&gt;To make that clear, if the parser stack looked something like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# def foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#   x.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;stack &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;def&amp;#39;&lt;/span&gt;, identifier, &lt;span class=&quot;ch&quot;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, expression, &lt;span class=&quot;ch&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;lookahead &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and Bison found no matching error production rule, it would throw away the &lt;code&gt;'.'&lt;/code&gt; token that it had already shifted onto the parser stack:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;stack &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;def&amp;#39;&lt;/span&gt;, identifier, &lt;span class=&quot;ch&quot;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, expression&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;lookahead &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then loop back to the previous step, checking to see whether it’s now possible to shift the &lt;code&gt;error&lt;/code&gt; token. This process repeats until Bison has gobbled up the whole stack or some production rule consumes the error token.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If Bison’s &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Tracking-Locations&quot;&gt;Location Tracking&lt;/a&gt; feature is on (which allows using &lt;code&gt;@1&lt;/code&gt;, &lt;code&gt;@2&lt;/code&gt;, etc. in semantic actions to get the locations associated with components of the rule), it’s worth knowing how the &lt;code&gt;error&lt;/code&gt; token’s location is set. Bison sets the error location to span from the last thing it discarded from the stack all the way to the lookahead token that induced the error. If it discarded nothing, then the range would just be the location of the lookahead token.&lt;/p&gt;
&lt;p&gt;Using the example above, if the &lt;code&gt;'.'&lt;/code&gt; token was the only token Bison needed to discard, the error token’s location would be set to span from that &lt;code&gt;'.'&lt;/code&gt; token all the way to the &lt;code&gt;'end'&lt;/code&gt; lookahead token.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most Bison grammars have a catch all &lt;code&gt;| error&lt;/code&gt; production somewhere, like this one in Sorbet’s parser:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode numberSource yacc numberLines hl-4&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot;&gt;&lt;/a&gt;stmts: &lt;span class=&quot;kw&quot;&gt;%empty&lt;/span&gt; { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot;&gt;&lt;/a&gt;     | stmt { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot;&gt;&lt;/a&gt;     | stmts newline stmt { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot;&gt;&lt;/a&gt;     | error { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet’s parser. &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L653-L657&quot;&gt;View on GitHub →&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The nice thing about a rule like this is that it provides coarse grained error recovery at a high level without requiring special cases for every production in the grammar. It works because no matter what happens to be on the stack, it’ll always eventually match (as long as we’re in the parser state corresponding to &lt;code&gt;stmts&lt;/code&gt;) because eventually Bison will have discarded the entire stack.&lt;/p&gt;
&lt;p&gt;It’ll definitely throw away a lot of stuff, but at least it’ll let the parse continue instead of failing to produce any parse result. For example, if there was no parse error further down in the file, and the error occurred near the top, this rule gets us lots of error recovery for little work. But yeah, it’s not great to throw that much stuff away.&lt;/p&gt;
&lt;p&gt;We’re going to want to put more &lt;code&gt;error&lt;/code&gt; tokens in more targeted places. For that, I’ve come up with a handful of strategies to make the most of Bison’s error recovery.&lt;/p&gt;
&lt;h1 id=&quot;figure-out-the-most-common-edit-paths&quot;&gt;Figure out the most common edit paths&lt;/h1&gt;
&lt;p&gt;Even though Bison requires a lot of &lt;code&gt;error&lt;/code&gt; annotations to get good parse results, you can get good bang for your buck by figuring out the most common edit paths. For example, here’s every intermediate edit when the user adds a keyword argument to a Ruby method:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x) &lt;span class=&quot;co&quot;&gt;# contents before edit&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x,)&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, y)&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, y:)&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, &lt;span class=&quot;wa&quot;&gt;y: &lt;/span&gt;y) &lt;span class=&quot;co&quot;&gt;# edit finished&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ideally there’s an &lt;code&gt;error&lt;/code&gt; production for every intermediate state, because adding a keyword argument to a method call is common. On the other hand, you can likely get away not adding rules for uncommon syntax errors.&lt;/p&gt;
&lt;p&gt;If you want, you can take the guesswork out of what’s common and what’s not by measuring, assuming you have a corpus of syntax errors you can sample from.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;For example, we gather usage metrics from every Sorbet user at Stripe.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; The semi-automated approach to measurement, which is what I’ve personally used: when there’s a syntax error and the parse result is “bad” according to some heuristic (like: the parse is completely empty, or there was a partial parse result but it was too bad to find any completion suggestions at the user’s cursor), log the bad source buffer to a file, and then go triage the logged files, fixing the most common errors first.&lt;/p&gt;
&lt;p&gt;The annoying part about that approach is the manual triage work of opening up the logged buffers, identifying which part of the file had the parse error, and blaming it to some section of the parser. An idea I’ve had (but not implemented) for a more automatic approach: when there’s a syntax error that’s never recovered (or that’s handled by some “catch all” production rule), log the lookahead token and parser state where the error happened. Cross reference parser states with what’s in the &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Understanding&quot;&gt;textual report&lt;/a&gt; on the parser to get approximate line numbers in the grammar that need to be updated. States that show up the most commonly are the ones in need of dedicated &lt;code&gt;error&lt;/code&gt; rules.&lt;/p&gt;
&lt;h1 id=&quot;the-error-token-is-usually-last&quot;&gt;The &lt;code&gt;error&lt;/code&gt; token is usually last&lt;/h1&gt;
&lt;p&gt;With the most common edit paths in hand, I’ve usually had the most success by following two tips for crafting the error rules.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Put the &lt;code&gt;error&lt;/code&gt; token as the very last token in the production rule. It can be tempting to try writing rules like this, where the &lt;code&gt;error&lt;/code&gt; token is followed by some other stuff:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode yacc&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  | args &amp;#39;,&amp;#39; arg { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  | args &amp;#39;,&amp;#39; error arg  { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sometimes this works, but in my experience, it’s much easier to reason about conflicts when the &lt;code&gt;error&lt;/code&gt; token is the last token in a rule.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Put the &lt;code&gt;error&lt;/code&gt; token &lt;strong&gt;only&lt;/strong&gt; after terminals. There’s almost never conflicts in the grammar when putting the &lt;code&gt;error&lt;/code&gt; token after a &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;'='&lt;/code&gt; token, but there usually are when putting it after something like an &lt;code&gt;args&lt;/code&gt; non-terminal.&lt;/p&gt;
&lt;p&gt;Intuitively this makes sense, because the &lt;code&gt;args&lt;/code&gt; production itself probably has a bunch of rules that have consume an &lt;code&gt;error&lt;/code&gt; token at the end, causing the conflicts. The non-terminal might even have a catch-all &lt;code&gt;| error&lt;/code&gt; rule.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In situations where I haven’t been able to trivially follow these rules, I’ve usually been able to go into the preceding non-terminal rule (like &lt;code&gt;args&lt;/code&gt;) and sprinkle &lt;code&gt;error&lt;/code&gt; tokens judiciously inside &lt;em&gt;that&lt;/em&gt; rule to allow following these rules.&lt;/p&gt;
&lt;p&gt;Unfortunately, there have definitely been times where that hasn’t worked, which will be the topic of a future post. &lt;!-- TODO(jez) Link to the indentation post here, when written --&gt;&lt;/p&gt;
&lt;h1 id=&quot;consider-using-yyclearin&quot;&gt;Consider using &lt;code&gt;yyclearin&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;After recovering from a parse error using the &lt;code&gt;error&lt;/code&gt; token, the lookahead token will still be set to whatever it was that caused the error to happen in the first place.&lt;/p&gt;
&lt;p&gt;If for whatever reason you think that attempting to continue the parse with that token would just screw things up again, you can use the &lt;code&gt;yyclearin&lt;/code&gt; macro&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-5&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-5&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;In the C++ skeleton, this is available using &lt;code&gt;yyla.clear()&lt;/code&gt; instead.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to clear out the lookahead token, which will cause Bison to request another token from the lexer.&lt;/p&gt;
&lt;p&gt;We’re not currently using this in Sorbet because I’ve replaced most places where it might have been useful with some even more powerful techniques (discussed in a future part), but I figured I may as well mention it. &lt;!-- TODO(jez) Link to part 5 lexer hacks here --&gt;&lt;/p&gt;
&lt;h1 id=&quot;invent-a-special-ast-node-for-errors&quot;&gt;Invent a special AST node for errors&lt;/h1&gt;
&lt;p&gt;Consider this parse error:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rule for parsing an assignment with no error looks like this, and produces an &lt;code&gt;assign&lt;/code&gt; node in the AST:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode numberSource yacc numberLines&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet’s parser. &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1285-L1288&quot;&gt;View on GitHub →&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;To handle the error case, we still have the &lt;code&gt;lhs&lt;/code&gt; and the &lt;code&gt;'='&lt;/code&gt;, but we don’t have the &lt;code&gt;arg_rhs&lt;/code&gt;. The parser will detect that &lt;code&gt;'end'&lt;/code&gt; is not a valid &lt;code&gt;arg_rhs&lt;/code&gt;, and shift the &lt;code&gt;error&lt;/code&gt; token for us to recognize:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode numberSource yacc numberLines hl-5 hl-7&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot;&gt;&lt;/a&gt;   | lhs &amp;#39;=&amp;#39; error&lt;/span&gt;
&lt;span id=&quot;cb8-6&quot;&gt;&lt;a href=&quot;#cb8-6&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb8-7&quot;&gt;&lt;a href=&quot;#cb8-7&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, &lt;span class=&quot;co&quot;&gt;/* ... ? ... */&lt;/span&gt;);&lt;/span&gt;
&lt;span id=&quot;cb8-8&quot;&gt;&lt;a href=&quot;#cb8-8&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb8-9&quot;&gt;&lt;a href=&quot;#cb8-9&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s unclear what to use in place of &lt;code&gt;$3&lt;/code&gt;, because &lt;code&gt;error&lt;/code&gt; doesn’t have an associated semantic value. To fill the void, we can invent a special AST &lt;code&gt;error_node&lt;/code&gt; type.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-6&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-6&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Slight fib; Sorbet actually creates a &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/Builder.cc#L911-L913&quot;&gt;constant literal node&lt;/a&gt; with a magic name for backwards compatibility reasons.&lt;br /&gt;
&lt;br /&gt;
“What’s up with that &lt;code&gt;endPos&lt;/code&gt; stuff?”&lt;br /&gt;
There’s some discussion in the full source on GitHub.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode numberSource yacc numberLines hl-7 hl-8&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb9-1&quot;&gt;&lt;a href=&quot;#cb9-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb9-2&quot;&gt;&lt;a href=&quot;#cb9-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb9-3&quot;&gt;&lt;a href=&quot;#cb9-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb9-4&quot;&gt;&lt;a href=&quot;#cb9-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb9-5&quot;&gt;&lt;a href=&quot;#cb9-5&quot;&gt;&lt;/a&gt;   | lhs &amp;#39;=&amp;#39; error&lt;/span&gt;
&lt;span id=&quot;cb9-6&quot;&gt;&lt;a href=&quot;#cb9-6&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb9-7&quot;&gt;&lt;a href=&quot;#cb9-7&quot;&gt;&lt;/a&gt;         auto enode = driver.build.error_node(self, @2.endPos(), @3.endPos());&lt;/span&gt;
&lt;span id=&quot;cb9-8&quot;&gt;&lt;a href=&quot;#cb9-8&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, enode);&lt;/span&gt;
&lt;span id=&quot;cb9-9&quot;&gt;&lt;a href=&quot;#cb9-9&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb9-10&quot;&gt;&lt;a href=&quot;#cb9-10&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet’s parser. &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1289-L1303&quot;&gt;View on GitHub →&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This special AST node allows phases downstream of the parser to pretend the parse succeeded. In particular, it’s easy to detect where the syntax error occurred when responding to completion requests (which is important, because in the above example, the syntax error is also where the user’s cursor is).&lt;/p&gt;
&lt;h1 id=&quot;read-the-generated-parsers-source&quot;&gt;Read the generated parser’s source&lt;/h1&gt;
&lt;p&gt;To close, I’d like to point out that everything in this post that I didn’t find in the official docs, I taught myself by browsing the source code generated by Bison. Despite being generated, it’s actually pretty well commented, and with a bit of elbow grease you might even be able to get your IDE to let you use jump to def in it.&lt;/p&gt;
&lt;p&gt;Some nice things about browsing the source:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It’s never out of sync with the version of Bison you’re using (unlike the official docs, which only track the latest version).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can see exactly what happens and in what order. For example, reading the source is how I convinced a colleague that no, using &lt;code&gt;error&lt;/code&gt; productions did not mean we would be preventing errors from being reported. It was faster to read the source than attempt to find whether the docs mentioned this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can see what fun, undocumented APIs are actually available to you. For example, the docs talk about &lt;code&gt;yylval&lt;/code&gt; and &lt;code&gt;yylloc&lt;/code&gt;, which are supposed to store the semantic value and location of the lookahead token. But in the C++ skeleton, these things have been renamed (without documentation) to &lt;code&gt;yyla.value&lt;/code&gt; and &lt;code&gt;yyla.location&lt;/code&gt;, respectively.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reading the generated parser’s source code reinforced my understanding of Bison’s parsing algorithm and made it easier to debug when things went wrong.&lt;/p&gt;
&lt;p&gt;All this being said, I’ve run into plenty of limitations when attempting to improve Sorbet’s parser. In the next post, I’ll explain one such example, why using &lt;code&gt;error&lt;/code&gt; tokens alone wasn’t enough, and how I tweaked Sorbet’s lexer to aid the parser in error recovery.&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;← Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks →
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">← Return home This is the fourth post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” With the last post, I talked about some tools and techniques that I’ve found useful while hacking on Sorbet’s Bison-based parser. This post is going to continue that theme by explaining in a little more detail the primary tool Bison has for adding error recovery to a parser: the special error token.</summary></entry><entry><title type="html">With types, seeing is believing</title><link href="https://blog.jez.io/seeing-is-believing/" rel="alternate" type="text/html" title="With types, seeing is believing" /><published>2022-06-04T23:31:51-04:00</published><updated>2022-06-04T23:31:51-04:00</updated><id>https://blog.jez.io/seeing-is-believing</id><content type="html" xml:base="https://blog.jez.io/seeing-is-believing/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;From time to time I get asked something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I write a lot of Ruby at work. In past projects I’ve really enjoyed and benefited from a statically typed language. But on my current team, people aren’t as excited.&lt;/p&gt;
&lt;p&gt;What can I say to them to get them to change their mind, so we can start using types in Ruby?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In my experience, this framing is backwards. You don’t first convince everyone that types are good, and then start adopting types. Instead, you put them to sleep, enter their dream, and plant the idea that types are good—ah, wait, wrong storyline. Instead, you adopt types first and then let people see for themselves what types do for them. The people opposed to types won’t be convinced to start liking them by anything you can tell them or ask them to read.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;In all of the cases where I’ve seen Sorbet be adopted, the process looked like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;An ambitious team (or even individual) who really, really wants types in Ruby does the work to get an initial pass at adoption passing in CI.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;This can be somewhat of a grind, and is all too often done during nights and weekends, though high-trust teams do a good job of carving out time for experiments like this.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Importantly, the initial pass does a minimal amount of work, so that it doesn’t take long to get here.&lt;/p&gt;
&lt;p&gt;For &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt;, that means only checking at &lt;a href=&quot;https://sorbet.org/docs/static#file-level-granularity-strictness-levels&quot;&gt;&lt;code&gt;# typed: false&lt;/code&gt;&lt;/a&gt;, which enables Sorbet in every file but only does the most basic checks, like checking for syntax errors and typos in constant literals.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That initial version sits silently in the codebase over a period of days or weeks. When new changes introduce new type errors, it pings the enthusiastic types adoption team; they figure out whether it caught a real bug or whether the tooling could be improved (for example, for syncing type definitions for third-party code). It does &lt;strong&gt;not&lt;/strong&gt; ping the unsuspecting user yet.&lt;/p&gt;
&lt;p&gt;When we did this to roll out Sorbet at Stripe, this manifested as a job that ran on the &lt;code&gt;master&lt;/code&gt; branch&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Limiting to &lt;code&gt;master&lt;/code&gt;, instead of all branches, is a convenient way to get a sense for whether enforcing types would have actually blocked someone. It’s far more likely that in-progress branches with type failures also have failing tests, and that the type failure would have done a &lt;em&gt;better&lt;/em&gt; job at alerting the user to the problem.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; in CI, but if it failed it would send a Slack message to us, not tell the user that their change was broken.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This process repeats until the pings are only &lt;strong&gt;high-signal&lt;/strong&gt; pings. When there’s an error, it represents actual bugs (or maybe it doesn’t error at all: remember, most files are still &lt;code&gt;# typed: false&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Double check at this point that it’s easy to configure whatever editors your team uses to put the errors directly in the editor. You likely already did this for yourself while working on the initial migration.&lt;/p&gt;
&lt;p&gt;Sorbet exposes an &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;LSP server&lt;/a&gt; via the &lt;code&gt;--lsp&lt;/code&gt; command line flag to allow integrating with arbitrary editors, and also publishes a &lt;a href=&quot;https://sorbet.org/docs/vscode&quot;&gt;VS Code extension&lt;/a&gt; for people who want a one-click, low-config solution.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The time has come to enforce that the codebase type checks in CI. You and your team effectively beta-tested it on behalf of the organization and decided it wasn’t going to bring development to a halt. Flip the switch, and if need be, remind people that this is still an experiment. “We can try it out for a while and re-evaluate later—it’s still the same language.”&lt;/p&gt;
&lt;p&gt;Most code still has no explicit type annotations and limited type checking (due to the &lt;code&gt;# typed: false&lt;/code&gt;), but now more teams can experiment with enabling stricter type checking in the sections of the codebase they own.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;This is the whole point of “gradual” in &lt;a href=&quot;https://sorbet.org/docs/gradual&quot;&gt;gradual type checking&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, the important part: &lt;strong&gt;show&lt;/strong&gt; people how good Sorbet is, don’t tell them. Fire up Sorbet on your codebase, delete something, and watch as the error list populates instantly. Jump to definition on a constant. Try autocompleting something.&lt;/p&gt;
&lt;p&gt;Notice how we’re &lt;strong&gt;not&lt;/strong&gt; showing off the type system and how expressive it might be. We’re showing off what the type system actually lets them do! Be more productive at their job.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In my experience trying to bring static types to Ruby users, seeing really is believing. I’ve seen this exact same story or slight variations of it play out in just about every successful adoption case.&lt;/p&gt;
&lt;p&gt;While it’s true that the type checker is going to prevent people from writing valid code they used to be able to write, every gradual type system has &lt;a href=&quot;https://sorbet.org/docs/troubleshooting#escape-hatches&quot;&gt;escape hatches&lt;/a&gt; to opt out of those checks in some way. The argument that people fond of type checkers want to make is that the instant feedback and powerful editor features a type checker provides outshine the times when the type checker gets in the way, but it’s impossible to make that argument with words alone.&lt;/p&gt;
&lt;p&gt;One final, important note: &lt;strong&gt;be supportive&lt;/strong&gt;. Advertise a single place for anyone to ask questions and get quick responses.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Like, actually quick. “Notify for new Slack every message” quick. If you queue questions into some ticketing system and respond tomorrow, people will lose patience with &lt;em&gt;types overall&lt;/em&gt; not just with you.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Admit that this will likely lead to being overworked for a bit until it takes off. In the long run as adoption and familiarity spread, other teammates will start to help out with the evangelism as the benefits spread outward.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="devprod" /><summary type="html">← Return home From time to time I get asked something like this:</summary></entry><entry><title type="html">Is tree-sitter good enough?</title><link href="https://blog.jez.io/tree-sitter-limitations/" rel="alternate" type="text/html" title="Is tree-sitter good enough?" /><published>2022-05-30T04:43:46-04:00</published><updated>2022-05-30T04:43:46-04:00</updated><id>https://blog.jez.io/tree-sitter-limitations</id><content type="html" xml:base="https://blog.jez.io/tree-sitter-limitations/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: no, or at the very least, “not for every use case.” (Though I really wish it were for the use cases I have, because it would save me a lot of work.)&lt;/p&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;I’m guessing you already know what tree-sitter is because you clicked on the title. If you clicked because you were hoping to find out: &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt; is a relatively&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Is it still new? The GitHub repo has commits dating back to 2013, though I only first heard about it in 2017. It still has a feeling of newness about it, but I digress.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; new project which aims to make writing fast, error-tolerant parsers take less work. To do that, it provides both pre-built parsers for common programming languages and a toolkit for building new parsers. It’s known for use in various GitHub features by way of their &lt;a href=&quot;https://github.com/github/semantic&quot;&gt;semantic&lt;/a&gt; tool, which powers the code navigation tooltips that you sometimes see on GitHub.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;The semantic repo actually has a &lt;a href=&quot;https://github.com/github/semantic/blob/master/docs/why-tree-sitter.md&quot;&gt;short overview&lt;/a&gt; of why they chose tree-sitter, along with some drawbacks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For a lot of projects, tree-sitter is really nice! &lt;em&gt;Especially&lt;/em&gt; for projects where the quality of the parser is less important than the quantity of languages supported. For example: an editor syntax highlighter. It’s more important that the editor highlight lots of languages’ syntax than it is that every language is highlighted perfectly. Another example: building something like &lt;a href=&quot;https://www.emacswiki.org/emacs/ParEdit&quot;&gt;ParEdit&lt;/a&gt; for arbitrary languages. Or providing jump-to-def that’s mostly better than plain-text code search.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Another neat use case, from work: every time a commit is pushed to an approved PR, the approval is dismissed, unless (using tree-sitter) the CI system detects that the parse tree hasn’t changed. This spares comment and formatting changes the toil of a re-review.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; For a lot of these applications it’s actually &lt;em&gt;completely fine&lt;/em&gt; if there’s a flagrant bug in one of the grammars, because the project is still so useful in all the other languages.&lt;/p&gt;
&lt;p&gt;But when the goals are flipped—it has to work for exactly one language, and the quality of the parser is paramount—tree-sitter becomes less attractive. There are two questions I would pose to anyone curious about using tree-sitter for their parser:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Is serving autocompletion requests a key use cases?&lt;/p&gt;
&lt;p&gt;Serving autocompletion requests requires an unnaturally high parse fidelity, even when the buffer is ridiculed with syntax errors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How much do you care about crafting custom messages for syntax errors?&lt;/p&gt;
&lt;p&gt;Customizing syntax error messages becomes context-dependent very quickly. It’s easy to maintain that context when your parser allows running arbitrary code, and hard when the parser is constrained to a declarative DSL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If either of these goals are important, I’d recommend rolling your own parser (using the technique of your choice). It comes down to flexibility: a tree-sitter grammar, with it’s declarative specification, provides a lot of neat features for free (like error recovery), but places a ceiling on possibilities for future improvement.&lt;/p&gt;
&lt;p&gt;Let me show some examples.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It’s entirely possible that I’ve just been &lt;em&gt;really&lt;/em&gt; unlucky, and that the problems I’ve found are all fixable with a few bug reports and a little ingenuity. But if it’s going to take ingenuity anyways, isn’t that the same as writing a parser myself?&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; The snippets of code below are exactly the kinds of programs that people type in their editors, but which tree-sitter doesn’t parse well enough. You can follow along on the &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/playground&quot;&gt;tree-sitter online playground&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Let’s start with a Ruby program, alongside its parse result:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines hl-8 hl-9&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot;&gt;&lt;/a&gt;        identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 4]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here’s what a comparable, syntactically-valid parse looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines hl-8 hl-9 hl-10&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot;&gt;&lt;/a&gt;        call [1, 2] - [1, 7]&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot;&gt;&lt;/a&gt;          receiver: identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot;&gt;&lt;/a&gt;          method: identifier [1, 4] - [1, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the good parse, tree-sitter produces a &lt;code&gt;call&lt;/code&gt; node. In the bad parse, it just produces a &lt;code&gt;block&lt;/code&gt; that has a list containing two elements. Ideally, what we’d see here is something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call
  receiver: identifier
  method: ERROR&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which tells us that there was a method call, what the receiver of the method call was so we know where to start looking for methods to autocomplete, and that the syntax error was localized to the method call.&lt;/p&gt;
&lt;p&gt;There’s a similar problem with constant accesses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;g &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;cn&quot;&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;program [0, 0] - [6, 0]&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;        constant [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 5]&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot;&gt;&lt;/a&gt;      body: block [3, 10] - [5, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot;&gt;&lt;/a&gt;        scope_resolution [4, 2] - [4, 6]&lt;/span&gt;
&lt;span id=&quot;cb7-9&quot;&gt;&lt;a href=&quot;#cb7-9&quot;&gt;&lt;/a&gt;          scope: constant [4, 2] - [4, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-10&quot;&gt;&lt;a href=&quot;#cb7-10&quot;&gt;&lt;/a&gt;          name: constant [4, 5] - [4, 6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;… and a similar problem with &lt;code&gt;@&lt;/code&gt; (the start of an instance variable access), and with &lt;code&gt;x =&lt;/code&gt; (the start of an assignment).&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Maybe this example was a little contrived? Comparable programs written in JavaScript actually parse the good way, so maybe that’s just an indictment of tree-sitter-ruby, not tree-sitter itself.&lt;/p&gt;
&lt;p&gt;But this next snippet reproduces in both Ruby and JavaScript:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb8-6&quot;&gt;&lt;a href=&quot;#cb8-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;program [0, 0] - [6, 0]
  class_declaration [0, 0] - [5, 1]
    name: identifier [0, 6] - [0, 7]
    body: class_body [0, 8] - [5, 1]
      member: method_definition [1, 2] - [4, 3]
        name: property_identifier [1, 2] - [1, 5]
        parameters: formal_parameters [1, 5] - [1, 7]
        body: statement_block [1, 8] - [4, 3]
          expression_statement [3, 2] - [3, 9]
            call_expression [3, 2] - [3, 7]
              function: identifier [3, 2] - [3, 5]
              arguments: arguments [3, 5] - [3, 7]
            ERROR [3, 8] - [3, 9]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make it more obvious why this parse tree is not great, it’s basically the same parse tree as produced by this program:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;#cb10-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;#cb10-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;#cb10-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-4&quot;&gt;&lt;a href=&quot;#cb10-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    {&lt;/span&gt;
&lt;span id=&quot;cb10-5&quot;&gt;&lt;a href=&quot;#cb10-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb10-6&quot;&gt;&lt;a href=&quot;#cb10-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Even though &lt;code&gt;bar() { ... }&lt;/code&gt; is valid method syntax, there’s no definition of a method called &lt;code&gt;bar&lt;/code&gt; in the parse. Instead, the parser thinks that there was a &lt;strong&gt;function call&lt;/strong&gt; to a function named &lt;code&gt;bar&lt;/code&gt; that doesn’t exist.&lt;/li&gt;
&lt;li&gt;The syntax error shows up after the imagined call to &lt;code&gt;bar&lt;/code&gt; (associated with the &lt;code&gt;{&lt;/code&gt; immediately after the call to &lt;code&gt;bar&lt;/code&gt;), not associated with the &lt;code&gt;foo&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the user’s cursor was inside the &lt;code&gt;bar&lt;/code&gt; method and asking for completion results, we’d be forced to serve them completion results as though their cursor was inside the half-formed &lt;code&gt;foo&lt;/code&gt; method, which produces completely wrong results.&lt;/p&gt;
&lt;p&gt;This behavior is not unique to JavaScript. I’ve reproduced it almost verbatim in Ruby and Java, and partially in most other tree-sitter parsers (C#, C++, Rust, etc.).&lt;/p&gt;
&lt;p&gt;The best behavior here would be to point out that the curly braces are mismatched,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Indeed, that’s &lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=872bd946a8789aba9d49e07aef614819&quot;&gt;exactly the error&lt;/a&gt; on a comparable Rust example. (Rust’s parser is hand-written.)&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and then recover assuming that the user fixed that mismatch, preserving the &lt;code&gt;bar&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;I could turn this into a post full of weird code snippets and poor parse results, but that’s not useful. What I’m trying to show is that when the demands are, “The one specific language I care about has lots of idiosyncratic but common parse errors that I want to handle well,” then prepare to devote a substantial amount of time to tweaking anyways. I prefer doing that in a setting that gives me maximum flexibility, so that I can be as clever as I need to eke out good parse results.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong, I still think tree-sitter is a great project with a neat new idea. I also haven’t shown how surprisingly good tree-sitter was on a lot of the examples I tried! All I’m saying is that tree-sitter comes with tradeoffs, and that it’s not useful to respond to every complaint about an existing parser with, “If you just used tree-sitter, your problems would go away,” because that’s not true. For a certain class of parsing problems, tree-sitter is not quite good enough.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If I’ve overlooked something, please let me know and I’ll happily update this post (and maybe even start using tree-sitter in my projects).&lt;/em&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="parsing" /><category term="tree-sitter" /><summary type="html">← Return home tl;dr: no, or at the very least, “not for every use case.” (Though I really wish it were for the use cases I have, because it would save me a lot of work.)</summary></entry><entry><title type="html">What would a type-aware Rubocop look like?</title><link href="https://blog.jez.io/type-aware-rubocop/" rel="alternate" type="text/html" title="What would a type-aware Rubocop look like?" /><published>2022-05-16T16:17:20-04:00</published><updated>2022-05-16T16:17:20-04:00</updated><id>https://blog.jez.io/type-aware-rubocop</id><content type="html" xml:base="https://blog.jez.io/type-aware-rubocop/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should every AST node (i.e., every expression) have a type associated with it?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just variables is enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even if this “give me the type of a variable” API works, is it enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet + linter?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-do-people-actually-want-this-for&quot;&gt;… what do people actually want this for?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#is-there-anything-like-this-in-another-language&quot;&gt;… is there anything like this in another language?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#competing-priorities-tend-to-win-out&quot;&gt;Competing priorities tend to win out&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-in-the-future&quot;&gt;“Maybe in the future…”&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;&lt;em&gt;This post represents my opinions at a point in time. It’s not necessarily the views of my team or my employer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;From time to time, someone asks, “Would &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt; ever allow defining some sort of type-aware lint rules?” The answer has usually been “no,” for a couple of reasons.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The biggest open question is that it’s not 100% clear what use cases people have in mind. Most commonly people imagine “the full &lt;a href=&quot;https://rubocop.org/&quot;&gt;Rubocop&lt;/a&gt; API, but with types,” but this is underspecified, in my opinion.&lt;/p&gt;
&lt;h3 id=&quot;should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should every AST node (i.e., every expression) have a type associated with it?&lt;/h3&gt;
&lt;p&gt;This would be particularly hard to support, because Sorbet aggressively simplifies the AST from the start to the end of its pipeline. The Rubocop AST has something like 100 node types. Sorbet immediately simplifies this into an AST that only has 30 or so node types, then subsequently keeps refining the AST until it only has about 15. The thing Sorbet type checks looks nothing like the AST that you’d want if you were trying to write a linter, because so much of it has been desugared, rewritten, or simplified.&lt;/p&gt;
&lt;p&gt;Then finally right before type checking, Sorbet actually abandons the (tree-based) AST, preferring to use a &lt;strong&gt;control flow graph&lt;/strong&gt; (CFG) for type checking! A CFG is no longer tree-based&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It’s a graph, where nodes are basic blocks and edges are control flow jumps between those blocks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;, which breaks a lot of the assumptions people make about what’s easy and hard to build in a linter rule.&lt;/p&gt;
&lt;p&gt;Because Sorbet type checks a CFG only, there’s no tree-based structure inside Sorbet that has types. &lt;em&gt;Maybe&lt;/em&gt; it’s possible to take the type-annotated CFG and use it to reconstruct some sort of typed AST, but that sounds brittle and error prone.&lt;/p&gt;
&lt;p&gt;And finally, in the CFG Sorbet doesn’t associate types with expressions, only types with variables! This works because the act of building a CFG assigns all intermediate expressions’ results to a variable and then only dealing with variables from then on.&lt;/p&gt;
&lt;h3 id=&quot;maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just variables is enough?&lt;/h3&gt;
&lt;p&gt;This would likely be somewhat easier to implement, because Sorbet already does maintain environments mapping variables to their types.&lt;/p&gt;
&lt;p&gt;However, these data structures are expensive to maintain and therefore not long-lived.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Sorbet’s LSP editor integration gets around this by re-typechecking an entire method every time the user hovers over a variable. When these hover requests come as (infrequent) requests from the user, this is fine because Sorbet is already initialized. Powering a linter this way would either require that the Sorbet server be initialized for variable type every request (crazy slow), or somehow kept around persistently (brittle).&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Unlike Sorbet’s symbol table, which exists indefinitely after creation, the environments that track variable types only last as long as is required to type check a single method.&lt;/p&gt;
&lt;p&gt;Maybe there could be an API like “please give me the type of the variable with this name,” but again this would be tricky, because chances are the lint rule author wants to build the lint rule on some tree-based data structure, and Sorbet only has the CFG. So there would additionally need to be some mapping between environments (basic blocks) and AST variable nodes, which again sounds pretty tricky and likely to break some assumptions.&lt;/p&gt;
&lt;h3 id=&quot;even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even if this “give me the type of a variable” API works, is it enough?&lt;/h3&gt;
&lt;p&gt;Knowing the type of a variable on its own isn’t very useful. The most common questions you want ask of a type are:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Is is this type a subtype of this other type?&lt;/li&gt;
&lt;li&gt;If a method with a given name is called on a receiver of this type, what are the &lt;em&gt;list&lt;/em&gt; of methods that would be dispatched to? (It’s a list because the receiver could be a union type.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The answer to (1) requires having the entire symbol table on hand (lots of memory). The answer to (2) is subtle and complicated—Sorbet spends &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/core/types/calls.cc&quot;&gt;about 4,000 lines of code&lt;/a&gt; answering it—and &lt;em&gt;also&lt;/em&gt; requires having the symbol table on hand.&lt;/p&gt;
&lt;p&gt;So it’s probably not enough to just, e.g., return some JSON representation of one of Sorbet’s types. It’d also require having some structured representation of Sorbet’s symbol table, which brings us to our next question:&lt;/p&gt;
&lt;h3 id=&quot;rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet + linter?&lt;/h3&gt;
&lt;p&gt;So far I’ve kind of assumed that we want to start with an existing linter (Rubocop) and just add types. But what we’ve seen so far is that the things we’d need to get types into Rubocop basically amount to exporting almost all of Sorbet’s internal data structures.&lt;/p&gt;
&lt;p&gt;Sorbet’s internal data structures change all the time as we fix bugs, add features, and refactor things. Having to commit to a stable API for every internal data structure mentioned above would slow down how quickly we can improve the rest of Sorbet.&lt;/p&gt;
&lt;p&gt;So maybe instead of exporting an API that Rubocop could use, we should build a linter into Sorbet? This just has different tradeoffs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet has to reinvent the wheel on linter APIs (e.g., are lint rules specified in Ruby code with some new API? Does it attempt to copy as much of Rubocop’s API as possible? What happens when there are papercut differences between what Sorbet’s linter allows and what Rubocop does?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How are rules distributed? Are the rules written in Ruby, and Sorbet runs the Ruby code with some sort of FFI to expose the internal data structures? Does Sorbet embed some other scripting language for writing rules? Do people write rules as shared objects which Sorbet dynamically loads, akin to Ruby native extensions? Are the rules committed directly into the Sorbet repo, like how custom DSL and rewriter passes are right now?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;what-do-people-actually-want-this-for&quot;&gt;… what do people actually want this for?&lt;/h3&gt;
&lt;p&gt;Whenever someone asks for a type-aware linter, here are a sampling of the answers given when I ask, “What are you really trying to do?”&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;“Ban calling &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt;, because I just spent half an hour tracking down a bug where I had a &lt;code&gt;T.nilable(Symbol)&lt;/code&gt; that I called &lt;code&gt;to_s&lt;/code&gt; on and got the wrong answer.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Update the &lt;a href=&quot;https://docs.rubocop.org/rubocop-performance/cops_performance.html#performanceinefficienthashsearch&quot;&gt;Performance/InefficientHashSearch&lt;/a&gt; rule to only act on &lt;code&gt;Hash&lt;/code&gt; values. Not all calls like &lt;code&gt;xs.values.include?&lt;/code&gt; can be safely rewritten to &lt;code&gt;xs.value?&lt;/code&gt;.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Do type-aware codemods, for example change all calls to &lt;code&gt;x.merchant_&lt;/code&gt; to something like &lt;code&gt;ClassOfX.get_merchant(x.id)&lt;/code&gt;”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Enforce that all methods returning &lt;code&gt;T::Boolean&lt;/code&gt; have names ending in &lt;code&gt;?&lt;/code&gt;”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It’s not clear that “just” building a type-aware linter necessarily solves these problems.&lt;/p&gt;
&lt;p&gt;Doing (1) is hard—should we allow &lt;code&gt;Object#to_s&lt;/code&gt;? You could still accidentally call &lt;code&gt;to_s&lt;/code&gt; on something that’s &lt;code&gt;nil&lt;/code&gt; inside a method that accepts &lt;code&gt;Object&lt;/code&gt; if you do. Also there are sometimes valid cases to call &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt; that no type system will help you discover! This feature seems similar to the &lt;code&gt;#poison&lt;/code&gt; pragma in C and C++, but there the language makes it easier because &lt;code&gt;#include&lt;/code&gt;’ed files are explicitly ordered, and it’s easy to say “after this point, the identifier is poisoned.” (Also I’m not even sure how &lt;code&gt;#poison&lt;/code&gt; works with methods, not just C functions, where things like inheritance become a problem.)&lt;/p&gt;
&lt;p&gt;Doing (2) relies on that hard feature we chatted about above: types for arbitrary expressions, not just variables. If we don’t have types for arbitrary expressions, detecting this case in a cop requires essentially re-inventing Sorbet’s inference algorithm: &lt;code&gt;input.map {...}.filter {...}.values.include?&lt;/code&gt;. We mentioned the difficulty in exposing types for arbitrary expressions above.&lt;/p&gt;
&lt;p&gt;The situation for (3) is something I can really relate to, as there are a lot of cases where I can imagine this being useful. But rather than build this as a lint rule, we’ve historically wanted to build these as IDE-mode code actions: the API is much more constrained (no internal data structures needed) and the IDE already has the type information in memory. Sorbet supports a limited number of refactorings now, but mostly because we haven’t spent time on it. It’s reasonable to assume we’ll build many more refactorings in the future.&lt;/p&gt;
&lt;p&gt;And finally, things like (4) can &lt;em&gt;already&lt;/em&gt; be done in Rubocop. It’s slightly more annoying (you have to write the code to parse Sorbet signature annotations manually) but Sorbet signature annotations are very stable. Their syntax changes infrequently, and when it does, it’s usually minor and/or backwards compatible changes.&lt;/p&gt;
&lt;h3 id=&quot;is-there-anything-like-this-in-another-language&quot;&gt;… is there anything like this in another language?&lt;/h3&gt;
&lt;p&gt;Here’s one of Sorbet’s explicit design principles:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;As simple as possible, but powerful enough&lt;/p&gt;
&lt;p&gt;Overall, we are not strong believers in super-complex type systems. They have their place, and we need a fair amount of expressive power to model (enough) real Ruby code, but all else being equal we want to be simpler. We believe that such a system scales better, and—most importantly—is easier for our users to learn &amp;amp; understand.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;— &lt;a href=&quot;https://github.com/sorbet/sorbet/#sorbet-user-facing-design-principles&quot;&gt;Sorbet user-facing design principles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another way to read this is, “we let other people blaze trails, and then copy their good ideas.”&lt;/p&gt;
&lt;p&gt;&lt;del&gt;This question comes up often enough that it makes me want to imagine that some sort of similar tool exists for other dynamically typed languages? But as far as I’m aware, no sort of type-aware linter exists for TypeScript, Flow, or Mypy.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;&lt;del&gt;If you know of a comparable tool, please do share!&lt;/del&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Not having any sort of frame of reference makes it hard to gauge expectations people have when asking for a tool like this.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update, 2022-05-18&lt;/strong&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Thanks to Steve Dignam for pointing out that not only does C# have static analysis APIs, but that TypeScript does as well, along with an ecosystem of type-aware lint rules.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; There &lt;em&gt;are&lt;/em&gt; type-aware static analysis tools for C# and TypeScript. Both languages were designed by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Anders_Hejlsberg&quot;&gt;same person&lt;/a&gt;, so maybe this isn’t surprising. Unfortunately for Sorbet, they were architected to support static analysis tooling &lt;a href=&quot;https://en.wikipedia.org/wiki/Roslyn_%28compiler%29#:~:text=Roslyn%20was%20designed%20with%20that%20intent%20from%20the%20beginning.&quot;&gt;from the beginning&lt;/a&gt;. Sorbet’s current architecture was instead designed for batch type checking performance on large monorepos,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;All things considered, it’s actually quite good at this.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and IDE support was grafted on later. Exposing hackable APIs has so far not been considered.&lt;/p&gt;
&lt;p&gt;For example, TypeScript offers a &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API&quot;&gt;compiler API&lt;/a&gt;, which is then used by the TypeScript ESLint project, which allows defining &lt;a href=&quot;https://typescript-eslint.io/docs/development/custom-rules#type-checking&quot;&gt;custom type-aware lint rules&lt;/a&gt;. What can we learn from this project?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The TypeScript compiler API does not have any sort of backwards compatibility guarantee, so breaking changes are published from time to time.&lt;/li&gt;
&lt;li&gt;It appears that all TypeScript functionality can be accessed behind the API, including instantiating a stateful object representing the type checker, running the type checker end-to-end on a project, spawning an LSP server, etc.&lt;/li&gt;
&lt;li&gt;The way custom lint rules are written is by converting between ESLint’s AST node type and TypeScript’s AST node type. The TypeScript compiler APIs then allow asking for the type of an AST (i.e., expression). I haven’t confirmed, but this leads me to believe that TypeScript itself is doing typechecking on the AST (maybe with some auxiliary structures to track control flow), not on a CFG like Sorbet, which makes it easier to present the kind of API that makes sense in a lint rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It’s interesting to &lt;a href=&quot;https://cs.github.com/typescript-eslint/typescript-eslint?q=%22requiresTypeChecking%3A+true%22&quot;&gt;browse the rules that require type information&lt;/a&gt; to get a sense for what’s possible. Things like &lt;code&gt;strict-boolean-expressions&lt;/code&gt; and &lt;code&gt;no-floating-promises&lt;/code&gt; are examples of non-trivial lints using type information.&lt;/p&gt;
&lt;p&gt;I have spent very limited time looking into how things work exactly, so it’s possible I’m misrepresenting the ideas. In any case, I personally still draw the same conclusion: clearly people in the TypeScript community derive value from building type-aware lint rules, and TypeScript is well-architected to enable this. As mentioned in previous sections, Sorbet’s current architecture does not present the same conveniences.&lt;/p&gt;
&lt;h3 id=&quot;competing-priorities-tend-to-win-out&quot;&gt;Competing priorities tend to win out&lt;/h3&gt;
&lt;p&gt;When attempting to build this feature, we’d of course have to judge the cost of what we’d have to give up.&lt;/p&gt;
&lt;p&gt;Overwhelmingly, the requests people have about Sorbet are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please fix shape and tuple types.&lt;/li&gt;
&lt;li&gt;Please fix generics (classes and methods).&lt;/li&gt;
&lt;li&gt;Please make Sorbet work faster on large codebases, especially in IDE mode.&lt;/li&gt;
&lt;li&gt;Please build more refactoring tools. If IntelliJ can do it, I’d like Sorbet to do it too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far, these requests have taken priority over greenfield projects, including things like a type-aware linter.&lt;/p&gt;
&lt;h3 id=&quot;maybe-in-the-future&quot;&gt;“Maybe in the future…”&lt;/h3&gt;
&lt;p&gt;Those are my current thoughts on the topic. Obviously, a lot of these reasons are just “it’s hard,” and maybe for someone else those things would be easy. Others are just selfish, “it’s convenient for us to not have to think about compatibility,” and so they’re easy to disagree with. Some of them are, “there’s no clear answer to this question,” and sometimes you can wave those away by just picking &lt;em&gt;any&lt;/em&gt; answer and living with it, rather than searching for the best.&lt;/p&gt;
&lt;p&gt;So while I don’t think that Sorbet would &lt;em&gt;never&lt;/em&gt; get some sort of type-aware linter, so far there are many factors that present a pretty high barrier to building something like this. Hopefully this post sheds some light on why a type-aware linter for Sorbet does not currently exist.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="rubocop" /><summary type="html">← Return home This post represents my opinions at a point in time. It’s not necessarily the views of my team or my employer.</summary></entry><entry><title type="html">T::Enum Pros &amp;amp; Cons</title><link href="https://blog.jez.io/tenum-pro-con/" rel="alternate" type="text/html" title="T::Enum Pros &amp;amp; Cons" /><published>2022-03-17T19:13:16-04:00</published><updated>2022-03-17T19:13:16-04:00</updated><id>https://blog.jez.io/tenum-pro-con</id><content type="html" xml:base="https://blog.jez.io/tenum-pro-con/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-is-verbose.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;👎 It’s hard to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;🚀 Every IDE feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-guards-against-basically-all-typos.&quot;&gt;🙊 &lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#it-requires-being-intentional.&quot;&gt;🤝 It requires being intentional.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-easy-to-search-for.&quot;&gt;🕵️ It’s easy to search for.&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;One feature that Sorbet doesn’t have&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Yet. The biggest limitation is just that Sorbet’s approach to type inference is designed to run fast and be simple to understand, sometimes sacrificing power.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;… but actually Sorbet already has these types internally 😅 It’s just that it doesn’t have syntax for people to write them in type annotations. And lo, it’s &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Ax%20%3D%20%3Adefault%0A%0A1.times%20do%0A%20%20%23%20Sorbet%20does%20not%20report%20an%20error%20here%0A%20%20%23%20%28it%20would%20have%20to%20start%20doing%20so%29%0A%20%20x%20%3D%20%3Afirst%0Aend%0A%0AT.reveal_type%28x%29%20%23%20Sorbet%20shows%20the%20wrong%20type%20here%0A%0A%23%20Sorbet%20can&amp;#39;t%20tell%20the%20difference%20bewteen%20a%20hash%20literal%0A%23%20with%20a%20variable%20key%20versus%20with%20a%20symbol%20literal%20key%0A%23%20at%20the%20time%20that%20inference%20happens.%0AT.reveal_type%28%7Bx%20%3D%3E%20nil%7D%29%0AT.reveal_type%28%7B%3Adefault%20%3D%3E%20nil%7D%29&quot;&gt;because they’re buggy&lt;/a&gt;, but for the things where Sorbet needs to use them internally we can intentionally work around the known bugs, so it hasn’t been worth the pain to fix.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; but gets requested frequently is support for literal string and symbol types. Something like &lt;code&gt;T.any(:left, :right)&lt;/code&gt;, which is a type that allows either the symbol literal &lt;code&gt;:left&lt;/code&gt; or &lt;code&gt;:right&lt;/code&gt;, but no other &lt;code&gt;Symbol&lt;/code&gt;s much less other types of values. The closest that Sorbet has to this right now is typed enums:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  enums &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TypeScript, Flow, and Mypy all have literal types. You probably have felt yourself wanting this. I don’t really have to explain why they’re nice. But I’ll do it anyways, just to prove that I hear you.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/h2&gt;
&lt;p&gt;That’s a fancy way of saying we’d like to be able to write &lt;code&gt;T.any(:left, :right)&lt;/code&gt; in any type annotation, without first having to pre-declare the new union type to the world. I spoke at length about how the existence of ad hoc union types make handling exceptional conditions &lt;a href=&quot;/union-types-checked-exceptions/&quot;&gt;more pleasant than checked exceptions&lt;/a&gt;, so I’m right there with you in appreciating that feature.&lt;/p&gt;
&lt;h2 id=&quot;tenum-is-verbose.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/h2&gt;
&lt;p&gt;Even if you wanted to pre-declare the enum type. Consider:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:left&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:right&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Boom. One line, no boilerplate. Wouldn’t that be nice?&lt;/p&gt;
&lt;h2 id=&quot;its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;👎 It’s hard to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/h2&gt;
&lt;p&gt;This comes up so frequently that there’s &lt;a href=&quot;https://sorbet.org/docs/tenum#defining-one-enum-as-a-subset-of-another-enum&quot;&gt;an FAQ entry&lt;/a&gt; about it. The answer is yet more verbosity and boilerplate.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;So I hear you. But I wanted to say a few things in defense of &lt;code&gt;T::Enum&lt;/code&gt;, because I think that despite how nice it might be to have literal types (and again, we may yet build them one day), there are still &lt;em&gt;a lot of points&lt;/em&gt; in favor of &lt;code&gt;T::Enum&lt;/code&gt; as it exists today.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;🚀 Every IDE feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;T::Enum&lt;/code&gt;s are just normal constants. Sorbet supports finding all constant references, renaming constants, autocompleting constant names, jumping to a constant’s definition, hovering over a constant to see its documentation comment. Also all of those features work on both the enum class itself and each individual enum value.&lt;/p&gt;
&lt;p&gt;We could &lt;em&gt;maybe&lt;/em&gt; support completion for symbol literals in limited circumstances, but it would be the first of its kind in Sorbet. Same goes for rename, and maybe find all references. Jump to Definition I guess would want to jump not to the actual definition, but rather to the signature that specified the literal type? It’s weird.&lt;/p&gt;
&lt;h2 id=&quot;tenum-guards-against-basically-all-typos.&quot;&gt;🙊 &lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/h2&gt;
&lt;p&gt;Even in &lt;code&gt;# typed: false&lt;/code&gt; files! Even when calling methods that take don’t have signatures, or that have loose signatures like &lt;code&gt;Object&lt;/code&gt;! Incidentally, this is basically the same reason why find all references can work so well.&lt;/p&gt;
&lt;h2 id=&quot;it-requires-being-intentional.&quot;&gt;🤝 It requires being intentional.&lt;/h2&gt;
&lt;p&gt;Code gets out of hand really quickly when people try to cutely interpolate strings into other strings that hold meaning. I’d much rather deal with this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;left_or_right, up_or_down&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;than this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you try to do this with &lt;code&gt;T::Enum&lt;/code&gt; you get strings that look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;#&amp;lt;LeftOrRight::Left&amp;gt;__#&amp;lt;UpOrDown::Up&amp;gt;&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which confuses people, so they ask how to do the thing they’re trying to do, which is a perfect opportunity to talk them down from that cliff. If people decide that yes, this really is the API we need, we can be intentional about it with &lt;code&gt;.serialize&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;its-easy-to-search-for.&quot;&gt;🕵️ It’s easy to search for.&lt;/h2&gt;
&lt;p&gt;This is a small one, but I’ll mention it anyways. It’s quick to search the Sorbet docs for &lt;code&gt;T::Enum&lt;/code&gt; and get to the right page. It’s similarly easy to find examples of it being used in a given codebase, to learn from real code. There’s no unique piece of syntax in &lt;code&gt;T.any(:left, :right)&lt;/code&gt; that is a surefire thing to search for.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="fragment" /><category term="sorbet" /><summary type="html">← Return home One feature that Sorbet doesn’t have[^yet][^but-actually] but gets requested frequently is support for literal string and symbol types. Something like T.any(:left, :right), which is a type that allows either the symbol literal :left or :right, but no other Symbols much less other types of values. The closest that Sorbet has to this right now is typed enums:</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 3</title><link href="https://blog.jez.io/error-recovery-part-3/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 3" /><published>2022-02-28T00:25:56-05:00</published><updated>2022-02-28T00:25:56-05:00</updated><id>https://blog.jez.io/error-recovery-part-3</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-3/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#read-the-docs&quot;&gt;Read the docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enable-traces-and-make-them-good&quot;&gt;Enable traces, and make them good&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#diff-traces-for-good-and-bad-parses&quot;&gt;Diff traces for good and bad parses&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the third post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Previously I discussed high level questions like why it’s an important problem for Sorbet to solve and some approaches I decided not to take. This post switches gears to focus on specific tips and techniques I found useful while making parser changes.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With that all out of the way, let’s dive into the tips.&lt;/p&gt;
&lt;h1 id=&quot;read-the-docs&quot;&gt;Read the docs&lt;/h1&gt;
&lt;p&gt;Haha! You probably thought that by Googling for things you’d be able to find something that lets you avoid reading the official docs. But it’s boring for me to repeat everything that’s in the docs, and honestly the Bison and Ragel docs are rather comprehensive as far as software documentation goes these days:&lt;/p&gt;
&lt;p&gt;→ &lt;a href=&quot;https://www.colm.net/files/ragel/ragel-guide-6.9.pdf&quot;&gt;Ragel User Guide&lt;/a&gt;&lt;br /&gt;
→ &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html&quot;&gt;Bison User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But I will give you some tips for &lt;strong&gt;how&lt;/strong&gt; to read the docs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You ~always want the “HTML entirely on one web page” version of the Bison docs—it’s way easier to ⌘F around one page.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bison actually gets new, interesting features from version to version. Double check that the version of the docs you’re reading actually match the version of Bison you’re using. I haven’t found an easy way to read old Bison docs online, so I usually just &lt;code&gt;grep&lt;/code&gt; for things in the docs’ sources:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ git clone https://github.com/akimd/bison
❯ git checkout v3.3.2
❯ grep -r &amp;#39;error.*token&amp;#39; doc/
doc/bison.texi:error.  If there is a @samp{..} token before the next
doc/bison.texi:value of the error token is 256, unless you explicitly assigned 256
... many more results ...&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’ve found it valuable to actually take my time while reading the Bison docs. I’ve found a lot of things that turned out to be relevant later on because I took the time to read parts of the docs that didn’t look immediately relevant.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But that’s enough soapbox standing, now we return to regularly scheduled tips.&lt;/p&gt;
&lt;h1 id=&quot;enable-traces-and-make-them-good&quot;&gt;Enable traces, and make them good&lt;/h1&gt;
&lt;p&gt;Before I started working on this project, I treated Sorbet’s parser like a black box. In the spirit of “&lt;a href=&quot;https://blog.nelhage.com/post/computers-can-be-understood/&quot;&gt;Computers can be understood&lt;/a&gt;,” the first thing I did was enable traces for our parser. Easy enough:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define the &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Tracing&quot;&gt;&lt;code&gt;parse.trace&lt;/code&gt;&lt;/a&gt; variable in the grammar&lt;/li&gt;
&lt;li&gt;Call &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#index-set_005fdebug_005flevel-on-parser&quot;&gt;&lt;code&gt;set_debug_level&lt;/code&gt;&lt;/a&gt; on the generated parser&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s &lt;a href=&quot;https://github.com/sorbet/sorbet/pull/4985/files?w=1#diff-63fada7036ffcba42e6615c3b85615cb81d47aafbf88122a552a34fb799c06b5R17&quot;&gt;the PR in Sorbet&lt;/a&gt;, which might help to make these two steps more concrete.&lt;/p&gt;
&lt;p&gt;The trace output looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet --trace-parser -e &amp;#39;def foo; end&amp;#39;
Starting parse
Entering state 0
Reading a token: Next token is token &amp;quot;def&amp;quot; ()
Shifting token &amp;quot;def&amp;quot; ()
Entering state 4
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 184

...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is somewhat useful as is, but it can be better. First, all the trailing &lt;code&gt;()&lt;/code&gt; on the “Next token is …” lines are present because there aren’t any &lt;code&gt;%printer&lt;/code&gt;’s for those tokens–we can easily get the trace to not only show that it read a &lt;code&gt;tIDENTIFIER&lt;/code&gt; token, but also what the name of that variable was. After adding one for &lt;code&gt;tIDENTIFIER&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%printer { yyo &amp;lt;&amp;lt; $$-&amp;gt;view(); } tIDENTIFIER&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;$$-&amp;gt;view();&lt;/code&gt; bit calls the &lt;code&gt;view&lt;/code&gt; method on Sorbet’s token type, converting it to a string. Now our traces look better:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet --trace-parser -e &amp;#39;def foo; end&amp;#39;
Starting parse
Entering state 0
Reading a token: Next token is token &amp;quot;def&amp;quot; ()
Shifting token &amp;quot;def&amp;quot; ()
Entering state 4
Reading a token: Next token is token tIDENTIFIER (foo)
Shifting token tIDENTIFIER (foo)
Entering state 184
Reading a token: Next token is token &amp;quot;;&amp;quot; ()
Reducing stack by rule 125 (line 1140):
   $1 = token tIDENTIFIER (foo)
-&amp;gt; $$ = nterm fname ()
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far I’ve been adding these &lt;code&gt;%printer&lt;/code&gt;s only as I encounter the tokens that show up, mostly because I’m too lazy to exhaustively define printers for all the tokens—Ruby has a lot of tokens. You’ll note that Bison even lets you register &lt;code&gt;%printer&lt;/code&gt;s for non-terminals (not pictured, but the same mechanism). You could use this to, like, print the currently reduced AST for that non-terminal, or some other summary.&lt;/p&gt;
&lt;p&gt;The next step is to actually understand what these traces mean, because it looks like there’s a lot of magic names and numbers. The long answer is that you’ll have to look in the textual report that Bison generates about all the intermediate states in your parser. This is documented in the &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Understanding&quot;&gt;Understanding Your Parser&lt;/a&gt; section of the Bison docs.&lt;/p&gt;
&lt;p&gt;But if you’re impatient, there’s a bit of a short cut that can work in many cases.&lt;/p&gt;
&lt;h1 id=&quot;diff-traces-for-good-and-bad-parses&quot;&gt;Diff traces for good and bad parses&lt;/h1&gt;
&lt;p&gt;This code is a syntax error in Ruby:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo(x,); &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bison has a fancy &lt;code&gt;error&lt;/code&gt; token that we can use to recover from cases like this, but it’s hard to know where to add that &lt;code&gt;error&lt;/code&gt; token into the grammar. Printing the trace file would likely help us figure out where, but even when we’re staring at the trace file it’s not entirely clear.&lt;/p&gt;
&lt;p&gt;Luckily there’s a short cut:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Record a parser trace for the invalid parse.&lt;/li&gt;
&lt;li&gt;“Fix” the file so that it parses by only adding tokens, and record a trace for that parse.
&lt;ul&gt;
&lt;li&gt;This ensures that all the tokens present in the bad parse are also present in the good parse.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff&lt;/code&gt; (or &lt;code&gt;vimdiff&lt;/code&gt;) the two traces, and add an error recovery rule to the place where the trace differs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In our case, I want &lt;code&gt;def foo(x,); end&lt;/code&gt; to parse as if the user had properly written two arguments, so that I can record the fact that the user started to introduce a second argument. I’ll record a trace for the program &lt;code&gt;def foo(x, y); end&lt;/code&gt;, and diff it. The diff looks like this:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode numberSource diff numberLines hl-30 hl-31 hl-32 hl-33 hl-34&quot;&gt;&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot;&gt;&lt;/a&gt;❯ sorbet --trace-parser -e &amp;#39;def foo(x,); end&amp;#39; 2&amp;gt; trace-bad.txt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot;&gt;&lt;/a&gt;  sorbet --trace-parser -e &amp;#39;def foo(x, y); end&amp;#39; 2&amp;gt; trace-good.txt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot;&gt;&lt;/a&gt;  diff -u trace-bad.txt trace-good.txt&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;--- trace-bad.txt       2022-01-16 14:40:51.168977798 -0800&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;+++ trace-good.txt      2022-01-16 14:40:51.728976581 -0800&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;@@ -53,45 +53,201 @@&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-7&quot;&gt;&lt;a href=&quot;#cb6-7&quot;&gt;&lt;/a&gt; Next token is token &amp;quot;,&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-8&quot;&gt;&lt;a href=&quot;#cb6-8&quot;&gt;&lt;/a&gt; Shifting token &amp;quot;,&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-9&quot;&gt;&lt;a href=&quot;#cb6-9&quot;&gt;&lt;/a&gt; Entering state 752&lt;/span&gt;
&lt;span id=&quot;cb6-10&quot;&gt;&lt;a href=&quot;#cb6-10&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reading a token: Next token is token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-11&quot;&gt;&lt;a href=&quot;#cb6-11&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Shifting token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-12&quot;&gt;&lt;a href=&quot;#cb6-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 541&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-13&quot;&gt;&lt;a href=&quot;#cb6-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 660 (line 3400):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-14&quot;&gt;&lt;a href=&quot;#cb6-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-15&quot;&gt;&lt;a href=&quot;#cb6-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_norm_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-16&quot;&gt;&lt;a href=&quot;#cb6-16&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-17&quot;&gt;&lt;a href=&quot;#cb6-17&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 559&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-18&quot;&gt;&lt;a href=&quot;#cb6-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 661 (line 3408):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-19&quot;&gt;&lt;a href=&quot;#cb6-19&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_norm_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-20&quot;&gt;&lt;a href=&quot;#cb6-20&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg_asgn ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-21&quot;&gt;&lt;a href=&quot;#cb6-21&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-22&quot;&gt;&lt;a href=&quot;#cb6-22&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 560&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-23&quot;&gt;&lt;a href=&quot;#cb6-23&quot;&gt;&lt;/a&gt; Reading a token: Next token is token &amp;quot;)&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-24&quot;&gt;&lt;a href=&quot;#cb6-24&quot;&gt;&lt;/a&gt;&lt;span class=&quot;st&quot;&gt;-Error: popping token &amp;quot;,&amp;quot; ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-25&quot;&gt;&lt;a href=&quot;#cb6-25&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 662 (line 3414):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-26&quot;&gt;&lt;a href=&quot;#cb6-26&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_arg_asgn ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-27&quot;&gt;&lt;a href=&quot;#cb6-27&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg_item ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-28&quot;&gt;&lt;a href=&quot;#cb6-28&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-29&quot;&gt;&lt;a href=&quot;#cb6-29&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 901&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-30&quot;&gt;&lt;a href=&quot;#cb6-30&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 665 (line 3428):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-31&quot;&gt;&lt;a href=&quot;#cb6-31&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-32&quot;&gt;&lt;a href=&quot;#cb6-32&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $2 = token &amp;quot;,&amp;quot; ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-33&quot;&gt;&lt;a href=&quot;#cb6-33&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $3 = nterm f_arg_item ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-34&quot;&gt;&lt;a href=&quot;#cb6-34&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-35&quot;&gt;&lt;a href=&quot;#cb6-35&quot;&gt;&lt;/a&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
This example shows &lt;code&gt;diff -u&lt;/code&gt; in the command line, but when I’m looking at these traces I almost exclusively use &lt;code&gt;vimdiff&lt;/code&gt;, because it lets me expand surrounding context, search for keywords, etc. And it looks nicer.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Looking at the highlighted lines near the bottom, we see that eventually the good parse was able to reduce &lt;code&gt;nterm f_arg&lt;/code&gt; by combining &lt;code&gt;f_arg&lt;/code&gt;, &lt;code&gt;&quot;,&quot;&lt;/code&gt;, and &lt;code&gt;f_arg_item&lt;/code&gt;. The trace tells us that this happened in &lt;code&gt;rule 665 (line 2428)&lt;/code&gt;. That line number is the actual source line number in our &lt;code&gt;*.ypp&lt;/code&gt; grammar file.&lt;/p&gt;
&lt;p&gt;All we have to do is go to that line and add an error case, which is pretty easy:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode numberSource diff numberLines hl-11 hl-12 hl-13 hl-14&quot;&gt;&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;           f_arg: f_arg_item&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;                    {&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;                      $$ = driver.alloc.node_list($1);&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;                    }&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;                | f_arg tCOMMA f_arg_item&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot;&gt;&lt;/a&gt;                    {&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot;&gt;&lt;/a&gt;                      auto &amp;amp;list = $1;&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot;&gt;&lt;/a&gt;                      list-&amp;gt;emplace_back($3);&lt;/span&gt;
&lt;span id=&quot;cb7-9&quot;&gt;&lt;a href=&quot;#cb7-9&quot;&gt;&lt;/a&gt;                      $$ = list;&lt;/span&gt;
&lt;span id=&quot;cb7-10&quot;&gt;&lt;a href=&quot;#cb7-10&quot;&gt;&lt;/a&gt;                    }&lt;/span&gt;
&lt;span id=&quot;cb7-11&quot;&gt;&lt;a href=&quot;#cb7-11&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+               | f_arg tCOMMA error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-12&quot;&gt;&lt;a href=&quot;#cb7-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                   {&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-13&quot;&gt;&lt;a href=&quot;#cb7-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                     $$ = $1;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-14&quot;&gt;&lt;a href=&quot;#cb7-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                   }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now the parser reports the error but continues to recover from the error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet -p parse-tree-whitequark -e &amp;#39;def foo(x,); end&amp;#39;
s(:def, :foo,
  s(:args,
    s(:arg, :x)), nil)
-e:1: unexpected token &amp;quot;)&amp;quot; https://srb.help/2001
     1 |def foo(x,); end
                  ^
Errors: 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This technique of comparing the trace for “what it currently does” against “what I wish it did” has been super useful, because it often shows exactly the point where the trace diverged, along with the reason. In this example, the &lt;code&gt;f_arg_item&lt;/code&gt; was never reduced, but sometimes the difference will be something like “the lexer didn’t read a token” or “the lexer read a token, but because of the state the lexer was in, it was the wrong token.” Whatever the cause, comparing traces usually shows the problem.&lt;/p&gt;
&lt;p&gt;This particular example also showed an example of using Bison’s &lt;code&gt;error&lt;/code&gt; token. I’ll talk more about what this &lt;code&gt;error&lt;/code&gt; token means in the next post.&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;← Part 2: Why Recover from Syntax Errors&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token →&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">← Return home This is the third post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Previously I discussed high level questions like why it’s an important problem for Sorbet to solve and some approaches I decided not to take. This post switches gears to focus on specific tips and techniques I found useful while making parser changes.</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 2</title><link href="https://blog.jez.io/error-recovery-part-2/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 2" /><published>2022-02-22T03:56:34-05:00</published><updated>2022-02-22T03:56:34-05:00</updated><id>https://blog.jez.io/error-recovery-part-2</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-2/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the second post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Specifically, it’s about approaches I considered but decided against.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we get started, I should say: I’m not, like, an expert at writing parsers. In fact of all the changes I’ve made to Sorbet, it’s definitely up there for “changes I’ve been least qualified to have made.” But at the end of the day my test cases passed &lt;span class=&quot;emoji&quot; data-emoji=&quot;upside_down_face&quot;&gt;🙃&lt;/span&gt; Take my experiences with as many or as few grains of salt as you’d like. This also means that if you want to suggest other alternatives or otherwise teach me something new, I’m all ears!&lt;/p&gt;
&lt;p&gt;First, a little bit of history. Sorbet’s parser was originally a part of the &lt;a href=&quot;https://github.com/typedruby/typedruby&quot;&gt;TypedRuby&lt;/a&gt; project.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;&lt;a href=&quot;https://github.com/typedruby/typedruby&quot;&gt;TypedRuby&lt;/a&gt; was an aspirational Ruby type checker implemented in Rust that predated Sorbet. It is now abandoned.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; In turn, TypedRuby sourced its parser by porting the grammar file in the &lt;a href=&quot;https://github.com/whitequark/parser&quot;&gt;whitequark parser&lt;/a&gt; from &lt;a href=&quot;https://rubygems.org/gems/racc&quot;&gt;Racc&lt;/a&gt; (a Yacc-like parser generator for Ruby) to &lt;a href=&quot;https://www.gnu.org/software/bison/&quot;&gt;Bison&lt;/a&gt; (a Yacc-like parser generator for C/C++). Sorbet imported the source code of the TypedRuby parser and continued to modify it over time as Ruby syntax evolved. The lexer uses &lt;a href=&quot;http://www.colm.net/open-source/ragel/&quot;&gt;Ragel&lt;/a&gt; (also inherited from whitequark by way of TypedRuby) and tends to be quite stateful compared to other lexers I’ve seen—a point which we’ll come back to in future posts.&lt;/p&gt;
&lt;p&gt;Importantly…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser does not use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.7.3/libdoc/ripper/rdoc/Ripper.html&quot;&gt;Ripper&lt;/a&gt;, the parser built into the Ruby VM itself.&lt;/p&gt;
&lt;p&gt;Ripper is meant to be used as a library from Ruby code, not from C++ like Sorbet needs for performance.&lt;/p&gt;
&lt;p&gt;Okay technically that’s a lie. The &lt;a href=&quot;https://github.com/penelopezone/rubyfmt&quot;&gt;rubyfmt&lt;/a&gt; project manages to depend on Ripper from Rust by exposing it via Ruby’s support for native (C) extensions. &lt;strong&gt;But&lt;/strong&gt; doing that comes with &lt;a href=&quot;https://github.com/penelopezone/rubyfmt/blob/trunk/librubyfmt/build.rs&quot;&gt;significant build complexity&lt;/a&gt;, because it has the effect of basically importing Ruby’s whole &lt;code&gt;configure &amp;amp;&amp;amp; make&lt;/code&gt; build step.&lt;/p&gt;
&lt;p&gt;Meanwhile it was super easy to import the TypedRuby parser as a self-contained unit with basically no questions asked (and remember: Sorbet predates rubyfmt). It’s also nice to be free from upstream&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;I should note that I’m not opposed to upstreaming the changes I’ve made to Sorbet’s parser. Some of them intentionally break Ruby compatibility (in minor ways), and even the changes that don’t would likely require effort to get them merged properly. If you find my changes and want to submit them upstream, please go ahead!&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; constraints: I can mess around in Sorbet’s parser as much as I want and the only people I have to defend my choices to are my teammates, not the Ruby maintainers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser does not use &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tree-sitter is tool whose main goals are basically 100% aligned with Sorbet’s needs in a parser: fast enough to run on every keystoke, robust enough to handle syntax errors, and native-code friendly. It would seem like a no-brainer for Sorbet to use.&lt;/p&gt;
&lt;p&gt;Unfortunately when I looked closely, it didn’t actually pan out. I used the &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/playground&quot;&gt;tree-sitter playground&lt;/a&gt; to test a bunch of syntax errors where I wanted to be able to respond to completion requests for to see what the parse result looked like. In some cases it worked okay, but for the cases I cared about the most (mostly those involving &lt;code&gt;x.&lt;/code&gt;), the results weren’t good enough. If I was going to have to manually hack on a parser to get it to do what I wanted, I figured I’d rather just stick with what Sorbet already had.&lt;/p&gt;
&lt;p&gt;On top of that tree-sitter is still pretty young, and almost everyone who is using tree-sitter right now is using it for two use cases: syntax highlighting, and code navigation. If the parse result generates the wrong thing (imagine there’s a bug in the grammar file that no one else has reported yet), oh well, maybe the colors are wrong or the jump-to-def goes to the wrong place. In Sorbet, it would mean either reporting an error when there isn’t one, or not reporting an error when there is one, both of which are particularly bad.&lt;/p&gt;
&lt;p&gt;Given that it was both (1) going to take extra hacks&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;After publishing this post, I wrote more about my &lt;a href=&quot;/tree-sitter-limitations/&quot;&gt;thoughts on tree-sitter&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to get working instead of being a drop-in solution and (2) potentially trade Sorbet’s mature parser for a less-mature parser, it didn’t seem worth pursuing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser is not hand-written with &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursive_descent_parser&quot;&gt;recursive descent&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Many people whose opinions I respect have told me that there’s a reason why so many people hand-write their parsers: error recovery is easier when given the flexibility to bend the whole parser to your will.&lt;/p&gt;
&lt;p&gt;But there isn’t an existing hand-written Ruby parser I could start from, and I didn’t want to completely stall progress with a bug-for-bug rewrite when I already had some ideas for how to make the existing parser better. Basically this approach has the same tradeoffs as adopting tree-sitter (lots of work with too many unknowns).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these claims about Sorbet’s parser were true when I started, and they haven’t changed. You’ll notice that in most cases the justification is “I don’t have time to do X” and not “doing X is wrong.” My biggest constraint in improving the parser has been making small, fast, iterative improvements. I wanted to be left with something to show even if I had to stop working on the parser sooner than expected. It’s possible that someone with more time or more patience will want to revisit one of these approaches in the future, and if you do I’d love to hear about it!&lt;/p&gt;
&lt;p&gt;Anyways, that rules out the most common refrains from onlookers. But there was another, more unconventional approach I considered and decided against: using &lt;a href=&quot;https://github.com/zombocom/dead_end&quot;&gt;dead_end&lt;/a&gt;. &lt;code&gt;dead_end&lt;/code&gt; isn’t a Ruby parser but rather a tool that hijacks Ruby’s syntax error reporting mechanism&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It turns out, all (“all”) you have to do is is monkey patch &lt;code&gt;require&lt;/code&gt; to &lt;code&gt;rescue   SyntaxError&lt;/code&gt;. Thanks Ruby &lt;span class=&quot;emoji&quot; data-emoji=&quot;slightly_smiling_face&quot;&gt;🙂&lt;/span&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to improve the message for certain syntax errors. Specifically, it’ll try to show error messages in cases like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-4 hl-8&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# ... lots of code ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ← dead_end error: missing `end` keyword&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; bar&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# ← ruby default error: unexpected token &amp;quot;end of file&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Missing an &lt;code&gt;end&lt;/code&gt; keyword is a super common class of Ruby syntax errors,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;One of my biggest Ruby syntax gripes is that it isn’t a curly brace language like C or JavaScript. Any sensibly editor will &lt;strong&gt;immediately&lt;/strong&gt; insert the matching &lt;code&gt;}&lt;/code&gt; after first typing &lt;code&gt;{&lt;/code&gt;. But most Ruby editors will only insert the &lt;code&gt;end&lt;/code&gt; matching some statement after a full line has been typed and &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; has been pressed, if anything. This means that unclosed &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;def&lt;/code&gt;/&lt;code&gt;class&lt;/code&gt; statements are &lt;strong&gt;abundantly&lt;/strong&gt; common in Ruby, and this class of error (mismatched pairs) is trickier than the average error.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and &lt;code&gt;dead_end&lt;/code&gt; already works particularly well at reporting them, so it was tempting to &lt;del&gt;steal&lt;/del&gt; reuse either the code or the ideas.&lt;/p&gt;
&lt;p&gt;Early on I had decided not to use the code directly (it’s written in Ruby, and I didn’t want to add a runtime dependency on Ruby to Sorbet). But in the end, I decided not to use its recovery algorithm either.&lt;/p&gt;
&lt;p&gt;The algorithm is &lt;a href=&quot;https://schneems.com/2020/12/01/squash-unexpectedend-errors-with-syntaxsearch/&quot;&gt;described in more detail here&lt;/a&gt;, but the tl;dr is that it uses indentation to search for mismatched snippets, expanding and discarding lines from the search frontier when it finds portions of a Ruby file that properly parse at a given indentation level.&lt;/p&gt;
&lt;p&gt;The problem with taking that idea verbatim is that the end result is basically just a set of lines in the source file that contain the error. But knowing those lines, there’s still no parse result for those lines. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-3&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ... code before ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; arbitrary_expression()&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ... code after ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dead_end&lt;/code&gt; could point to line 3 as the problem, but then I’d still have to parse that line to be able to e.g. service a completion request after the &lt;code&gt;.&lt;/code&gt;, which is &lt;em&gt;basically&lt;/em&gt; the situation we started with, because the parser would still be on the hook for the full complexity of what that &lt;code&gt;arbitrary_expression()&lt;/code&gt; could represent. So I put the &lt;code&gt;dead_end&lt;/code&gt; algorithm itself aside as well.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But!&lt;/strong&gt; the general idea of using indentation to guide recovery proved out to be pretty useful—most Ruby editors will auto-indent and -dedent correctly for most edits—and there was another way to take advantage of it in Sorbet’s parser, along with some other tricks. The next few posts will discuss those tricks!&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;← Part 1: Why Recover from Syntax Errors&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser →&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><category term="tree-sitter" /><summary type="html">← Return home This is the second post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Specifically, it’s about approaches I considered but decided against.</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 1</title><link href="https://blog.jez.io/error-recovery-part-1/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 1" /><published>2022-02-21T03:56:34-05:00</published><updated>2022-02-21T03:56:34-05:00</updated><id>https://blog.jez.io/error-recovery-part-1</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-1/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’ve spent a lot of time recently making &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt;’s parser recover from syntax errors when parsing. I didn’t have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I’d share the experience so that you can learn too.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The original post kept growing and growing as I wrote it, so I broke it up into a handful of parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;&lt;strong&gt;Part 1: Why Recover from Syntax Errors&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;This part is going to set the stage a bit and briefly mention why Sorbet cares so much about syntax errors. The short answer? Editor support is everything.&lt;/p&gt;
&lt;p&gt;There are people out there who clamor for a type checker in any codebase they work for. They’re zealous, early-adopters who evangelize types to everyone around them. They love even just being able to run the type checker in the command line or in CI hand have it reject code where the types don’t check. Sorbet has snuck its way into many codebases this way! But this approach always introduces friction: there’s always a group of people who see the type checker as an antagonist, sitting there and rejecting code that passes the test suite and gets the job done.&lt;/p&gt;
&lt;p&gt;Having a powerful editor integration drives organic adoption. A command line interface to a type checker is only really good at reporting errors, but an editor interface exposes so much more: inline hover lets programmers explore a code’s types and documentation by pointing. Language-aware jump-to-definition and find-all-references mean spending less time fumbling around a code base and more time looking at the code that’s relevant in the moment. And of course autocompletion is huge. Maybe you’re a curmudgeon like me who doesn’t use completion except the occasional keyword completion in Vim, but I’ve learned that many, many people feel like moving back to the dark ages when they have to work in a codebase that doesn’t have fast, accurate autocompletion. Every additional editor feature is another spoonful of sugar—once there are enough, it overwhelms any feeling that the type checker tastes like medicine.&lt;/p&gt;
&lt;p&gt;But if a syntax error means that the parser returns an empty parse result, all those spoonfuls fall to the floor with a loud clang. Hover and go-to-def are serve stale (read: imperfect) results at best, if anything. Autocomplete yields no results no matter how long you wait for the menu to appear.&lt;/p&gt;
&lt;p&gt;And in Sorbet’s situation, it’s even more severe because of how it has chosen to implement the persistent editor mode. I’m sure I’ll discuss this in more depth at some point (because despite the criticism I’m going to leverage against it, I still think it works &lt;strong&gt;really&lt;/strong&gt; well), but here’s a quick overview of Sorbet’s language server architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nearly every part of Sorbet’s offline pipeline is embarrassingly parallel.&lt;/p&gt;
&lt;p&gt;All of the syntactic transformations on the tree happen without access to any sort of codebase-wide information. Type inference is only local—inferring types in one method body never affects the type check result of another method, let alone another file. Program-wide state is made immutable and shared across threads using shared memory (no copying).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet does not track dependencies.&lt;/p&gt;
&lt;p&gt;That means it doesn’t track which files &lt;code&gt;require&lt;/code&gt; what other files. It doesn’t have a way to incrementally update its class hierarchy (symbol table) when something changes. It only caches parse results and which what errors came from which files. There are no module or package boundaries—Sorbet views a codebase as one codebase.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;This is starting to change, but only because the approach mentioned here doesn’t scale to 10 million-line Ruby codebases. It’s probably possible to count all such codebases on your fingers.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Given all of this, there are two paths in server mode: the fast path and the slow path.&lt;/p&gt;
&lt;p&gt;When an edit comes in, Sorbet quickly decides whether the edit changes any global information. If it can, Sorbet throws everything away (except for cached parse results) and type checks the entire codebase from scratch. Otherwise, it leaves the symbol table unchanged and just retypechecks the edited file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On one hand, this is a very elegant architecture. Sorbet can be almost entirely understood by how it behaves in batch mode. Put another way, if a user reports a bug in the editor mode, it almost always reproduces outside of the editor mode. It’s rare in Sorbet to find a bug that only reproduces when the user makes one edit followed by another edit.&lt;/p&gt;
&lt;p&gt;But on the other hand, if the parser can’t recover from a syntax error, not only can Sorbet not provide those fancy editor features, it also makes it look like all the definitions in a file were deleted, which makes it look like the contents of the symbol table will have changed, which kicks off a retypecheck of the whole codebase. Most syntax errors are introduced in completely benign places (like &lt;code&gt;x.&lt;/code&gt; or &lt;code&gt;if x&lt;/code&gt;), not as part of changing what’s defined in a file (like &lt;code&gt;def foo&lt;/code&gt; or &lt;code&gt;X =&lt;/code&gt;) because people spend more time editing method bodies than anything else. So most syntax errors can take the fast path as long as the parser can manage to return a decent result.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;All of this is to say&lt;/strong&gt;: it’s important for Sorbet to recover from syntax errors for two reasons: it can’t provide editor features like completion consistently without it, and in large codebases it makes Sorbet deliver in-editor type checking errors far faster. In future posts we’ll ramp up to more technical and esoteric parsing topics. In particular, the next post gives some historical context about Sorbet’s parser and some ideas I rejected for how to get better parse results for syntax errors.&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do →&lt;/a&gt;
&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">← Return home I’ve spent a lot of time recently making Sorbet’s parser recover from syntax errors when parsing. I didn’t have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I’d share the experience so that you can learn too.</summary></entry><entry><title type="html">Sorbet, Generics, and Parametricity</title><link href="https://blog.jez.io/sorbet-parametricity/" rel="alternate" type="text/html" title="Sorbet, Generics, and Parametricity" /><published>2022-02-18T02:59:55-05:00</published><updated>2022-02-18T02:59:55-05:00</updated><id>https://blog.jez.io/sorbet-parametricity</id><content type="html" xml:base="https://blog.jez.io/sorbet-parametricity/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Consider this snippet of Ruby code using Sorbet:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-11&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;#                 ^^^^^^^^ error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%20then%20return%200%0A%20%20else%20return%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;It has the same signature as the identity function (which returns its argument unchanged), but doesn’t actually do that in all cases. In particular, on the highlighted line it checks the type of &lt;code&gt;x&lt;/code&gt; at runtime, and if it’s an &lt;code&gt;Integer&lt;/code&gt;, it always returns &lt;code&gt;0&lt;/code&gt;, regardless of the input.&lt;/p&gt;
&lt;p&gt;Sorbet flags this as an error (see the full error message in the sorbet.run link). Sometimes I get asked: “why?” The reasoning for why people think this &lt;em&gt;shouldn’t&lt;/em&gt; be an error usually looks like this: the signature just says that the output has to be the same as the input, and &lt;code&gt;Integer&lt;/code&gt; is the same as &lt;code&gt;Integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But the fun thing is that this signature makes a stronger constraint on the implementation of the method—in this case the signature &lt;strong&gt;mandates&lt;/strong&gt; that the result is the input. The hand-wavy intuition for how to think about what’s going on is to mentally read the &lt;code&gt;type_parameters(:U)&lt;/code&gt; in the signature as “for all,” specifically, “the behavior of this function is the same &lt;em&gt;for all&lt;/em&gt; choices of the type parameters.”&lt;/p&gt;
&lt;p&gt;In that light, generics put a pretty hefty constraint on the implementation of a generic method—which is actually a good thing! It means that the caller of the method can make stronger guarantees about what the method can or cannot do, even seeing only the types. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), &lt;span class=&quot;wa&quot;&gt;y: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)))&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From this signature we’re guaranteed that the method has to return exactly one of the arguments we provided (&lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;) and nothing else. It can’t invent some third value and return that.&lt;/p&gt;
&lt;p&gt;But the constraints come within reason: the types don’t say anything about what side effects the function might have. This isn’t particularly unique to generics (Sorbet doesn’t track side effects no matter the types), but it is worth noting as a sneaky way that methods can do different things with different arguments. Going back to our &lt;code&gt;fake_identity_function&lt;/code&gt; example from earlier:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-12 hl-15&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;#cb3-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-15&quot;&gt;&lt;a href=&quot;#cb3-15&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# error: Method `even?` does not exist&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-16&quot;&gt;&lt;a href=&quot;#cb3-16&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-17&quot;&gt;&lt;a href=&quot;#cb3-17&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-18&quot;&gt;&lt;a href=&quot;#cb3-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20else%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In this example, the side effect of calling &lt;code&gt;puts(x.even?)&lt;/code&gt; only happens if the type is &lt;code&gt;Integer&lt;/code&gt;, breaking the intuition that the behavior of this function is uniform for all input types.&lt;/p&gt;
&lt;p&gt;If Sorbet wanted,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Unlike everything we’ve discussed so far, I’m not actually sure whether that was a conscious decision or an accident. But it is a pretty useful feature in practice.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; it could prevent this particular form of anti-uniformity by not allowing any &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;control-flow-sensitive&lt;/a&gt; type updates. But it wouldn’t change the fact that, for example, one implementation of &lt;code&gt;fake_identity_function&lt;/code&gt; could always print one log line, while another implementation could always print two log lines. The only uniformity guarantees we get are about specifically what’s captured in the input and output types.&lt;/p&gt;
&lt;p&gt;It turns out that there’s a name for this property of generic functions: &lt;a href=&quot;https://en.wikipedia.org/wiki/Parametricity&quot;&gt;parametricity&lt;/a&gt;. It’s a fancy word but it basically means what we’ve talked about here: the implementation of generic functions are constrained to basically only do one thing, modulo side-effects. It goes further than just intuition though, and people have done interesting work to formalize the intuitions into proofs.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="plt" /><summary type="html">← Return home Consider this snippet of Ruby code using Sorbet:</summary></entry><entry><title type="html">Typed Errors in Sorbet</title><link href="https://blog.jez.io/typed-errors-sorbet/" rel="alternate" type="text/html" title="Typed Errors in Sorbet" /><published>2021-06-05T01:12:37-04:00</published><updated>2021-06-05T01:12:37-04:00</updated><id>https://blog.jez.io/typed-errors-sorbet</id><content type="html" xml:base="https://blog.jez.io/typed-errors-sorbet/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I really like this post from Matt Parsons, &lt;a href=&quot;https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html&quot;&gt;The Trouble with Typed Errors&lt;/a&gt;. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.&lt;/p&gt;
&lt;p&gt;If you haven’t read it (or it’s been a while) the setup is basically: typing errors is hard, and nearly every solution is either brittle, clunky, verbose, or uses powerful type system features that we didn’t want to have to reach for.&lt;/p&gt;
&lt;p&gt;Hidden towards the bottom of the post, we find:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In PureScript or OCaml, you can use open variant types to do this flawlessly. Haskell doesn’t have open variants, and the attempts to &amp;gt; mock them end up quite clumsy to use in practice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What Matt calls “open variant types” I call &lt;strong&gt;ad hoc union types&lt;/strong&gt; (see my previous post about &lt;a href=&quot;https://blog.jez.io/union-types-checked-exceptions/&quot;&gt;checked exceptions and Sorbet&lt;/a&gt;). Naming aside, Sorbet has them! We don’t have to suffer from clunky error handling!&lt;/p&gt;
&lt;p&gt;I thought it’d be interesting to show what Matt meant in this quote by translating his example to Sorbet.&lt;/p&gt;
&lt;p&gt;I wrote a complete, working example, but rather than repeat the whole thing here, I’m just going to excerpt the good stuff. If you’re wondering how something is defined in full, check the full example:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0A%0A%23%20This%20is%20a%20re-implementation%20of%20Matt%20Parsons&amp;#39;s%20%22The%20Trouble%20with%20Typed%0A%23%20Errors%22%20in%20Sorbet%20(Ruby)%20because%20I%20think%20Sorbet%20happens%20to%20handle%20it%0A%23%20pretty%20well%20all%20things%20considered.%0A%23%0A%23%20%20%20%20%20%3Chttps%3A%2F%2Fwww.parsonsmatt.org%2F2018%2F11%2F03%2Ftrouble_with_typed_errors.html%3E%0A%23%0A%23%20Specifically%2C%20he%20mentions%0A%23%0A%23%20%20%20%20%20In%20PureScript%20or%20OCaml%2C%20you%20can%20use%20open%20variant%20types%20to%20do%20this%0A%23%20%20%20%20%20flawlessly.%0A%23%0A%23%20and%20Sorbet%20more%20or%20less%20has%20those%20(untagged%20unions).%20It&amp;#39;s%20interesting%0A%23%20to%20see%20what%20that%20means%20for%20being%20able%20to%20track%20errors%2C%20because%20we%0A%23%20actually%20use%20Sorbet%20in%20a%20huge%20codebase%20at%20work.%20Tracking%20all%20the%20kinds%0A%23%20of%20errors%20that%20could%20happen--and%20no%20more--can%20make%20code%20far%20easier%20to%0A%23%20understand.%0A%0A%23%20To%20run%20this%20file%3A%0A%23%0A%23%20%20%20gem%20install%20sorbet-runtime%0A%23%20%20%20ruby%20typed-errors.rb%0A%0Arequire%20&amp;#39;sorbet-runtime&amp;#39;%0A%0A%23%20There&amp;#39;s%20a%20bug%20in%20Sorbet%20that%20forces%20us%20to%20wrap%20all%20this%20code%20in%20a%0A%23%20class%2C%20but%20I%20have%20a%20PR%20open%20to%20fix%20it.%20For%20now%2C%20we%20tolerate%20it.%0Aclass%20Main%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20%23%20-----%20Custom%20error%20types%20-----%0A%0A%20%20%23%20Defining%20custom%20data%20types%20is%20a%20little%20clunky%20in%20Ruby%20%2F%20Sorbet.%20You%0A%20%20%23%20have%20to%20chose%20whether%20you%20want%20a%20plain%20class%2C%20an%20enum%2C%20a%20sealed%0A%20%20%23%20class%20hierarchy%2C%20etc.%20In%20a%20real%20codebase%2C%20I%20think%20if%20you%20were%20going%0A%20%20%23%20to%20this%20length%20to%20care%20for%20errors%20the%20kinds%20of%20errors%20that%20you%20have%0A%20%20%23%20are%20usually%20pretty%20rich%20(e.g.%2C%20there&amp;#39;s%20a%20message%20and%20context%20with%0A%20%20%23%20the%20failures)%2C%20so%20you&amp;#39;d%20probably%20go%20with%20the%20sealed%20class%20hierarchy.%0A%20%20%23%0A%20%20%23%20For%20this%20example%2C%20I%20chose%20three%20different%20ways%20to%20just%20show%20them%20all.%0A%0A%20%20class%20HeadError%0A%20%20end%0A%0A%20%20class%20LookupError%20%3C%20T%3A%3AEnum%0A%20%20%20%20enums%20do%0A%20%20%20%20%20%20KeyWasNotPresent%20%3D%20new%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20module%20ParseError%0A%20%20%20%20extend%20T%3A%3AHelpers%0A%20%20%20%20sealed!%0A%0A%20%20%20%20class%20UnexpectedChar%20%3C%20T%3A%3AStruct%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20%20%20prop%20%3Amessage%2C%20String%0A%20%20%20%20end%0A%0A%20%20%20%20class%20RanOutOfInput%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Helper%20methods%20-----%0A%0A%20%20%23%20Again%2C%20concise%20syntax%20is%20not%20Sorbet&amp;#39;s%20strong%20suit.%20The%20signature%0A%20%20%23%20annotations%20are%20pretty%20verbose%20here%20(especially%20generics)%20but%20they%0A%20%20%23%20pretty%20much%20exactly%20map%20to%20the%20Haskell%20functions%20in%20the%20post.%0A%0A%20%20sig%20do%0A%20%20%20%20%20%20params(xs%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(String%2C%20HeadError))%0A%20%20end%0A%20%20def%20self.head(xs)%0A%20%20%20%20case%20xs.size%0A%20%20%20%20when%200%20then%20HeadError.new%0A%20%20%20%20else%20T.must(xs%5B0%5D)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters(%3AK%2C%20%3AV)%0A%20%20%20%20%20%20.params(%0A%20%20%20%20%20%20%20%20hash%3A%20T%3A%3AHash%5BT.type_parameter(%3AK)%2C%20T.type_parameter(%3AV)%5D%2C%0A%20%20%20%20%20%20%20%20key%3A%20T.type_parameter(%3AK)%0A%20%20%20%20%20%20)%0A%20%20%20%20%20%20.returns(T.any(T.type_parameter(%3AV)%2C%20LookupError))%0A%20%20end%0A%20%20def%20self.lookup(hash%2C%20key)%0A%20%20%20%20if%20hash.key%3F(key)%0A%20%20%20%20%20%20hash.fetch(key)%0A%20%20%20%20else%0A%20%20%20%20%20%20LookupError%3A%3AKeyWasNotPresent%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20params(source%3A%20String).returns(T.any(Integer%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.parse(source)%0A%20%20%20%20case%20source%0A%20%20%20%20when%20%22%22%20then%20ParseError%3A%3ARanOutOfInput.new%0A%20%20%20%20else%0A%20%20%20%20%20%20begin%0A%20%20%20%20%20%20%20%20Integer(source%2C%2010)%0A%20%20%20%20%20%20rescue%20ArgumentError%20%3D%3E%20exn%0A%20%20%20%20%20%20%20%20ParseError%3A%3AUnexpectedChar.new(message%3A%20exn.message)%0A%20%20%20%20%20%20end%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Composing%20errors%20-----%0A%0A%20%20STR_MAP%20%3D%20T.let(%7B%0A%20%20%20%20%224__%22%20%3D%3E%20%222%22%0A%20%20%7D%2C%20T%3A%3AHash%5BString%2C%20String%5D)%0A%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20HeadError%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.foo(str)%0A%20%20%20%20%23%20These%20%60return%60%20lines%20are%20definitely%20not%20as%20convenient%20as%20do%0A%20%20%20%20%23%20notation%20in%20Haskell%2C%20but%20the%20interesting%20thing%20is%20that%20they&amp;#39;re%0A%20%20%20%20%23%20still%20pretty%20nice%3A%20because%20of%20flow-sensitive%20typing%2C%20the%20type%20of%0A%20%20%20%20%23%20%60c%60%20changes%2C%20as%20commented%3A%0A%20%20%20%20c%20%3D%20head(str)%20%23%20%3D%3E%20c%20%3A%20T.any(String%2C%20HeadError)%0A%20%20%20%20return%20c%20unless%20c.is_a%3F(String)%0A%20%20%20%20%23%20%3D%3E%20c%20%3A%20String%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(%22%23%7Bc%7D%23%7Br%7D%22)%0A%20%20end%0A%0A%20%20%23%20This%20method%20doesn&amp;#39;t%20call%20%60head%60%20like%20before%2C%20so%20it%20doesn&amp;#39;t%20need%20to%0A%20%20%23%20have%20%60HeadError%60%20in%20the%20return%20type.%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.bar(str)%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(r)%0A%20%20end%0A%0A%20%20p%20foo(%224__%22)%0A%20%20p%20bar(%224__%22)%0Aend%0A%0A%23%20Because%20%60T.any%60%20can%20create%20ad%20hoc%2C%20untagged%20union%20types%20anywhere%2C%0A%23%20there&amp;#39;s%20no%20need%20to%20define%20an%20%60AllErrorsEver%60%20data%20type%20like%20the%20reader%0A%23%20was%20tempted%20to%20in%20the%20Typed%20Errors%20blog%20post.%0A%23%0A%23%20If%20you%20find%20that%20a%20particular%20set%20of%20errors%20are%20showing%20up%20super%0A%23%20frequently%2C%20you%20can%20lurk%20them%20into%20a%20type%20alias%3A%0A%23%0A%23%20%20%20%20%20MostCommonErrors%20%3D%20T.type_alias%20%7BT.any(LookupError%2C%20ParseError)%7D%0A%23%0A%23%20and%20then%20use%20this%20alias%20in%20various%20places.%0A%23%0A%23%20One%20other%20note%3A%20to%20make%20this%20pattern%20nicer%2C%20code%20might%20want%20to%0A%23%20explicitly%20box%20up%20successful%20results%2C%20with%20a%20type%20like%0A%23%0A%23%20%20%20%20%20class%20Ok%20%3C%20T%3A%3AStruct%0A%23%20%20%20%20%20%20%20extend%20T%3A%3AGeneric%0A%23%20%20%20%20%20%20%20Type%20%3D%20type_member%0A%23%20%20%20%20%20%20%20prop%20%3Aval%2C%20Type%0A%23%20%20%20%20%20end%0A%23%0A%23%20So%20then%20you&amp;#39;d%20have%0A%23%20%20%20%20%20T.any(Ok%5BString%5D%2C%20MostCommonErrors)%0A%23%20and%20you%20could%20do%20make%20all%20the%20%60return%60%20lines%20always%20look%20the%20same%3A%0A%23%20%20%20%20%20return%20x%20unless%20x.is_a%3F(Ok)%0A%23%20but%20the%20flipside%20would%20mean%20that%20you&amp;#39;d%20have%20to%20use%20%60.val%60%20at%20all%20the%0A%23%20places%20that%20you%20would%20have%20normally%20used%20%60x%60%3A%0A%23%20%20%20%20%20parse(x.val)%0A%23%20so%20it&amp;#39;s%20maybe%20not%20worth%20it.%0A%0A&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First, here’s how we’d type the three running helper methods from Matt’s post:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Returns the first letter of the input,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# or returns `HeadError` if empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;xs: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.head&lt;/span&gt;(xs); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Gets the value for `key` in `hash`, or returns LookupError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This is normally defined in the stdlib, and in trying to&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# match Matt&amp;#39;s post, it ends up not being super idiomatic,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# but the types still work out.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;hash: &lt;/span&gt;T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb1-16&quot;&gt;&lt;a href=&quot;#cb1-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;key: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-17&quot;&gt;&lt;a href=&quot;#cb1-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&quot;cb1-18&quot;&gt;&lt;a href=&quot;#cb1-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-19&quot;&gt;&lt;a href=&quot;#cb1-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-20&quot;&gt;&lt;a href=&quot;#cb1-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.lookup&lt;/span&gt;(hash, key); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; en&lt;/span&gt;
&lt;span id=&quot;cb1-21&quot;&gt;&lt;a href=&quot;#cb1-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-22&quot;&gt;&lt;a href=&quot;#cb1-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-23&quot;&gt;&lt;a href=&quot;#cb1-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Convert a String to an integer, or return ParseError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-24&quot;&gt;&lt;a href=&quot;#cb1-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;source: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-25&quot;&gt;&lt;a href=&quot;#cb1-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.parse&lt;/span&gt;(source); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice how in all three cases, we use a normal &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;Sorbet union type&lt;/a&gt; in the return, like &lt;code&gt;T.any(String, HeadError)&lt;/code&gt;. All of the error types are just user-defined classes. For example, &lt;code&gt;HeadError&lt;/code&gt; is just defined like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;ParseError&lt;/code&gt; is defined using &lt;a href=&quot;https://sorbet.org/docs/sealed&quot;&gt;sealed classes&lt;/a&gt; and &lt;a href=&quot;https://sorbet.org/docs/tstruct&quot;&gt;typed structs&lt;/a&gt; to approximate algebraic data types in other typed languages:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Helpers&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  sealed!&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnexpectedChar&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Struct&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    prop &lt;span class=&quot;wa&quot;&gt;:message&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RanOutOfInput&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then at the caller side, it’s simple to handle the errors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  c &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; head(str) &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : T.any(String, HeadError)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; c &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; c&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;c&lt;span class=&quot;sc&quot;&gt;}#{&lt;/span&gt;r&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that the return type includes the possible errors, so we have to handle them. This example handles the errors by checking for success and returning early with the error otherwise. This manifests in the return type of &lt;code&gt;foo&lt;/code&gt;, which mentions four outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a successful result (&lt;code&gt;Integer&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;three kinds of failures (&lt;code&gt;HeadError&lt;/code&gt;, &lt;code&gt;LookupError&lt;/code&gt;, and &lt;code&gt;ParseError&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would have worked equally well to handle and recover from any or all of the errors: Sorbet knows exactly which error is returned by which method, so there’s never a burden of handling more errors than are possible.&lt;/p&gt;
&lt;p&gt;It’s fun that what makes this work is Sorbet’s natural &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;flow-sensitive typing&lt;/a&gt;, not some special language feature. Notice how before and after the first early return, Sorbet updates its knowledge of the type of &lt;code&gt;c&lt;/code&gt; (shown in the comments) because it knows how &lt;code&gt;is_a?&lt;/code&gt; works.&lt;/p&gt;
&lt;p&gt;Another example: if some other method only calls &lt;code&gt;lookup&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; (but not &lt;code&gt;head&lt;/code&gt;), it doesn’t have to mention &lt;code&gt;HeadError&lt;/code&gt; in its return:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# does need to mention HeadError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb5-5&quot;&gt;&lt;a href=&quot;#cb5-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-6&quot;&gt;&lt;a href=&quot;#cb5-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.bar&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb5-7&quot;&gt;&lt;a href=&quot;#cb5-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb5-8&quot;&gt;&lt;a href=&quot;#cb5-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-9&quot;&gt;&lt;a href=&quot;#cb5-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(r)&lt;/span&gt;
&lt;span id=&quot;cb5-10&quot;&gt;&lt;a href=&quot;#cb5-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And while there’s never a &lt;strong&gt;need&lt;/strong&gt; to predeclare one monolithic error type (like &lt;code&gt;AllErrorsEver&lt;/code&gt; in Matt’s post), if it happens to be convenient, Sorbet still lets you, using type aliases. For example, maybe there are a bunch of methods that all return &lt;code&gt;LookupError&lt;/code&gt; and &lt;code&gt;ParseError&lt;/code&gt;. We can factor that out into a type alias:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;MostCommonErrors&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s it! Sorbet’s union types in method returns provide a low-friction, high value way to model how methods can fail.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home I really like this post from Matt Parsons, The Trouble with Typed Errors. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.</summary></entry></feed>