<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2023-09-25T13:43:26-04:00</updated><id>https://blog.jez.io/atom.xml</id><title type="html">Jake Zimmerman</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">It’s okay to work on tiny projects</title><link href="https://blog.jez.io/tiny-projects/" rel="alternate" type="text/html" title="It’s okay to work on tiny projects" /><published>2023-09-18T22:10:41-04:00</published><updated>2023-09-18T22:10:41-04:00</updated><id>https://blog.jez.io/tiny-projects</id><author><name>Jake Zimmerman</name></author><category term="practices" /><summary type="html"><![CDATA[You don't have to chase novelty—it's okay to work on tiny projects too.]]></summary></entry><entry><title type="html">Only return nil if given nil</title><link href="https://blog.jez.io/sorbet-nil-if-nil/" rel="alternate" type="text/html" title="Only return nil if given nil" /><published>2023-09-15T18:28:50-04:00</published><updated>2023-09-15T18:28:50-04:00</updated><id>https://blog.jez.io/sorbet-nil-if-nil</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><summary type="html"><![CDATA[A quick post showing how to write a type that people commonly want to be able to write, where the return type is only nil if the input was nilable.]]></summary></entry><entry><title type="html">Ruby’s Conditional Send is not Safe Navigation</title><link href="https://blog.jez.io/conditional-send/" rel="alternate" type="text/html" title="Ruby’s Conditional Send is not Safe Navigation" /><published>2023-09-03T11:06:27-04:00</published><updated>2023-09-03T11:06:27-04:00</updated><id>https://blog.jez.io/conditional-send</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="javascript" /><category term="programming" /><summary type="html"><![CDATA[A brief explanation of why Ruby calls x&.foo "conditional send" and not "safe navigation."]]></summary></entry><entry><title type="html">ActiveSupport’s Concern, in pictures</title><link href="https://blog.jez.io/concern-inheritance/" rel="alternate" type="text/html" title="ActiveSupport’s Concern, in pictures" /><published>2023-08-26T15:43:12-04:00</published><updated>2023-08-26T15:43:12-04:00</updated><id>https://blog.jez.io/concern-inheritance</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="in-pictures" /><summary type="html"><![CDATA[A series of pictures which show how Rails's ActiveSupport::Concern works to redefine what inheritance means in Ruby.]]></summary></entry><entry><title type="html">Driving Bazel with fzf</title><link href="https://blog.jez.io/fzf-bazel/" rel="alternate" type="text/html" title="Driving Bazel with fzf" /><published>2023-08-10T22:57:54-04:00</published><updated>2023-08-10T22:57:54-04:00</updated><id>https://blog.jez.io/fzf-bazel</id><author><name>Jake Zimmerman</name></author><category term="bash" /><category term="zsh" /><category term="dotfiles" /><category term="bazel" /><summary type="html"><![CDATA[I find that the easiest way to work with Bazel is to use fzf.]]></summary></entry><entry><title type="html">Why Sorbet needs T.let(…, T::Boolean)</title><link href="https://blog.jez.io/t-let-boolean/" rel="alternate" type="text/html" title="Why Sorbet needs T.let(…, T::Boolean)" /><published>2023-05-13T19:31:29-04:00</published><updated>2023-05-13T19:31:29-04:00</updated><id>https://blog.jez.io/t-let-boolean</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html"><![CDATA[A short explanation of why Sorbet sometimes requires an explicit type annotation when initializing a variable whose type is changed in a loop.]]></summary></entry><entry><title type="html">Every type is defined by its intro and elim forms</title><link href="https://blog.jez.io/intro-elim/" rel="alternate" type="text/html" title="Every type is defined by its intro and elim forms" /><published>2023-04-23T19:43:00-04:00</published><updated>2023-04-23T19:43:00-04:00</updated><id>https://blog.jez.io/intro-elim</id><author><name>Jake Zimmerman</name></author><category term="programming" /><category term="plt" /><category term="types" /><summary type="html"><![CDATA[I took a course about programming languages in college. It was a very theory-oriented course, but as it turned out I learned more about how to write software from this theory course than many of my peers who took our school's software engineering elective.]]></summary></entry><entry><title type="html">Typing klass.new in Ruby with Sorbet</title><link href="https://blog.jez.io/typing-klass-new/" rel="alternate" type="text/html" title="Typing klass.new in Ruby with Sorbet" /><published>2023-02-19T22:34:27-05:00</published><updated>2023-02-19T22:34:27-05:00</updated><id>https://blog.jez.io/typing-klass-new</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html"><![CDATA[The straightforward attempt at writing a Sorbet signature for a method that calls `klass.new` doesn't work. The strategy that does work uses abstract methods, and so I'd like to walk through an extended example showing how to get such code to typecheck.]]></summary></entry><entry><title type="html">Ruby’s private keyword is weird</title><link href="https://blog.jez.io/ruby-private/" rel="alternate" type="text/html" title="Ruby’s private keyword is weird" /><published>2023-02-13T13:58:43-05:00</published><updated>2023-02-13T13:58:43-05:00</updated><id>https://blog.jez.io/ruby-private</id><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="scala" /><summary type="html"><![CDATA[Ruby's `private` keyword means something different compared to basically all other object-oriented languages. Most other languages don't even have a feature matching what Ruby calls `private`, but incredibly, Scala does, which it calls `protected[this]` (meaning "object-protected", as opposed to the normal `protected` keyword which is called "class-protected"). First let's review what `private` normally means, and then discuss what `private` in Ruby means (which will also amount to an explanation of what `protected[this]` means in Scala).]]></summary></entry><entry><title type="html">Problems typing equality in Ruby</title><link href="https://blog.jez.io/problems-typing-ruby-equality/" rel="alternate" type="text/html" title="Problems typing equality in Ruby" /><published>2023-01-24T16:12:15-05:00</published><updated>2023-01-24T16:12:15-05:00</updated><id>https://blog.jez.io/problems-typing-ruby-equality</id><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="types" /><category term="ruby" /><summary type="html"><![CDATA[TypeScript has this really handy error that flags when it looks like two values of unrelated types are getting compared. I would love to build the same error into Sorbet, but there are two features which make that hard: custom overrides of `==` and subtyping. Here are some heuristics we might consider building in Sorbet, and why they don't work.]]></summary></entry></feed>