<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2022-05-30T04:47:37-04:00</updated><id>https://blog.jez.io/atom.xml</id><title type="html">Jake Zimmerman</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Is tree-sitter good enough?</title><link href="https://blog.jez.io/tree-sitter-limitations/" rel="alternate" type="text/html" title="Is tree-sitter good enough?" /><published>2022-05-30T04:43:46-04:00</published><updated>2022-05-30T04:43:46-04:00</updated><id>https://blog.jez.io/tree-sitter-limitations</id><content type="html" xml:base="https://blog.jez.io/tree-sitter-limitations/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-sorbet&quot;&gt;Appendix: Sorbet&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;My answer: mostly no, or at the very least not for all cases, though I really wish it were good enough for the use cases I have, because then I would have less work to do.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;I’m guessing you already know what tree-sitter is because you clicked on the title. If you clicked because you were hoping to find out: &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt; is a relatively&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Is it still new? The GitHub repo has commits dating back to 2013, though I only first heard about it in 2017. It still has a feeling of newness about it, but I digress.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; new project which aims to make writing fast, error-tolerant parsers take less work. To do that, it provides both pre-built parsers for common programming languages and a toolkit for building new parsers. It’s known for use in various GitHub features by way of their &lt;a href=&quot;https://github.com/github/semantic&quot;&gt;semantic&lt;/a&gt; tool, which powers the code navigation tooltips that you sometimes see on GitHub.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;The semantic repo actually has a &lt;a href=&quot;https://github.com/github/semantic/blob/master/docs/why-tree-sitter.md&quot;&gt;short overview&lt;/a&gt; of why they chose tree-sitter, along with some drawbacks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I see a lot of talk about tree-sitter these days. And for a lot of projects, it’s really nice! This is especially true for projects that want to be able to parse a super wide variety of languages with an otherwise uniform API with the least amount of manual work. Things like writing a syntax highlighter in an editor, or building something like &lt;a href=&quot;https://www.emacswiki.org/emacs/ParEdit&quot;&gt;ParEdit&lt;/a&gt; for arbitrary languages, or providing best-effort jump-to-definition results.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Another neat use case, from work: every time a commit is pushed to an approved PR, the approval is dismissed, unless (using tree-sitter) the CI system detects that the parse tree hasn’t changed. This spares comment and formatting changes the toil of a re-review.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;When those goals are flipped—it has to work for exactly one language, and “best-effort” isn’t enough—tree-sitter becomes less attractive. As someone who works on language tooling &lt;a href=&quot;https://jez.io/#work&quot;&gt;professionally&lt;/a&gt; and is lazy, it’s kind of disappointing. As much as tree-sitter enthusiasts sell it as a magical solution that can free me from having to think about parsers, it’s just not been that silver bullet in my experience.&lt;/p&gt;
&lt;p&gt;There are two questions I would pose to anyone curious about using tree-sitter for their parser:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Is serving autocompletion requests going to be one of your use cases?&lt;/li&gt;
&lt;li&gt;How much do you care about custom messages for syntax errors?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If either or both of these are important, I’d probably recommend rolling your own parser, either using a parser generator or using recursive descent by hand. The longer lived your project is, the more these constraints are going to be hard to accomplish in tree-sitter.&lt;/p&gt;
&lt;p&gt;At this point, I should caveat this by saying that I’ve come to these conclusions having spent far less time with tree-sitter than I have with other parsing techniques, so maybe I only think they’re harder than they actually are because I lack a depth of tree-sitter experience.&lt;/p&gt;
&lt;p&gt;When investigating tree-sitter as a replacement for an existing parser, it’s been too easy to find parses from tree-sitter that don’t look like what I’d expect out of a parser that is meant to handle the kinds of errors programmers write in the real world.&lt;/p&gt;
&lt;p&gt;It’s entirely possible that I’ve just been &lt;em&gt;really&lt;/em&gt; unlucky, and that the problems I’ve found are all fixable with a few bug reports and a little elbow grease. But it just seems to me that if I’m going to have to spend time fixing bugs anyways, it may as well be in a parser I’ve written myself.&lt;/p&gt;
&lt;p&gt;Let me show what I mean. Here are some snippets of code that I hope you’ll agree represents code someone might write mid-edit, for which you want to both (1) provide autocompletion results for and (2) provide a human-friendly error message for. Following the code snippet is the parse result produced by the corresponding tree-sitter grammar for that language. You can follow along on the &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/playground&quot;&gt;tree-sitter online playground&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Let’s start with a Ruby program:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines hl-8 hl-9&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot;&gt;&lt;/a&gt;        identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 4]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By way of comparison, here’s what a valid parse looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines hl-8 hl-9 hl-10&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot;&gt;&lt;/a&gt;        call [1, 2] - [1, 7]&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot;&gt;&lt;/a&gt;          receiver: identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot;&gt;&lt;/a&gt;          method: identifier [1, 4] - [1, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the good parse, tree-sitter produces a &lt;code&gt;call&lt;/code&gt; node. In the bad parse, it just produces a &lt;code&gt;block&lt;/code&gt; that has a list containing two elements. Ideally, what we’d see here is something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call
  receiver: identifier
  method: ERROR&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which tells us (1) that there was a method call, (2) what the receiver of the method call was so we know where to start looking for methods to autocomplete, (3) that the syntax error was localized to the method call.&lt;/p&gt;
&lt;p&gt;There’s a similar problem with constants accesses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;g &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;cn&quot;&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode numberSource numberLines&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;program [0, 0] - [6, 0]&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;        constant [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 5]&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot;&gt;&lt;/a&gt;      body: block [3, 10] - [5, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot;&gt;&lt;/a&gt;        scope_resolution [4, 2] - [4, 6]&lt;/span&gt;
&lt;span id=&quot;cb7-9&quot;&gt;&lt;a href=&quot;#cb7-9&quot;&gt;&lt;/a&gt;          scope: constant [4, 2] - [4, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-10&quot;&gt;&lt;a href=&quot;#cb7-10&quot;&gt;&lt;/a&gt;          name: constant [4, 5] - [4, 6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Maybe this example was a little contrived, because a comparable program written in JavaScript actually parses the way I’d hoped the Ruby one did. Okay, maybe it’s just a bug in the Ruby grammar?&lt;/p&gt;
&lt;p&gt;This next snippet reproduces in both Ruby and JavaScript:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb8-6&quot;&gt;&lt;a href=&quot;#cb8-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;program [0, 0] - [6, 0]
  class_declaration [0, 0] - [5, 1]
    name: identifier [0, 6] - [0, 7]
    body: class_body [0, 8] - [5, 1]
      member: method_definition [1, 2] - [4, 3]
        name: property_identifier [1, 2] - [1, 5]
        parameters: formal_parameters [1, 5] - [1, 7]
        body: statement_block [1, 8] - [4, 3]
          expression_statement [3, 2] - [3, 9]
            call_expression [3, 2] - [3, 7]
              function: identifier [3, 2] - [3, 5]
              arguments: arguments [3, 5] - [3, 7]
            ERROR [3, 8] - [3, 9]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s hard to see what’s going on here without matching up the line numbers in the parse tree. Here’s essentially what the snippet above looks like to tree-sitter:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;#cb10-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;#cb10-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;#cb10-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb10-4&quot;&gt;&lt;a href=&quot;#cb10-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb10-5&quot;&gt;&lt;a href=&quot;#cb10-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Even though &lt;code&gt;bar() { ... }&lt;/code&gt; is valid method syntax, that’s gone. The parser thinks that there was a call to a method named &lt;code&gt;bar&lt;/code&gt; on an implicit receiver (i.e., &lt;code&gt;this&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The syntax error shows up after the imagined call to &lt;code&gt;bar&lt;/code&gt;, not associated with the &lt;code&gt;foo&lt;/code&gt; method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It gets even worse if the snippet changes so that &lt;code&gt;bar&lt;/code&gt; actually has parameters and code in the method body.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;The parameters become call-site arguments, and the code acts as though it was written inside &lt;code&gt;foo&lt;/code&gt; not &lt;code&gt;bar&lt;/code&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; With a parse that drops the &lt;code&gt;bar&lt;/code&gt; method definition entirely, the user no longer receives autocompletion results inside &lt;code&gt;bar&lt;/code&gt; until they fix the error in &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The best error message here would be to point out to the author that their curly braces are mismatched,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Indeed, that’s &lt;a href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=872bd946a8789aba9d49e07aef614819&quot;&gt;exactly the error&lt;/a&gt; on a comparable Rust example. (Rust’s parser is hand-written.)&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and then ideally use that information to recover when parsing.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;I could turn this into a post full of weird code snippets and poor parse results, but that’s not useful. What I’m trying to show is that when the demands are “the one specific language I care about has lots of idiosyncratic parse errors that are super common when in an editor,” then you’re still going to be limited by the quality of the particular tree-sitter grammar you’re working with. Fixing bugs in that grammar requires working within the constraints tree-sitter imposes to be able to power all the grammar-agnostic features (best-effort error recovery, uniform API, etc.) that it provides.&lt;/p&gt;
&lt;p&gt;On the other hand, if you control the whole parser, you can bend it however you want. You arguably do more work, but you at least have the option of doing more work (with the reward of better results).&lt;/p&gt;
&lt;p&gt;Don’t get me wrong, I still think tree-sitter is a great project with a neat new idea, and it’s done more to make parsing more accessible than any recent effort. But too many people tout it as something with no tradeoffs, and I just don’t think that’s fair.&lt;/p&gt;
&lt;p&gt;If you think I’m overlooking something, please let me know and I’ll happily update this post, and maybe even start using tree-sitter in my projects.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h1 id=&quot;appendix-sorbet&quot;&gt;Appendix: Sorbet&lt;/h1&gt;
&lt;p&gt;This is the part where I get to gleefully show off Sorbet’s parser, which I’m quite proud of.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb11&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb11-1&quot;&gt;&lt;a href=&quot;#cb11-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-2&quot;&gt;&lt;a href=&quot;#cb11-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb11-3&quot;&gt;&lt;a href=&quot;#cb11-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb11-4&quot;&gt;&lt;a href=&quot;#cb11-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;&amp;#39;inside foo&amp;#39;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb11-5&quot;&gt;&lt;a href=&quot;#cb11-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-6&quot;&gt;&lt;a href=&quot;#cb11-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;&amp;#39;after (outside) foo&amp;#39;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb11-7&quot;&gt;&lt;a href=&quot;#cb11-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-8&quot;&gt;&lt;a href=&quot;#cb11-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; bar(x)&lt;/span&gt;
&lt;span id=&quot;cb11-9&quot;&gt;&lt;a href=&quot;#cb11-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-10&quot;&gt;&lt;a href=&quot;#cb11-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-11&quot;&gt;&lt;a href=&quot;#cb11-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The parse tree:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb12&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb12-1&quot;&gt;&lt;a href=&quot;#cb12-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;s(&lt;span class=&quot;wa&quot;&gt;:class&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-2&quot;&gt;&lt;a href=&quot;#cb12-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  s(&lt;span class=&quot;wa&quot;&gt;:const&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:A&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-3&quot;&gt;&lt;a href=&quot;#cb12-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  s(&lt;span class=&quot;wa&quot;&gt;:begin&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-4&quot;&gt;&lt;a href=&quot;#cb12-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    s(&lt;span class=&quot;wa&quot;&gt;:def&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-5&quot;&gt;&lt;a href=&quot;#cb12-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      s(&lt;span class=&quot;wa&quot;&gt;:begin&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-6&quot;&gt;&lt;a href=&quot;#cb12-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        s(&lt;span class=&quot;wa&quot;&gt;:send&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:puts&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-7&quot;&gt;&lt;a href=&quot;#cb12-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;          s(&lt;span class=&quot;wa&quot;&gt;:str&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;inside foo&amp;quot;&lt;/span&gt;)))),&lt;/span&gt;
&lt;span id=&quot;cb12-8&quot;&gt;&lt;a href=&quot;#cb12-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    s(&lt;span class=&quot;wa&quot;&gt;:send&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:puts&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-9&quot;&gt;&lt;a href=&quot;#cb12-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      s(&lt;span class=&quot;wa&quot;&gt;:str&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;after (outside) foo&amp;quot;&lt;/span&gt;)),&lt;/span&gt;
&lt;span id=&quot;cb12-10&quot;&gt;&lt;a href=&quot;#cb12-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    s(&lt;span class=&quot;wa&quot;&gt;:def&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:bar&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-11&quot;&gt;&lt;a href=&quot;#cb12-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      s(&lt;span class=&quot;wa&quot;&gt;:args&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-12&quot;&gt;&lt;a href=&quot;#cb12-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        s(&lt;span class=&quot;wa&quot;&gt;:arg&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:x&lt;/span&gt;)),&lt;/span&gt;
&lt;span id=&quot;cb12-13&quot;&gt;&lt;a href=&quot;#cb12-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      s(&lt;span class=&quot;wa&quot;&gt;:send&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb12-14&quot;&gt;&lt;a href=&quot;#cb12-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        s(&lt;span class=&quot;wa&quot;&gt;:lvar&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:x&lt;/span&gt;), :&lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;method&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt;name&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt;missing&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;))))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The errors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;editor.rb:10: unexpected token &amp;quot;end&amp;quot; https://srb.help/2001
    10 |  end
          ^^^

editor.rb:11: unexpected token &amp;quot;end of file&amp;quot; https://srb.help/2001
    11 |end
    12 |

editor.rb:3: Hint: this &amp;quot;def&amp;quot; token might not be properly closed https://srb.help/2003
     3 |  def foo
          ^^^
    editor.rb:11: Matching `end` found here but is not indented as far
    11 |end
        ^^^
Errors: 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you use Sorbet and ever come across a file where you either didn’t get the autocompletion results that you wanted or you thought a syntax error was particularly confusing, feel free to &lt;a href=&quot;https://sorbet.run/?arg=--print=parse-tree-whitequark#%23%20typed%3A%20true%0A%23%20Share%20your%20example%20with%20%22Examples%20%3E%20Create%20issue%20with%20example%22%0A&quot;&gt;craft a bug report here&lt;/a&gt; and I’d be happy to take a look.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="parsing" /><category term="tree-sitter" /><summary type="html">← Return home My answer: mostly no, or at the very least not for all cases, though I really wish it were good enough for the use cases I have, because then I would have less work to do.</summary></entry><entry><title type="html">What would a type-aware Rubocop look like?</title><link href="https://blog.jez.io/type-aware-rubocop/" rel="alternate" type="text/html" title="What would a type-aware Rubocop look like?" /><published>2022-05-16T16:17:20-04:00</published><updated>2022-05-16T16:17:20-04:00</updated><id>https://blog.jez.io/type-aware-rubocop</id><content type="html" xml:base="https://blog.jez.io/type-aware-rubocop/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should every AST node (i.e., every expression) have a type associated with it?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just variables is enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even if this “give me the type of a variable” API works, is it enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet + linter?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-do-people-actually-want-this-for&quot;&gt;… what do people actually want this for?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#is-there-anything-like-this-in-another-language&quot;&gt;… is there anything like this in another language?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#competing-priorities-tend-to-win-out&quot;&gt;Competing priorities tend to win out&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-in-the-future&quot;&gt;“Maybe in the future…”&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;&lt;em&gt;This post represents my opinions at a point in time. It’s not necessarily the views of my team or my employer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;From time to time, someone asks, “Would &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt; ever allow defining some sort of type-aware lint rules?” The answer has usually been “no,” for a couple of reasons.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The biggest open question is that it’s not 100% clear what use cases people have in mind. Most commonly people imagine “the full &lt;a href=&quot;https://rubocop.org/&quot;&gt;Rubocop&lt;/a&gt; API, but with types,” but this is underspecified, in my opinion.&lt;/p&gt;
&lt;h3 id=&quot;should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should every AST node (i.e., every expression) have a type associated with it?&lt;/h3&gt;
&lt;p&gt;This would be particularly hard to support, because Sorbet aggressively simplifies the AST from the start to the end of its pipeline. The Rubocop AST has something like 100 node types. Sorbet immediately simplifies this into an AST that only has 30 or so node types, then subsequently keeps refining the AST until it only has about 15. The thing Sorbet type checks looks nothing like the AST that you’d want if you were trying to write a linter, because so much of it has been desugared, rewritten, or simplified.&lt;/p&gt;
&lt;p&gt;Then finally right before type checking, Sorbet actually abandons the (tree-based) AST, preferring to use a &lt;strong&gt;control flow graph&lt;/strong&gt; (CFG) for type checking! A CFG is no longer tree-based&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It’s a graph, where nodes are basic blocks and edges are control flow jumps between those blocks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;, which breaks a lot of the assumptions people make about what’s easy and hard to build in a linter rule.&lt;/p&gt;
&lt;p&gt;Because Sorbet type checks a CFG only, there’s no tree-based structure inside Sorbet that has types. &lt;em&gt;Maybe&lt;/em&gt; it’s possible to take the type-annotated CFG and use it to reconstruct some sort of typed AST, but that sounds brittle and error prone.&lt;/p&gt;
&lt;p&gt;And finally, in the CFG Sorbet doesn’t associate types with expressions, only types with variables! This works because the act of building a CFG assigns all intermediate expressions’ results to a variable and then only dealing with variables from then on.&lt;/p&gt;
&lt;h3 id=&quot;maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just variables is enough?&lt;/h3&gt;
&lt;p&gt;This would likely be somewhat easier to implement, because Sorbet already does maintain environments mapping variables to their types.&lt;/p&gt;
&lt;p&gt;However, these data structures are expensive to maintain and therefore not long-lived.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Sorbet’s LSP editor integration gets around this by re-typechecking an entire method every time the user hovers over a variable. When these hover requests come as (infrequent) requests from the user, this is fine because Sorbet is already initialized. Powering a linter this way would either require that the Sorbet server be initialized for variable type every request (crazy slow), or somehow kept around persistently (brittle).&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Unlike Sorbet’s symbol table, which exists indefinitely after creation, the environments that track variable types only last as long as is required to type check a single method.&lt;/p&gt;
&lt;p&gt;Maybe there could be an API like “please give me the type of the variable with this name,” but again this would be tricky, because chances are the lint rule author wants to build the lint rule on some tree-based data structure, and Sorbet only has the CFG. So there would additionally need to be some mapping between environments (basic blocks) and AST variable nodes, which again sounds pretty tricky and likely to break some assumptions.&lt;/p&gt;
&lt;h3 id=&quot;even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even if this “give me the type of a variable” API works, is it enough?&lt;/h3&gt;
&lt;p&gt;Knowing the type of a variable on its own isn’t very useful. The most common questions you want ask of a type are:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Is is this type a subtype of this other type?&lt;/li&gt;
&lt;li&gt;If a method with a given name is called on a receiver of this type, what are the &lt;em&gt;list&lt;/em&gt; of methods that would be dispatched to? (It’s a list because the receiver could be a union type.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The answer to (1) requires having the entire symbol table on hand (lots of memory). The answer to (2) is subtle and complicated—Sorbet spends &lt;a href=&quot;https://github.com/sorbet/sorbet/blob/master/core/types/calls.cc&quot;&gt;about 4,000 lines of code&lt;/a&gt; answering it—and &lt;em&gt;also&lt;/em&gt; requires having the symbol table on hand.&lt;/p&gt;
&lt;p&gt;So it’s probably not enough to just, e.g., return some JSON representation of one of Sorbet’s types. It’d also require having some structured representation of Sorbet’s symbol table, which brings us to our next question:&lt;/p&gt;
&lt;h3 id=&quot;rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet + linter?&lt;/h3&gt;
&lt;p&gt;So far I’ve kind of assumed that we want to start with an existing linter (Rubocop) and just add types. But what we’ve seen so far is that the things we’d need to get types into Rubocop basically amount to exporting almost all of Sorbet’s internal data structures.&lt;/p&gt;
&lt;p&gt;Sorbet’s internal data structures change all the time as we fix bugs, add features, and refactor things. Having to commit to a stable API for every internal data structure mentioned above would slow down how quickly we can improve the rest of Sorbet.&lt;/p&gt;
&lt;p&gt;So maybe instead of exporting an API that Rubocop could use, we should build a linter into Sorbet? This just has different tradeoffs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet has to reinvent the wheel on linter APIs (e.g., are lint rules specified in Ruby code with some new API? Does it attempt to copy as much of Rubocop’s API as possible? What happens when there are papercut differences between what Sorbet’s linter allows and what Rubocop does?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How are rules distributed? Are the rules written in Ruby, and Sorbet runs the Ruby code with some sort of FFI to expose the internal data structures? Does Sorbet embed some other scripting language for writing rules? Do people write rules as shared objects which Sorbet dynamically loads, akin to Ruby native extensions? Are the rules committed directly into the Sorbet repo, like how custom DSL and rewriter passes are right now?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;what-do-people-actually-want-this-for&quot;&gt;… what do people actually want this for?&lt;/h3&gt;
&lt;p&gt;Whenever someone asks for a type-aware linter, here are a sampling of the answers given when I ask, “What are you really trying to do?”&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;“Ban calling &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt;, because I just spent half an hour tracking down a bug where I had a &lt;code&gt;T.nilable(Symbol)&lt;/code&gt; that I called &lt;code&gt;to_s&lt;/code&gt; on and got the wrong answer.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Update the &lt;a href=&quot;https://docs.rubocop.org/rubocop-performance/cops_performance.html#performanceinefficienthashsearch&quot;&gt;Performance/InefficientHashSearch&lt;/a&gt; rule to only act on &lt;code&gt;Hash&lt;/code&gt; values. Not all calls like &lt;code&gt;xs.values.include?&lt;/code&gt; can be safely rewritten to &lt;code&gt;xs.value?&lt;/code&gt;.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Do type-aware codemods, for example change all calls to &lt;code&gt;x.merchant_&lt;/code&gt; to something like &lt;code&gt;ClassOfX.get_merchant(x.id)&lt;/code&gt;”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Enforce that all methods returning &lt;code&gt;T::Boolean&lt;/code&gt; have names ending in &lt;code&gt;?&lt;/code&gt;”&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It’s not clear that “just” building a type-aware linter necessarily solves these problems.&lt;/p&gt;
&lt;p&gt;Doing (1) is hard—should we allow &lt;code&gt;Object#to_s&lt;/code&gt;? You could still accidentally call &lt;code&gt;to_s&lt;/code&gt; on something that’s &lt;code&gt;nil&lt;/code&gt; inside a method that accepts &lt;code&gt;Object&lt;/code&gt; if you do. Also there are sometimes valid cases to call &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt; that no type system will help you discover! This feature seems similar to the &lt;code&gt;#poison&lt;/code&gt; pragma in C and C++, but there the language makes it easier because &lt;code&gt;#include&lt;/code&gt;’ed files are explicitly ordered, and it’s easy to say “after this point, the identifier is poisoned.” (Also I’m not even sure how &lt;code&gt;#poison&lt;/code&gt; works with methods, not just C functions, where things like inheritance become a problem.)&lt;/p&gt;
&lt;p&gt;Doing (2) relies on that hard feature we chatted about above: types for arbitrary expressions, not just variables. If we don’t have types for arbitrary expressions, detecting this case in a cop requires essentially re-inventing Sorbet’s inference algorithm: &lt;code&gt;input.map {...}.filter {...}.values.include?&lt;/code&gt;. We mentioned the difficulty in exposing types for arbitrary expressions above.&lt;/p&gt;
&lt;p&gt;The situation for (3) is something I can really relate to, as there are a lot of cases where I can imagine this being useful. But rather than build this as a lint rule, we’ve historically wanted to build these as IDE-mode code actions: the API is much more constrained (no internal data structures needed) and the IDE already has the type information in memory. Sorbet supports a limited number of refactorings now, but mostly because we haven’t spent time on it. It’s reasonable to assume we’ll build many more refactorings in the future.&lt;/p&gt;
&lt;p&gt;And finally, things like (4) can &lt;em&gt;already&lt;/em&gt; be done in Rubocop. It’s slightly more annoying (you have to write the code to parse Sorbet signature annotations manually) but Sorbet signature annotations are very stable. Their syntax changes infrequently, and when it does, it’s usually minor and/or backwards compatible changes.&lt;/p&gt;
&lt;h3 id=&quot;is-there-anything-like-this-in-another-language&quot;&gt;… is there anything like this in another language?&lt;/h3&gt;
&lt;p&gt;Here’s one of Sorbet’s explicit design principles:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;As simple as possible, but powerful enough&lt;/p&gt;
&lt;p&gt;Overall, we are not strong believers in super-complex type systems. They have their place, and we need a fair amount of expressive power to model (enough) real Ruby code, but all else being equal we want to be simpler. We believe that such a system scales better, and—most importantly—is easier for our users to learn &amp;amp; understand.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;— &lt;a href=&quot;https://github.com/sorbet/sorbet/#sorbet-user-facing-design-principles&quot;&gt;Sorbet user-facing design principles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another way to read this is, “we let other people blaze trails, and then copy their good ideas.”&lt;/p&gt;
&lt;p&gt;&lt;del&gt;This question comes up often enough that it makes me want to imagine that some sort of similar tool exists for other dynamically typed languages? But as far as I’m aware, no sort of type-aware linter exists for TypeScript, Flow, or Mypy.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;&lt;del&gt;If you know of a comparable tool, please do share!&lt;/del&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Not having any sort of frame of reference makes it hard to gauge expectations people have when asking for a tool like this.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update, 2022-05-18&lt;/strong&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Thanks to Steve Dignam for pointing out that not only does C# have static analysis APIs, but that TypeScript does as well, along with an ecosystem of type-aware lint rules.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; There &lt;em&gt;are&lt;/em&gt; type-aware static analysis tools for C# and TypeScript. Both languages were designed by the &lt;a href=&quot;https://en.wikipedia.org/wiki/Anders_Hejlsberg&quot;&gt;same person&lt;/a&gt;, so maybe this isn’t surprising. Unfortunately for Sorbet, they were architected to support static analysis tooling &lt;a href=&quot;https://en.wikipedia.org/wiki/Roslyn_%28compiler%29#:~:text=Roslyn%20was%20designed%20with%20that%20intent%20from%20the%20beginning.&quot;&gt;from the beginning&lt;/a&gt;. Sorbet’s current architecture was instead designed for batch type checking performance on large monorepos,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;All things considered, it’s actually quite good at this.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and IDE support was grafted on later. Exposing hackable APIs has so far not been considered.&lt;/p&gt;
&lt;p&gt;For example, TypeScript offers a &lt;a href=&quot;https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API&quot;&gt;compiler API&lt;/a&gt;, which is then used by the TypeScript ESLint project, which allows defining &lt;a href=&quot;https://typescript-eslint.io/docs/development/custom-rules#type-checking&quot;&gt;custom type-aware lint rules&lt;/a&gt;. What can we learn from this project?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The TypeScript compiler API does not have any sort of backwards compatibility guarantee, so breaking changes are published from time to time.&lt;/li&gt;
&lt;li&gt;It appears that all TypeScript functionality can be accessed behind the API, including instantiating a stateful object representing the type checker, running the type checker end-to-end on a project, spawning an LSP server, etc.&lt;/li&gt;
&lt;li&gt;The way custom lint rules are written is by converting between ESLint’s AST node type and TypeScript’s AST node type. The TypeScript compiler APIs then allow asking for the type of an AST (i.e., expression). I haven’t confirmed, but this leads me to believe that TypeScript itself is doing typechecking on the AST (maybe with some auxiliary structures to track control flow), not on a CFG like Sorbet, which makes it easier to present the kind of API that makes sense in a lint rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It’s interesting to &lt;a href=&quot;https://cs.github.com/typescript-eslint/typescript-eslint?q=%22requiresTypeChecking%3A+true%22&quot;&gt;browse the rules that require type information&lt;/a&gt; to get a sense for what’s possible. Things like &lt;code&gt;strict-boolean-expressions&lt;/code&gt; and &lt;code&gt;no-floating-promises&lt;/code&gt; are examples of non-trivial lints using type information.&lt;/p&gt;
&lt;p&gt;I have spent very limited time looking into how things work exactly, so it’s possible I’m misrepresenting the ideas. In any case, I personally still draw the same conclusion: clearly people in the TypeScript community derive value from building type-aware lint rules, and TypeScript is well-architected to enable this. As mentioned in previous sections, Sorbet’s current architecture does not present the same conveniences.&lt;/p&gt;
&lt;h3 id=&quot;competing-priorities-tend-to-win-out&quot;&gt;Competing priorities tend to win out&lt;/h3&gt;
&lt;p&gt;When attempting to build this feature, we’d of course have to judge the cost of what we’d have to give up.&lt;/p&gt;
&lt;p&gt;Overwhelmingly, the requests people have about Sorbet are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please fix shape and tuple types.&lt;/li&gt;
&lt;li&gt;Please fix generics (classes and methods).&lt;/li&gt;
&lt;li&gt;Please make Sorbet work faster on large codebases, especially in IDE mode.&lt;/li&gt;
&lt;li&gt;Please build more refactoring tools. If IntelliJ can do it, I’d like Sorbet to do it too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far, these requests have taken priority over greenfield projects, including things like a type-aware linter.&lt;/p&gt;
&lt;h3 id=&quot;maybe-in-the-future&quot;&gt;“Maybe in the future…”&lt;/h3&gt;
&lt;p&gt;Those are my current thoughts on the topic. Obviously, a lot of these reasons are just “it’s hard,” and maybe for someone else those things would be easy. Others are just selfish, “it’s convenient for us to not have to think about compatibility,” and so they’re easy to disagree with. Some of them are, “there’s no clear answer to this question,” and sometimes you can wave those away by just picking &lt;em&gt;any&lt;/em&gt; answer and living with it, rather than searching for the best.&lt;/p&gt;
&lt;p&gt;So while I don’t think that Sorbet would &lt;em&gt;never&lt;/em&gt; get some sort of type-aware linter, so far there are many factors that present a pretty high barrier to building something like this. Hopefully this post sheds some light on why a type-aware linter for Sorbet does not currently exist.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="rubocop" /><summary type="html">← Return home This post represents my opinions at a point in time. It’s not necessarily the views of my team or my employer.</summary></entry><entry><title type="html">T::Enum Pros &amp;amp; Cons</title><link href="https://blog.jez.io/tenum-pro-con/" rel="alternate" type="text/html" title="T::Enum Pros &amp;amp; Cons" /><published>2022-03-17T19:13:16-04:00</published><updated>2022-03-17T19:13:16-04:00</updated><id>https://blog.jez.io/tenum-pro-con</id><content type="html" xml:base="https://blog.jez.io/tenum-pro-con/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-is-verbose.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;👎 It’s hard to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;🚀 Every IDE feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-guards-against-basically-all-typos.&quot;&gt;🙊 &lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#it-requires-being-intentional.&quot;&gt;🤝 It requires being intentional.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-easy-to-search-for.&quot;&gt;🕵️ It’s easy to search for.&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;One feature that Sorbet doesn’t have&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Yet. The biggest limitation is just that Sorbet’s approach to type inference is designed to run fast and be simple to understand, sometimes sacrificing power.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;… but actually Sorbet already has these types internally 😅 It’s just that it doesn’t have syntax for people to write them in type annotations. And lo, it’s &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Ax%20%3D%20%3Adefault%0A%0A1.times%20do%0A%20%20%23%20Sorbet%20does%20not%20report%20an%20error%20here%0A%20%20%23%20%28it%20would%20have%20to%20start%20doing%20so%29%0A%20%20x%20%3D%20%3Afirst%0Aend%0A%0AT.reveal_type%28x%29%20%23%20Sorbet%20shows%20the%20wrong%20type%20here%0A%0A%23%20Sorbet%20can&amp;#39;t%20tell%20the%20difference%20bewteen%20a%20hash%20literal%0A%23%20with%20a%20variable%20key%20versus%20with%20a%20symbol%20literal%20key%0A%23%20at%20the%20time%20that%20inference%20happens.%0AT.reveal_type%28%7Bx%20%3D%3E%20nil%7D%29%0AT.reveal_type%28%7B%3Adefault%20%3D%3E%20nil%7D%29&quot;&gt;because they’re buggy&lt;/a&gt;, but for the things where Sorbet needs to use them internally we can intentionally work around the known bugs, so it hasn’t been worth the pain to fix.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; but gets requested frequently is support for literal string and symbol types. Something like &lt;code&gt;T.any(:left, :right)&lt;/code&gt;, which is a type that allows either the symbol literal &lt;code&gt;:left&lt;/code&gt; or &lt;code&gt;:right&lt;/code&gt;, but no other &lt;code&gt;Symbol&lt;/code&gt;s much less other types of values. The closest that Sorbet has to this right now is typed enums:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  enums &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TypeScript, Flow, and Mypy all have literal types. You probably have felt yourself wanting this. I don’t really have to explain why they’re nice. But I’ll do it anyways, just to prove that I hear you.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/h2&gt;
&lt;p&gt;That’s a fancy way of saying we’d like to be able to write &lt;code&gt;T.any(:left, :right)&lt;/code&gt; in any type annotation, without first having to pre-declare the new union type to the world. I spoke at length about how the existence of ad hoc union types make handling exceptional conditions &lt;a href=&quot;/union-types-checked-exceptions/&quot;&gt;more pleasant than checked exceptions&lt;/a&gt;, so I’m right there with you in appreciating that feature.&lt;/p&gt;
&lt;h2 id=&quot;tenum-is-verbose.&quot;&gt;👎 &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/h2&gt;
&lt;p&gt;Even if you wanted to pre-declare the enum type. Consider:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:left&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:right&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Boom. One line, no boilerplate. Wouldn’t that be nice?&lt;/p&gt;
&lt;h2 id=&quot;its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;👎 It’s hard to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/h2&gt;
&lt;p&gt;This comes up so frequently that there’s &lt;a href=&quot;https://sorbet.org/docs/tenum#defining-one-enum-as-a-subset-of-another-enum&quot;&gt;an FAQ entry&lt;/a&gt; about it. The answer is yet more verbosity and boilerplate.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;So I hear you. But I wanted to say a few things in defense of &lt;code&gt;T::Enum&lt;/code&gt;, because I think that despite how nice it might be to have literal types (and again, we may yet build them one day), there are still &lt;em&gt;a lot of points&lt;/em&gt; in favor of &lt;code&gt;T::Enum&lt;/code&gt; as it exists today.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;🚀 Every IDE feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;T::Enum&lt;/code&gt;s are just normal constants. Sorbet supports finding all constant references, renaming constants, autocompleting constant names, jumping to a constant’s definition, hovering over a constant to see its documentation comment. Also all of those features work on both the enum class itself and each individual enum value.&lt;/p&gt;
&lt;p&gt;We could &lt;em&gt;maybe&lt;/em&gt; support completion for symbol literals in limited circumstances, but it would be the first of its kind in Sorbet. Same goes for rename, and maybe find all references. Jump to Definition I guess would want to jump not to the actual definition, but rather to the signature that specified the literal type? It’s weird.&lt;/p&gt;
&lt;h2 id=&quot;tenum-guards-against-basically-all-typos.&quot;&gt;🙊 &lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/h2&gt;
&lt;p&gt;Even in &lt;code&gt;# typed: false&lt;/code&gt; files! Even when calling methods that take don’t have signatures, or that have loose signatures like &lt;code&gt;Object&lt;/code&gt;! Incidentally, this is basically the same reason why find all references can work so well.&lt;/p&gt;
&lt;h2 id=&quot;it-requires-being-intentional.&quot;&gt;🤝 It requires being intentional.&lt;/h2&gt;
&lt;p&gt;Code gets out of hand really quickly when people try to cutely interpolate strings into other strings that hold meaning. I’d much rather deal with this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;left_or_right, up_or_down&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;than this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you try to do this with &lt;code&gt;T::Enum&lt;/code&gt; you get strings that look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;#&amp;lt;LeftOrRight::Left&amp;gt;__#&amp;lt;UpOrDown::Up&amp;gt;&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which confuses people, so they ask how to do the thing they’re trying to do, which is a perfect opportunity to talk them down from that cliff. If people decide that yes, this really is the API we need, we can be intentional about it with &lt;code&gt;.serialize&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;its-easy-to-search-for.&quot;&gt;🕵️ It’s easy to search for.&lt;/h2&gt;
&lt;p&gt;This is a small one, but I’ll mention it anyways. It’s quick to search the Sorbet docs for &lt;code&gt;T::Enum&lt;/code&gt; and get to the right page. It’s similarly easy to find examples of it being used in a given codebase, to learn from real code. There’s no unique piece of syntax in &lt;code&gt;T.any(:left, :right)&lt;/code&gt; that is a surefire thing to search for.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="fragment" /><category term="sorbet" /><summary type="html">← Return home One feature that Sorbet doesn’t have[^yet][^but-actually] but gets requested frequently is support for literal string and symbol types. Something like T.any(:left, :right), which is a type that allows either the symbol literal :left or :right, but no other Symbols much less other types of values. The closest that Sorbet has to this right now is typed enums:</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 3</title><link href="https://blog.jez.io/error-recovery-part-3/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 3" /><published>2022-02-28T00:25:56-05:00</published><updated>2022-02-28T00:25:56-05:00</updated><id>https://blog.jez.io/error-recovery-part-3</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-3/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#read-the-docs&quot;&gt;Read the docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enable-traces-and-make-them-good&quot;&gt;Enable traces, and make them good&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#diff-traces-for-good-and-bad-parses&quot;&gt;Diff traces for good and bad parses&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the third post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Previously I discussed high level questions like why it’s an important problem for Sorbet to solve and some approaches I decided not to take. This post switches gears to focus on specific tips and techniques I found useful while making parser changes.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With that all out of the way, let’s dive into the tips.&lt;/p&gt;
&lt;h1 id=&quot;read-the-docs&quot;&gt;Read the docs&lt;/h1&gt;
&lt;p&gt;Haha! You probably thought that by Googling for things you’d be able to find something that lets you avoid reading the official docs. But it’s boring for me to repeat everything that’s in the docs, and honestly the Bison and Ragel docs are rather comprehensive as far as software documentation goes these days:&lt;/p&gt;
&lt;p&gt;→ &lt;a href=&quot;https://www.colm.net/files/ragel/ragel-guide-6.9.pdf&quot;&gt;Ragel User Guide&lt;/a&gt;&lt;br /&gt;
→ &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html&quot;&gt;Bison User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But I will give you some tips for &lt;strong&gt;how&lt;/strong&gt; to read the docs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You ~always want the “HTML entirely on one web page” version of the Bison docs—it’s way easier to ⌘F around one page.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bison actually gets new, interesting features from version to version. Double check that the version of the docs you’re reading actually match the version of Bison you’re using. I haven’t found an easy way to read old Bison docs online, so I usually just &lt;code&gt;grep&lt;/code&gt; for things in the docs’ sources:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ git clone https://github.com/akimd/bison
❯ git checkout v3.3.2
❯ grep -r &amp;#39;error.*token&amp;#39; doc/
doc/bison.texi:error.  If there is a @samp{..} token before the next
doc/bison.texi:value of the error token is 256, unless you explicitly assigned 256
... many more results ...&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I’ve found it valuable to actually take my time while reading the Bison docs. I’ve found a lot of things that turned out to be relevant later on because I took the time to read parts of the docs that didn’t look immediately relevant.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But that’s enough soapbox standing, now we return to regularly scheduled tips.&lt;/p&gt;
&lt;h1 id=&quot;enable-traces-and-make-them-good&quot;&gt;Enable traces, and make them good&lt;/h1&gt;
&lt;p&gt;Before I started working on this project, I treated Sorbet’s parser like a black box. In the spirit of “&lt;a href=&quot;https://blog.nelhage.com/post/computers-can-be-understood/&quot;&gt;Computers can be understood&lt;/a&gt;,” the first thing I did was enable traces for our parser. Easy enough:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define the &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Tracing&quot;&gt;&lt;code&gt;parse.trace&lt;/code&gt;&lt;/a&gt; variable in the grammar&lt;/li&gt;
&lt;li&gt;Call &lt;a href=&quot;https://www.gnu.org/software/bison/manual/bison.html#index-set_005fdebug_005flevel-on-parser&quot;&gt;&lt;code&gt;set_debug_level&lt;/code&gt;&lt;/a&gt; on the generated parser&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s &lt;a href=&quot;https://github.com/sorbet/sorbet/pull/4985/files?w=1#diff-63fada7036ffcba42e6615c3b85615cb81d47aafbf88122a552a34fb799c06b5R17&quot;&gt;the PR in Sorbet&lt;/a&gt;, which might help to make these two steps more concrete.&lt;/p&gt;
&lt;p&gt;The trace output looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet --trace-parser -e &amp;#39;def foo; end&amp;#39;
Starting parse
Entering state 0
Reading a token: Next token is token &amp;quot;def&amp;quot; ()
Shifting token &amp;quot;def&amp;quot; ()
Entering state 4
Reading a token: Next token is token tIDENTIFIER ()
Shifting token tIDENTIFIER ()
Entering state 184

...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is somewhat useful as is, but it can be better. First, all the trailing &lt;code&gt;()&lt;/code&gt; on the “Next token is …” lines are present because there aren’t any &lt;code&gt;%printer&lt;/code&gt;’s for those tokens–we can easily get the trace to not only show that it read a &lt;code&gt;tIDENTIFIER&lt;/code&gt; token, but also what the name of that variable was. After adding one for &lt;code&gt;tIDENTIFIER&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%printer { yyo &amp;lt;&amp;lt; $$-&amp;gt;view(); } tIDENTIFIER&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;$$-&amp;gt;view();&lt;/code&gt; bit calls the &lt;code&gt;view&lt;/code&gt; method on Sorbet’s token type, converting it to a string. Now our traces look better:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet --trace-parser -e &amp;#39;def foo; end&amp;#39;
Starting parse
Entering state 0
Reading a token: Next token is token &amp;quot;def&amp;quot; ()
Shifting token &amp;quot;def&amp;quot; ()
Entering state 4
Reading a token: Next token is token tIDENTIFIER (foo)
Shifting token tIDENTIFIER (foo)
Entering state 184
Reading a token: Next token is token &amp;quot;;&amp;quot; ()
Reducing stack by rule 125 (line 1140):
   $1 = token tIDENTIFIER (foo)
-&amp;gt; $$ = nterm fname ()
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far I’ve been adding these &lt;code&gt;%printer&lt;/code&gt;s only as I encounter the tokens that show up, mostly because I’m too lazy to exhaustively define printers for all the tokens—Ruby has a lot of tokens. You’ll note that Bison even lets you register &lt;code&gt;%printer&lt;/code&gt;s for non-terminals (not pictured, but the same mechanism). You could use this to, like, print the currently reduced AST for that non-terminal, or some other summary.&lt;/p&gt;
&lt;p&gt;The next step is to actually understand what these traces mean, because it looks like there’s a lot of magic names and numbers, but there’s a short cut for that.&lt;/p&gt;
&lt;h1 id=&quot;diff-traces-for-good-and-bad-parses&quot;&gt;Diff traces for good and bad parses&lt;/h1&gt;
&lt;p&gt;This code is a syntax error in Ruby:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo(x,); &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bison has a fancy &lt;code&gt;error&lt;/code&gt; token that we can use to recover from cases like this, but it’s hard to know where to add that &lt;code&gt;error&lt;/code&gt; token into the grammar. Printing the trace file would likely help us figure out where, but even when we’re staring at the trace file it’s not entirely clear.&lt;/p&gt;
&lt;p&gt;Luckily there’s a short cut:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Record a parser trace for the invalid parse.&lt;/li&gt;
&lt;li&gt;“Fix” the file so that it parses by only adding tokens, and record a trace for that parse.
&lt;ul&gt;
&lt;li&gt;This ensures that all the tokens present in the bad parse are also present in the good parse.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;diff&lt;/code&gt; (or &lt;code&gt;vimdiff&lt;/code&gt;) the two traces, and add an error recovery rule to the place where the trace differs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In our case, I want &lt;code&gt;def foo(x,); end&lt;/code&gt; to parse as if the user had properly written two arguments, so that I can record the fact that the user started to introduce a second argument. I’ll record a trace for the program &lt;code&gt;def foo(x, y); end&lt;/code&gt;, and diff it. The diff looks like this:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode numberSource diff numberLines hl-30 hl-31 hl-32 hl-33 hl-34&quot;&gt;&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot;&gt;&lt;/a&gt;❯ sorbet --trace-parser -e &amp;#39;def foo(x,); end&amp;#39; 2&amp;gt; trace-bad.txt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot;&gt;&lt;/a&gt;  sorbet --trace-parser -e &amp;#39;def foo(x, y); end&amp;#39; 2&amp;gt; trace-good.txt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot;&gt;&lt;/a&gt;  diff -u trace-bad.txt trace-good.txt&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;--- trace-bad.txt       2022-01-16 14:40:51.168977798 -0800&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;+++ trace-good.txt      2022-01-16 14:40:51.728976581 -0800&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;@@ -53,45 +53,201 @@&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-7&quot;&gt;&lt;a href=&quot;#cb6-7&quot;&gt;&lt;/a&gt; Next token is token &amp;quot;,&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-8&quot;&gt;&lt;a href=&quot;#cb6-8&quot;&gt;&lt;/a&gt; Shifting token &amp;quot;,&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-9&quot;&gt;&lt;a href=&quot;#cb6-9&quot;&gt;&lt;/a&gt; Entering state 752&lt;/span&gt;
&lt;span id=&quot;cb6-10&quot;&gt;&lt;a href=&quot;#cb6-10&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reading a token: Next token is token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-11&quot;&gt;&lt;a href=&quot;#cb6-11&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Shifting token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-12&quot;&gt;&lt;a href=&quot;#cb6-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 541&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-13&quot;&gt;&lt;a href=&quot;#cb6-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 660 (line 3400):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-14&quot;&gt;&lt;a href=&quot;#cb6-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = token tIDENTIFIER ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-15&quot;&gt;&lt;a href=&quot;#cb6-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_norm_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-16&quot;&gt;&lt;a href=&quot;#cb6-16&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-17&quot;&gt;&lt;a href=&quot;#cb6-17&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 559&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-18&quot;&gt;&lt;a href=&quot;#cb6-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 661 (line 3408):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-19&quot;&gt;&lt;a href=&quot;#cb6-19&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_norm_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-20&quot;&gt;&lt;a href=&quot;#cb6-20&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg_asgn ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-21&quot;&gt;&lt;a href=&quot;#cb6-21&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-22&quot;&gt;&lt;a href=&quot;#cb6-22&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 560&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-23&quot;&gt;&lt;a href=&quot;#cb6-23&quot;&gt;&lt;/a&gt; Reading a token: Next token is token &amp;quot;)&amp;quot; ()&lt;/span&gt;
&lt;span id=&quot;cb6-24&quot;&gt;&lt;a href=&quot;#cb6-24&quot;&gt;&lt;/a&gt;&lt;span class=&quot;st&quot;&gt;-Error: popping token &amp;quot;,&amp;quot; ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-25&quot;&gt;&lt;a href=&quot;#cb6-25&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 662 (line 3414):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-26&quot;&gt;&lt;a href=&quot;#cb6-26&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_arg_asgn ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-27&quot;&gt;&lt;a href=&quot;#cb6-27&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg_item ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-28&quot;&gt;&lt;a href=&quot;#cb6-28&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Stack now 752 562 349 78 0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-29&quot;&gt;&lt;a href=&quot;#cb6-29&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Entering state 901&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-30&quot;&gt;&lt;a href=&quot;#cb6-30&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+Reducing stack by rule 665 (line 3428):&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-31&quot;&gt;&lt;a href=&quot;#cb6-31&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $1 = nterm f_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-32&quot;&gt;&lt;a href=&quot;#cb6-32&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $2 = token &amp;quot;,&amp;quot; ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-33&quot;&gt;&lt;a href=&quot;#cb6-33&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+   $3 = nterm f_arg_item ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-34&quot;&gt;&lt;a href=&quot;#cb6-34&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+-&amp;gt; $$ = nterm f_arg ()&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-35&quot;&gt;&lt;a href=&quot;#cb6-35&quot;&gt;&lt;/a&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
This example shows &lt;code&gt;diff -u&lt;/code&gt; in the command line, but when I’m looking at these traces I almost exclusively use &lt;code&gt;vimdiff&lt;/code&gt;, because it lets me expand surrounding context, search for keywords, etc. And it looks nicer.
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Looking at the highlighted lines near the bottom, we see that eventually the good parse was able to reduce &lt;code&gt;nterm f_arg&lt;/code&gt; by combining &lt;code&gt;f_arg&lt;/code&gt;, &lt;code&gt;&quot;,&quot;&lt;/code&gt;, and &lt;code&gt;f_arg_item&lt;/code&gt;. The trace tells us that this happened in &lt;code&gt;rule 665 (line 2428)&lt;/code&gt;. That line number is the actual source line number in our &lt;code&gt;*.ypp&lt;/code&gt; grammar file.&lt;/p&gt;
&lt;p&gt;All we have to do is go to that line and add an error case, which is pretty easy:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode numberSource diff numberLines hl-11 hl-12 hl-13 hl-14&quot;&gt;&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;           f_arg: f_arg_item&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;                    {&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;                      $$ = driver.alloc.node_list($1);&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;                    }&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;                | f_arg tCOMMA f_arg_item&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot;&gt;&lt;/a&gt;                    {&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot;&gt;&lt;/a&gt;                      auto &amp;amp;list = $1;&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot;&gt;&lt;/a&gt;                      list-&amp;gt;emplace_back($3);&lt;/span&gt;
&lt;span id=&quot;cb7-9&quot;&gt;&lt;a href=&quot;#cb7-9&quot;&gt;&lt;/a&gt;                      $$ = list;&lt;/span&gt;
&lt;span id=&quot;cb7-10&quot;&gt;&lt;a href=&quot;#cb7-10&quot;&gt;&lt;/a&gt;                    }&lt;/span&gt;
&lt;span id=&quot;cb7-11&quot;&gt;&lt;a href=&quot;#cb7-11&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+               | f_arg tCOMMA error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-12&quot;&gt;&lt;a href=&quot;#cb7-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                   {&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-13&quot;&gt;&lt;a href=&quot;#cb7-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                     $$ = $1;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-14&quot;&gt;&lt;a href=&quot;#cb7-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+                   }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now the parser reports the error but continues to recover from the error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ sorbet -p parse-tree-whitequark -e &amp;#39;def foo(x,); end&amp;#39;
s(:def, :foo,
  s(:args,
    s(:arg, :x)), nil)
-e:1: unexpected token &amp;quot;)&amp;quot; https://srb.help/2001
     1 |def foo(x,); end
                  ^
Errors: 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This technique of comparing the trace for “what it currently does” against “what I wish it did” has been super useful, because it often shows exactly the point where the trace diverged, along with the reason. In this example, the &lt;code&gt;f_arg_item&lt;/code&gt; was never reduced, but sometimes the difference will be something like “the lexer didn’t read a token” or “the lexer read a token, but because of the state the lexer was in, it was the wrong token.” Whatever the cause, comparing traces usually shows the problem.&lt;/p&gt;
&lt;p&gt;This particular example also showed an example of using Bison’s &lt;code&gt;error&lt;/code&gt; token. I’ll talk more about what this &lt;code&gt;error&lt;/code&gt; token means in the next post.&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;← Part 2: Why Recover from Syntax Errors&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token →&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">← Return home This is the third post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Previously I discussed high level questions like why it’s an important problem for Sorbet to solve and some approaches I decided not to take. This post switches gears to focus on specific tips and techniques I found useful while making parser changes.</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 2</title><link href="https://blog.jez.io/error-recovery-part-2/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 2" /><published>2022-02-22T03:56:34-05:00</published><updated>2022-02-22T03:56:34-05:00</updated><id>https://blog.jez.io/error-recovery-part-2</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-2/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the second post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Specifically, it’s about approaches I considered but decided against.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we get started, I should say: I’m not, like, an expert at writing parsers. In fact of all the changes I’ve made to Sorbet, it’s definitely up there for “changes I’ve been least qualified to have made.” But at the end of the day my test cases passed &lt;span class=&quot;emoji&quot; data-emoji=&quot;upside_down_face&quot;&gt;🙃&lt;/span&gt; Take my experiences with as many or as few grains of salt as you’d like. This also means that if you want to suggest other alternatives or otherwise teach me something new, I’m all ears!&lt;/p&gt;
&lt;p&gt;First, a little bit of history. Sorbet’s parser was originally a part of the &lt;a href=&quot;https://github.com/typedruby/typedruby&quot;&gt;TypedRuby&lt;/a&gt; project.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;&lt;a href=&quot;https://github.com/typedruby/typedruby&quot;&gt;TypedRuby&lt;/a&gt; was an aspirational Ruby type checker implemented in Rust that predated Sorbet. It is now abandoned.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; In turn, TypedRuby sourced its parser by porting the grammar file in the &lt;a href=&quot;https://github.com/whitequark/parser&quot;&gt;whitequark parser&lt;/a&gt; from &lt;a href=&quot;https://rubygems.org/gems/racc&quot;&gt;Racc&lt;/a&gt; (a Yacc-like parser generator for Ruby) to &lt;a href=&quot;https://www.gnu.org/software/bison/&quot;&gt;Bison&lt;/a&gt; (a Yacc-like parser generator for C/C++). Sorbet imported the source code of the TypedRuby parser and continued to modify it over time as Ruby syntax evolved. The lexer uses &lt;a href=&quot;http://www.colm.net/open-source/ragel/&quot;&gt;Ragel&lt;/a&gt; (also inherited from whitequark by way of TypedRuby) and tends to be quite stateful compared to other lexers I’ve seen—a point which we’ll come back to in future posts.&lt;/p&gt;
&lt;p&gt;Importantly…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser does not use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.7.3/libdoc/ripper/rdoc/Ripper.html&quot;&gt;Ripper&lt;/a&gt;, the parser built into the Ruby VM itself.&lt;/p&gt;
&lt;p&gt;Ripper is meant to be used as a library from Ruby code, not from C++ like Sorbet needs for performance.&lt;/p&gt;
&lt;p&gt;Okay technically that’s a lie. The &lt;a href=&quot;https://github.com/penelopezone/rubyfmt&quot;&gt;rubyfmt&lt;/a&gt; project manages to depend on Ripper from Rust by exposing it via Ruby’s support for native (C) extensions. &lt;strong&gt;But&lt;/strong&gt; doing that comes with &lt;a href=&quot;https://github.com/penelopezone/rubyfmt/blob/trunk/librubyfmt/build.rs&quot;&gt;significant build complexity&lt;/a&gt;, because it has the effect of basically importing Ruby’s whole &lt;code&gt;configure &amp;amp;&amp;amp; make&lt;/code&gt; build step.&lt;/p&gt;
&lt;p&gt;Meanwhile it was super easy to import the TypedRuby parser as a self-contained unit with basically no questions asked (and remember: Sorbet predates rubyfmt). It’s also nice to be free from upstream&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;I should note that I’m not opposed to upstreaming the changes I’ve made to Sorbet’s parser. Some of them intentionally break Ruby compatibility (in minor ways), and even the changes that don’t would likely require effort to get them merged properly. If you find my changes and want to submit them upstream, please go ahead!&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; constraints: I can mess around in Sorbet’s parser as much as I want and the only people I have to defend my choices to are my teammates, not the Ruby maintainers.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser does not use &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tree-sitter is tool whose main goals are basically 100% aligned with Sorbet’s needs in a parser: fast enough to run on every keystoke, robust enough to handle syntax errors, and native-code friendly. It would seem like a no-brainer for Sorbet to use.&lt;/p&gt;
&lt;p&gt;Unfortunately when I looked closely, it didn’t actually pan out. I used the &lt;a href=&quot;https://tree-sitter.github.io/tree-sitter/playground&quot;&gt;tree-sitter playground&lt;/a&gt; to test a bunch of syntax errors where I wanted to be able to respond to completion requests for to see what the parse result looked like. In some cases it worked okay, but for the cases I cared about the most (mostly those involving &lt;code&gt;x.&lt;/code&gt;), the results weren’t good enough. If I was going to have to manually hack on a parser to get it to do what I wanted, I figured I’d rather just stick with what Sorbet already had.&lt;/p&gt;
&lt;p&gt;On top of that tree-sitter is still pretty young, and almost everyone who is using tree-sitter right now is using it for two use cases: syntax highlighting, and code navigation. If the parse result generates the wrong thing (imagine there’s a bug in the grammar file that no one else has reported yet), oh well, maybe the colors are wrong or the jump-to-def goes to the wrong place. In Sorbet, it would mean either reporting an error when there isn’t one, or not reporting an error when there is one, both of which are particularly bad.&lt;/p&gt;
&lt;p&gt;Given that it was both (1) going to take extra hacks&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;After publishing this post, I wrote more about my &lt;a href=&quot;/tree-sitter-limitations/&quot;&gt;thoughts on tree-sitter&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to get working instead of being a drop-in solution and (2) potentially trade Sorbet’s mature parser for a less-mature parser, it didn’t seem worth pursuing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet’s parser is not hand-written with &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursive_descent_parser&quot;&gt;recursive descent&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Many people whose opinions I respect have told me that there’s a reason why so many people hand-write their parsers: error recovery is easier when given the flexibility to bend the whole parser to your will.&lt;/p&gt;
&lt;p&gt;But there isn’t an existing hand-written Ruby parser I could start from, and I didn’t want to completely stall progress with a bug-for-bug rewrite when I already had some ideas for how to make the existing parser better. Basically this approach has the same tradeoffs as adopting tree-sitter (lots of work with too many unknowns).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of these claims about Sorbet’s parser were true when I started, and they haven’t changed. You’ll notice that in most cases the justification is “I don’t have time to do X” and not “doing X is wrong.” My biggest constraint in improving the parser has been making small, fast, iterative improvements. I wanted to be left with something to show even if I had to stop working on the parser sooner than expected. It’s possible that someone with more time or more patience will want to revisit one of these approaches in the future, and if you do I’d love to hear about it!&lt;/p&gt;
&lt;p&gt;Anyways, that rules out the most common refrains from onlookers. But there was another, more unconventional approach I considered and decided against: using &lt;a href=&quot;https://github.com/zombocom/dead_end&quot;&gt;dead_end&lt;/a&gt;. &lt;code&gt;dead_end&lt;/code&gt; isn’t a Ruby parser but rather a tool that hijacks Ruby’s syntax error reporting mechanism&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It turns out, all (“all”) you have to do is is monkey patch &lt;code&gt;require&lt;/code&gt; to &lt;code&gt;rescue   SyntaxError&lt;/code&gt;. Thanks Ruby &lt;span class=&quot;emoji&quot; data-emoji=&quot;slightly_smiling_face&quot;&gt;🙂&lt;/span&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to improve the message for certain syntax errors. Specifically, it’ll try to show error messages in cases like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-4 hl-8&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# ... lots of code ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ← dead_end error: missing `end` keyword&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; bar&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# ← ruby default error: unexpected token &amp;quot;end of file&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Missing an &lt;code&gt;end&lt;/code&gt; keyword is a super common class of Ruby syntax errors,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;One of my biggest Ruby syntax gripes is that it isn’t a curly brace language like C or JavaScript. Any sensibly editor will &lt;strong&gt;immediately&lt;/strong&gt; insert the matching &lt;code&gt;}&lt;/code&gt; after first typing &lt;code&gt;{&lt;/code&gt;. But most Ruby editors will only insert the &lt;code&gt;end&lt;/code&gt; matching some statement after a full line has been typed and &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; has been pressed, if anything. This means that unclosed &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;def&lt;/code&gt;/&lt;code&gt;class&lt;/code&gt; statements are &lt;strong&gt;abundantly&lt;/strong&gt; common in Ruby, and this class of error (mismatched pairs) is trickier than the average error.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and &lt;code&gt;dead_end&lt;/code&gt; already works particularly well at reporting them, so it was tempting to &lt;del&gt;steal&lt;/del&gt; reuse either the code or the ideas.&lt;/p&gt;
&lt;p&gt;Early on I had decided not to use the code directly (it’s written in Ruby, and I didn’t want to add a runtime dependency on Ruby to Sorbet). But in the end, I decided not to use its recovery algorithm either.&lt;/p&gt;
&lt;p&gt;The algorithm is &lt;a href=&quot;https://schneems.com/2020/12/01/squash-unexpectedend-errors-with-syntaxsearch/&quot;&gt;described in more detail here&lt;/a&gt;, but the tl;dr is that it uses indentation to search for mismatched snippets, expanding and discarding lines from the search frontier when it finds portions of a Ruby file that properly parse at a given indentation level.&lt;/p&gt;
&lt;p&gt;The problem with taking that idea verbatim is that the end result is basically just a set of lines in the source file that contain the error. But knowing those lines, there’s still no parse result for those lines. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-3&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ... code before ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; arbitrary_expression()&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ... code after ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;dead_end&lt;/code&gt; could point to line 3 as the problem, but then I’d still have to parse that line to be able to e.g. service a completion request after the &lt;code&gt;.&lt;/code&gt;, which is &lt;em&gt;basically&lt;/em&gt; the situation we started with, because the parser would still be on the hook for the full complexity of what that &lt;code&gt;arbitrary_expression()&lt;/code&gt; could represent. So I put the &lt;code&gt;dead_end&lt;/code&gt; algorithm itself aside as well.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But!&lt;/strong&gt; the general idea of using indentation to guide recovery proved out to be pretty useful—most Ruby editors will auto-indent and -dedent correctly for most edits—and there was another way to take advantage of it in Sorbet’s parser, along with some other tricks. The next few posts will discuss those tricks!&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;← Part 1: Why Recover from Syntax Errors&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser →&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><category term="tree-sitter" /><summary type="html">← Return home This is the second post in a series about “things I’ve learned while making improvements to Sorbet’s parser.” Specifically, it’s about approaches I considered but decided against.</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 1</title><link href="https://blog.jez.io/error-recovery-part-1/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 1" /><published>2022-02-21T03:56:34-05:00</published><updated>2022-02-21T03:56:34-05:00</updated><id>https://blog.jez.io/error-recovery-part-1</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-1/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’ve spent a lot of time recently making &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt;’s parser recover from syntax errors when parsing. I didn’t have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I’d share the experience so that you can learn too.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The original post kept growing and growing as I wrote it, so I broke it up into a handful of parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;&lt;strong&gt;Part 1: Why Recover from Syntax Errors&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison’s &lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;This part is going to set the stage a bit and briefly mention why Sorbet cares so much about syntax errors. The short answer? Editor support is everything.&lt;/p&gt;
&lt;p&gt;There are people out there who clamor for a type checker in any codebase they work for. They’re zealous, early-adopters who evangelize types to everyone around them. They love even just being able to run the type checker in the command line or in CI hand have it reject code where the types don’t check. Sorbet has snuck its way into many codebases this way! But this approach always introduces friction: there’s always a group of people who see the type checker as an antagonist, sitting there and rejecting code that passes the test suite and gets the job done.&lt;/p&gt;
&lt;p&gt;Having a powerful editor integration drives organic adoption. A command line interface to a type checker is only really good at reporting errors, but an editor interface exposes so much more: inline hover lets programmers explore a code’s types and documentation by pointing. Language-aware jump-to-definition and find-all-references mean spending less time fumbling around a code base and more time looking at the code that’s relevant in the moment. And of course autocompletion is huge. Maybe you’re a curmudgeon like me who doesn’t use completion except the occasional keyword completion in Vim, but I’ve learned that many, many people feel like moving back to the dark ages when they have to work in a codebase that doesn’t have fast, accurate autocompletion. Every additional editor feature is another spoonful of sugar—once there are enough, it overwhelms any feeling that the type checker tastes like medicine.&lt;/p&gt;
&lt;p&gt;But if a syntax error means that the parser returns an empty parse result, all those spoonfuls fall to the floor with a loud clang. Hover and go-to-def are serve stale (read: imperfect) results at best, if anything. Autocomplete yields no results no matter how long you wait for the menu to appear.&lt;/p&gt;
&lt;p&gt;And in Sorbet’s situation, it’s even more severe because of how it has chosen to implement the persistent editor mode. I’m sure I’ll discuss this in more depth at some point (because despite the criticism I’m going to leverage against it, I still think it works &lt;strong&gt;really&lt;/strong&gt; well), but here’s a quick overview of Sorbet’s language server architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nearly every part of Sorbet’s offline pipeline is embarrassingly parallel.&lt;/p&gt;
&lt;p&gt;All of the syntactic transformations on the tree happen without access to any sort of codebase-wide information. Type inference is only local—inferring types in one method body never affects the type check result of another method, let alone another file. Program-wide state is made immutable and shared across threads using shared memory (no copying).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sorbet does not track dependencies.&lt;/p&gt;
&lt;p&gt;That means it doesn’t track which files &lt;code&gt;require&lt;/code&gt; what other files. It doesn’t have a way to incrementally update its class hierarchy (symbol table) when something changes. It only caches parse results and which what errors came from which files. There are no module or package boundaries—Sorbet views a codebase as one codebase.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;This is starting to change, but only because the approach mentioned here doesn’t scale to 10 million-line Ruby codebases. It’s probably possible to count all such codebases on your fingers.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Given all of this, there are two paths in server mode: the fast path and the slow path.&lt;/p&gt;
&lt;p&gt;When an edit comes in, Sorbet quickly decides whether the edit changes any global information. If it can, Sorbet throws everything away (except for cached parse results) and type checks the entire codebase from scratch. Otherwise, it leaves the symbol table unchanged and just retypechecks the edited file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On one hand, this is a very elegant architecture. Sorbet can be almost entirely understood by how it behaves in batch mode. Put another way, if a user reports a bug in the editor mode, it almost always reproduces outside of the editor mode. It’s rare in Sorbet to find a bug that only reproduces when the user makes one edit followed by another edit.&lt;/p&gt;
&lt;p&gt;But on the other hand, if the parser can’t recover from a syntax error, not only can Sorbet not provide those fancy editor features, it also makes it look like all the definitions in a file were deleted, which makes it look like the contents of the symbol table will have changed, which kicks off a retypecheck of the whole codebase. Most syntax errors are introduced in completely benign places (like &lt;code&gt;x.&lt;/code&gt; or &lt;code&gt;if x&lt;/code&gt;), not as part of changing what’s defined in a file (like &lt;code&gt;def foo&lt;/code&gt; or &lt;code&gt;X =&lt;/code&gt;) because people spend more time editing method bodies than anything else. So most syntax errors can take the fast path as long as the parser can manage to return a decent result.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;All of this is to say&lt;/strong&gt;: it’s important for Sorbet to recover from syntax errors for two reasons: it can’t provide editor features like completion consistently without it, and in large codebases it makes Sorbet deliver in-editor type checking errors far faster. In future posts we’ll ramp up to more technical and esoteric parsing topics. In particular, the next post gives some historical context about Sorbet’s parser and some ideas I rejected for how to get better parse results for syntax errors.&lt;/p&gt;
&lt;p style=&quot;text-align: right;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn’t Do →&lt;/a&gt;
&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">← Return home I’ve spent a lot of time recently making Sorbet’s parser recover from syntax errors when parsing. I didn’t have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I’d share the experience so that you can learn too.</summary></entry><entry><title type="html">Sorbet, Generics, and Parametricity</title><link href="https://blog.jez.io/sorbet-parametricity/" rel="alternate" type="text/html" title="Sorbet, Generics, and Parametricity" /><published>2022-02-18T02:59:55-05:00</published><updated>2022-02-18T02:59:55-05:00</updated><id>https://blog.jez.io/sorbet-parametricity</id><content type="html" xml:base="https://blog.jez.io/sorbet-parametricity/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Consider this snippet of Ruby code using Sorbet:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-11&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;#                 ^^^^^^^^ error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%20then%20return%200%0A%20%20else%20return%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;It has the same signature as the identity function (which returns its argument unchanged), but doesn’t actually do that in all cases. In particular, on the highlighted line it checks the type of &lt;code&gt;x&lt;/code&gt; at runtime, and if it’s an &lt;code&gt;Integer&lt;/code&gt;, it always returns &lt;code&gt;0&lt;/code&gt;, regardless of the input.&lt;/p&gt;
&lt;p&gt;Sorbet flags this as an error (see the full error message in the sorbet.run link). Sometimes I get asked: “why?” The reasoning for why people think this &lt;em&gt;shouldn’t&lt;/em&gt; be an error usually looks like this: the signature just says that the output has to be the same as the input, and &lt;code&gt;Integer&lt;/code&gt; is the same as &lt;code&gt;Integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But the fun thing is that this signature makes a stronger constraint on the implementation of the method—in this case the signature &lt;strong&gt;mandates&lt;/strong&gt; that the result is the input. The hand-wavy intuition for how to think about what’s going on is to mentally read the &lt;code&gt;type_parameters(:U)&lt;/code&gt; in the signature as “for all,” specifically, “the behavior of this function is the same &lt;em&gt;for all&lt;/em&gt; choices of the type parameters.”&lt;/p&gt;
&lt;p&gt;In that light, generics put a pretty hefty constraint on the implementation of a generic method—which is actually a good thing! It means that the caller of the method can make stronger guarantees about what the method can or cannot do, even seeing only the types. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), &lt;span class=&quot;wa&quot;&gt;y: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)))&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From this signature we’re guaranteed that the method has to return exactly one of the arguments we provided (&lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;) and nothing else. It can’t invent some third value and return that.&lt;/p&gt;
&lt;p&gt;But the constraints come within reason: the types don’t say anything about what side effects the function might have. This isn’t particularly unique to generics (Sorbet doesn’t track side effects no matter the types), but it is worth noting as a sneaky way that methods can do different things with different arguments. Going back to our &lt;code&gt;fake_identity_function&lt;/code&gt; example from earlier:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-12 hl-15&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;#cb3-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-15&quot;&gt;&lt;a href=&quot;#cb3-15&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# error: Method `even?` does not exist&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-16&quot;&gt;&lt;a href=&quot;#cb3-16&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-17&quot;&gt;&lt;a href=&quot;#cb3-17&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-18&quot;&gt;&lt;a href=&quot;#cb3-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20else%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In this example, the side effect of calling &lt;code&gt;puts(x.even?)&lt;/code&gt; only happens if the type is &lt;code&gt;Integer&lt;/code&gt;, breaking the intuition that the behavior of this function is uniform for all input types.&lt;/p&gt;
&lt;p&gt;If Sorbet wanted,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Unlike everything we’ve discussed so far, I’m not actually sure whether that was a conscious decision or an accident. But it is a pretty useful feature in practice.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; it could prevent this particular form of anti-uniformity by not allowing any &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;control-flow-sensitive&lt;/a&gt; type updates. But it wouldn’t change the fact that, for example, one implementation of &lt;code&gt;fake_identity_function&lt;/code&gt; could always print one log line, while another implementation could always print two log lines. The only uniformity guarantees we get are about specifically what’s captured in the input and output types.&lt;/p&gt;
&lt;p&gt;It turns out that there’s a name for this property of generic functions: &lt;a href=&quot;https://en.wikipedia.org/wiki/Parametricity&quot;&gt;parametricity&lt;/a&gt;. It’s a fancy word but it basically means what we’ve talked about here: the implementation of generic functions are constrained to basically only do one thing, modulo side-effects. It goes further than just intuition though, and people have done interesting work to formalize the intuitions into proofs.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="plt" /><summary type="html">← Return home Consider this snippet of Ruby code using Sorbet:</summary></entry><entry><title type="html">Typed Errors in Sorbet</title><link href="https://blog.jez.io/typed-errors-sorbet/" rel="alternate" type="text/html" title="Typed Errors in Sorbet" /><published>2021-06-05T01:12:37-04:00</published><updated>2021-06-05T01:12:37-04:00</updated><id>https://blog.jez.io/typed-errors-sorbet</id><content type="html" xml:base="https://blog.jez.io/typed-errors-sorbet/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I really like this post from Matt Parsons, &lt;a href=&quot;https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html&quot;&gt;The Trouble with Typed Errors&lt;/a&gt;. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.&lt;/p&gt;
&lt;p&gt;If you haven’t read it (or it’s been a while) the setup is basically: typing errors is hard, and nearly every solution is either brittle, clunky, verbose, or uses powerful type system features that we didn’t want to have to reach for.&lt;/p&gt;
&lt;p&gt;Hidden towards the bottom of the post, we find:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In PureScript or OCaml, you can use open variant types to do this flawlessly. Haskell doesn’t have open variants, and the attempts to &amp;gt; mock them end up quite clumsy to use in practice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What Matt calls “open variant types” I call &lt;strong&gt;ad hoc union types&lt;/strong&gt; (see my previous post about &lt;a href=&quot;https://blog.jez.io/union-types-checked-exceptions/&quot;&gt;checked exceptions and Sorbet&lt;/a&gt;). Naming aside, Sorbet has them! We don’t have to suffer from clunky error handling!&lt;/p&gt;
&lt;p&gt;I thought it’d be interesting to show what Matt meant in this quote by translating his example to Sorbet.&lt;/p&gt;
&lt;p&gt;I wrote a complete, working example, but rather than repeat the whole thing here, I’m just going to excerpt the good stuff. If you’re wondering how something is defined in full, check the full example:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0A%0A%23%20This%20is%20a%20re-implementation%20of%20Matt%20Parsons&amp;#39;s%20%22The%20Trouble%20with%20Typed%0A%23%20Errors%22%20in%20Sorbet%20(Ruby)%20because%20I%20think%20Sorbet%20happens%20to%20handle%20it%0A%23%20pretty%20well%20all%20things%20considered.%0A%23%0A%23%20%20%20%20%20%3Chttps%3A%2F%2Fwww.parsonsmatt.org%2F2018%2F11%2F03%2Ftrouble_with_typed_errors.html%3E%0A%23%0A%23%20Specifically%2C%20he%20mentions%0A%23%0A%23%20%20%20%20%20In%20PureScript%20or%20OCaml%2C%20you%20can%20use%20open%20variant%20types%20to%20do%20this%0A%23%20%20%20%20%20flawlessly.%0A%23%0A%23%20and%20Sorbet%20more%20or%20less%20has%20those%20(untagged%20unions).%20It&amp;#39;s%20interesting%0A%23%20to%20see%20what%20that%20means%20for%20being%20able%20to%20track%20errors%2C%20because%20we%0A%23%20actually%20use%20Sorbet%20in%20a%20huge%20codebase%20at%20work.%20Tracking%20all%20the%20kinds%0A%23%20of%20errors%20that%20could%20happen--and%20no%20more--can%20make%20code%20far%20easier%20to%0A%23%20understand.%0A%0A%23%20To%20run%20this%20file%3A%0A%23%0A%23%20%20%20gem%20install%20sorbet-runtime%0A%23%20%20%20ruby%20typed-errors.rb%0A%0Arequire%20&amp;#39;sorbet-runtime&amp;#39;%0A%0A%23%20There&amp;#39;s%20a%20bug%20in%20Sorbet%20that%20forces%20us%20to%20wrap%20all%20this%20code%20in%20a%0A%23%20class%2C%20but%20I%20have%20a%20PR%20open%20to%20fix%20it.%20For%20now%2C%20we%20tolerate%20it.%0Aclass%20Main%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20%23%20-----%20Custom%20error%20types%20-----%0A%0A%20%20%23%20Defining%20custom%20data%20types%20is%20a%20little%20clunky%20in%20Ruby%20%2F%20Sorbet.%20You%0A%20%20%23%20have%20to%20chose%20whether%20you%20want%20a%20plain%20class%2C%20an%20enum%2C%20a%20sealed%0A%20%20%23%20class%20hierarchy%2C%20etc.%20In%20a%20real%20codebase%2C%20I%20think%20if%20you%20were%20going%0A%20%20%23%20to%20this%20length%20to%20care%20for%20errors%20the%20kinds%20of%20errors%20that%20you%20have%0A%20%20%23%20are%20usually%20pretty%20rich%20(e.g.%2C%20there&amp;#39;s%20a%20message%20and%20context%20with%0A%20%20%23%20the%20failures)%2C%20so%20you&amp;#39;d%20probably%20go%20with%20the%20sealed%20class%20hierarchy.%0A%20%20%23%0A%20%20%23%20For%20this%20example%2C%20I%20chose%20three%20different%20ways%20to%20just%20show%20them%20all.%0A%0A%20%20class%20HeadError%0A%20%20end%0A%0A%20%20class%20LookupError%20%3C%20T%3A%3AEnum%0A%20%20%20%20enums%20do%0A%20%20%20%20%20%20KeyWasNotPresent%20%3D%20new%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20module%20ParseError%0A%20%20%20%20extend%20T%3A%3AHelpers%0A%20%20%20%20sealed!%0A%0A%20%20%20%20class%20UnexpectedChar%20%3C%20T%3A%3AStruct%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20%20%20prop%20%3Amessage%2C%20String%0A%20%20%20%20end%0A%0A%20%20%20%20class%20RanOutOfInput%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Helper%20methods%20-----%0A%0A%20%20%23%20Again%2C%20concise%20syntax%20is%20not%20Sorbet&amp;#39;s%20strong%20suit.%20The%20signature%0A%20%20%23%20annotations%20are%20pretty%20verbose%20here%20(especially%20generics)%20but%20they%0A%20%20%23%20pretty%20much%20exactly%20map%20to%20the%20Haskell%20functions%20in%20the%20post.%0A%0A%20%20sig%20do%0A%20%20%20%20%20%20params(xs%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(String%2C%20HeadError))%0A%20%20end%0A%20%20def%20self.head(xs)%0A%20%20%20%20case%20xs.size%0A%20%20%20%20when%200%20then%20HeadError.new%0A%20%20%20%20else%20T.must(xs%5B0%5D)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters(%3AK%2C%20%3AV)%0A%20%20%20%20%20%20.params(%0A%20%20%20%20%20%20%20%20hash%3A%20T%3A%3AHash%5BT.type_parameter(%3AK)%2C%20T.type_parameter(%3AV)%5D%2C%0A%20%20%20%20%20%20%20%20key%3A%20T.type_parameter(%3AK)%0A%20%20%20%20%20%20)%0A%20%20%20%20%20%20.returns(T.any(T.type_parameter(%3AV)%2C%20LookupError))%0A%20%20end%0A%20%20def%20self.lookup(hash%2C%20key)%0A%20%20%20%20if%20hash.key%3F(key)%0A%20%20%20%20%20%20hash.fetch(key)%0A%20%20%20%20else%0A%20%20%20%20%20%20LookupError%3A%3AKeyWasNotPresent%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20params(source%3A%20String).returns(T.any(Integer%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.parse(source)%0A%20%20%20%20case%20source%0A%20%20%20%20when%20%22%22%20then%20ParseError%3A%3ARanOutOfInput.new%0A%20%20%20%20else%0A%20%20%20%20%20%20begin%0A%20%20%20%20%20%20%20%20Integer(source%2C%2010)%0A%20%20%20%20%20%20rescue%20ArgumentError%20%3D%3E%20exn%0A%20%20%20%20%20%20%20%20ParseError%3A%3AUnexpectedChar.new(message%3A%20exn.message)%0A%20%20%20%20%20%20end%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Composing%20errors%20-----%0A%0A%20%20STR_MAP%20%3D%20T.let(%7B%0A%20%20%20%20%224__%22%20%3D%3E%20%222%22%0A%20%20%7D%2C%20T%3A%3AHash%5BString%2C%20String%5D)%0A%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20HeadError%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.foo(str)%0A%20%20%20%20%23%20These%20%60return%60%20lines%20are%20definitely%20not%20as%20convenient%20as%20do%0A%20%20%20%20%23%20notation%20in%20Haskell%2C%20but%20the%20interesting%20thing%20is%20that%20they&amp;#39;re%0A%20%20%20%20%23%20still%20pretty%20nice%3A%20because%20of%20flow-sensitive%20typing%2C%20the%20type%20of%0A%20%20%20%20%23%20%60c%60%20changes%2C%20as%20commented%3A%0A%20%20%20%20c%20%3D%20head(str)%20%23%20%3D%3E%20c%20%3A%20T.any(String%2C%20HeadError)%0A%20%20%20%20return%20c%20unless%20c.is_a%3F(String)%0A%20%20%20%20%23%20%3D%3E%20c%20%3A%20String%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(%22%23%7Bc%7D%23%7Br%7D%22)%0A%20%20end%0A%0A%20%20%23%20This%20method%20doesn&amp;#39;t%20call%20%60head%60%20like%20before%2C%20so%20it%20doesn&amp;#39;t%20need%20to%0A%20%20%23%20have%20%60HeadError%60%20in%20the%20return%20type.%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.bar(str)%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(r)%0A%20%20end%0A%0A%20%20p%20foo(%224__%22)%0A%20%20p%20bar(%224__%22)%0Aend%0A%0A%23%20Because%20%60T.any%60%20can%20create%20ad%20hoc%2C%20untagged%20union%20types%20anywhere%2C%0A%23%20there&amp;#39;s%20no%20need%20to%20define%20an%20%60AllErrorsEver%60%20data%20type%20like%20the%20reader%0A%23%20was%20tempted%20to%20in%20the%20Typed%20Errors%20blog%20post.%0A%23%0A%23%20If%20you%20find%20that%20a%20particular%20set%20of%20errors%20are%20showing%20up%20super%0A%23%20frequently%2C%20you%20can%20lurk%20them%20into%20a%20type%20alias%3A%0A%23%0A%23%20%20%20%20%20MostCommonErrors%20%3D%20T.type_alias%20%7BT.any(LookupError%2C%20ParseError)%7D%0A%23%0A%23%20and%20then%20use%20this%20alias%20in%20various%20places.%0A%23%0A%23%20One%20other%20note%3A%20to%20make%20this%20pattern%20nicer%2C%20code%20might%20want%20to%0A%23%20explicitly%20box%20up%20successful%20results%2C%20with%20a%20type%20like%0A%23%0A%23%20%20%20%20%20class%20Ok%20%3C%20T%3A%3AStruct%0A%23%20%20%20%20%20%20%20extend%20T%3A%3AGeneric%0A%23%20%20%20%20%20%20%20Type%20%3D%20type_member%0A%23%20%20%20%20%20%20%20prop%20%3Aval%2C%20Type%0A%23%20%20%20%20%20end%0A%23%0A%23%20So%20then%20you&amp;#39;d%20have%0A%23%20%20%20%20%20T.any(Ok%5BString%5D%2C%20MostCommonErrors)%0A%23%20and%20you%20could%20do%20make%20all%20the%20%60return%60%20lines%20always%20look%20the%20same%3A%0A%23%20%20%20%20%20return%20x%20unless%20x.is_a%3F(Ok)%0A%23%20but%20the%20flipside%20would%20mean%20that%20you&amp;#39;d%20have%20to%20use%20%60.val%60%20at%20all%20the%0A%23%20places%20that%20you%20would%20have%20normally%20used%20%60x%60%3A%0A%23%20%20%20%20%20parse(x.val)%0A%23%20so%20it&amp;#39;s%20maybe%20not%20worth%20it.%0A%0A&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First, here’s how we’d type the three running helper methods from Matt’s post:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Returns the first letter of the input,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# or returns `HeadError` if empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;xs: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.head&lt;/span&gt;(xs); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Gets the value for `key` in `hash`, or returns LookupError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This is normally defined in the stdlib, and in trying to&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# match Matt&amp;#39;s post, it ends up not being super idiomatic,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# but the types still work out.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;hash: &lt;/span&gt;T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb1-16&quot;&gt;&lt;a href=&quot;#cb1-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;key: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-17&quot;&gt;&lt;a href=&quot;#cb1-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&quot;cb1-18&quot;&gt;&lt;a href=&quot;#cb1-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-19&quot;&gt;&lt;a href=&quot;#cb1-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-20&quot;&gt;&lt;a href=&quot;#cb1-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.lookup&lt;/span&gt;(hash, key); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; en&lt;/span&gt;
&lt;span id=&quot;cb1-21&quot;&gt;&lt;a href=&quot;#cb1-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-22&quot;&gt;&lt;a href=&quot;#cb1-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-23&quot;&gt;&lt;a href=&quot;#cb1-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Convert a String to an integer, or return ParseError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-24&quot;&gt;&lt;a href=&quot;#cb1-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;source: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-25&quot;&gt;&lt;a href=&quot;#cb1-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.parse&lt;/span&gt;(source); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice how in all three cases, we use a normal &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;Sorbet union type&lt;/a&gt; in the return, like &lt;code&gt;T.any(String, HeadError)&lt;/code&gt;. All of the error types are just user-defined classes. For example, &lt;code&gt;HeadError&lt;/code&gt; is just defined like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;ParseError&lt;/code&gt; is defined using &lt;a href=&quot;https://sorbet.org/docs/sealed&quot;&gt;sealed classes&lt;/a&gt; and &lt;a href=&quot;https://sorbet.org/docs/tstruct&quot;&gt;typed structs&lt;/a&gt; to approximate algebraic data types in other typed languages:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Helpers&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  sealed!&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnexpectedChar&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Struct&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    prop &lt;span class=&quot;wa&quot;&gt;:message&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RanOutOfInput&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then at the caller side, it’s simple to handle the errors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  c &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; head(str) &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : T.any(String, HeadError)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; c &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; c&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;c&lt;span class=&quot;sc&quot;&gt;}#{&lt;/span&gt;r&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that the return type includes the possible errors, so we have to handle them. This example handles the errors by checking for success and returning early with the error otherwise. This manifests in the return type of &lt;code&gt;foo&lt;/code&gt;, which mentions four outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a successful result (&lt;code&gt;Integer&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;three kinds of failures (&lt;code&gt;HeadError&lt;/code&gt;, &lt;code&gt;LookupError&lt;/code&gt;, and &lt;code&gt;ParseError&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would have worked equally well to handle and recover from any or all of the errors: Sorbet knows exactly which error is returned by which method, so there’s never a burden of handling more errors than are possible.&lt;/p&gt;
&lt;p&gt;It’s fun that what makes this work is Sorbet’s natural &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;flow-sensitive typing&lt;/a&gt;, not some special language feature. Notice how before and after the first early return, Sorbet updates its knowledge of the type of &lt;code&gt;c&lt;/code&gt; (shown in the comments) because it knows how &lt;code&gt;is_a?&lt;/code&gt; works.&lt;/p&gt;
&lt;p&gt;Another example: if some other method only calls &lt;code&gt;lookup&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; (but not &lt;code&gt;head&lt;/code&gt;), it doesn’t have to mention &lt;code&gt;HeadError&lt;/code&gt; in its return:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# does need to mention HeadError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb5-5&quot;&gt;&lt;a href=&quot;#cb5-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-6&quot;&gt;&lt;a href=&quot;#cb5-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.bar&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb5-7&quot;&gt;&lt;a href=&quot;#cb5-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb5-8&quot;&gt;&lt;a href=&quot;#cb5-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-9&quot;&gt;&lt;a href=&quot;#cb5-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(r)&lt;/span&gt;
&lt;span id=&quot;cb5-10&quot;&gt;&lt;a href=&quot;#cb5-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And while there’s never a &lt;strong&gt;need&lt;/strong&gt; to predeclare one monolithic error type (like &lt;code&gt;AllErrorsEver&lt;/code&gt; in Matt’s post), if it happens to be convenient, Sorbet still lets you, using type aliases. For example, maybe there are a bunch of methods that all return &lt;code&gt;LookupError&lt;/code&gt; and &lt;code&gt;ParseError&lt;/code&gt;. We can factor that out into a type alias:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;MostCommonErrors&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s it! Sorbet’s union types in method returns provide a low-friction, high value way to model how methods can fail.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home I really like this post from Matt Parsons, The Trouble with Typed Errors. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.</summary></entry><entry><title type="html">Sorbet Does Not Have Checked Exceptions</title><link href="https://blog.jez.io/union-types-checked-exceptions/" rel="alternate" type="text/html" title="Sorbet Does Not Have Checked Exceptions" /><published>2021-05-29T04:21:41-04:00</published><updated>2021-05-29T04:21:41-04:00</updated><id>https://blog.jez.io/union-types-checked-exceptions</id><content type="html" xml:base="https://blog.jez.io/union-types-checked-exceptions/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#background-sorbets-union-types&quot;&gt;Background: Sorbet’s union types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#example-from-checked-exceptions-to-union-types&quot;&gt;Example: From checked exceptions to union types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#analysis&quot;&gt;Analysis: Why the union types approach is better&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix&quot;&gt;Appendix: Checked Exceptions&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Here’s a common question I get asked about Sorbet:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Does Sorbet support checked exceptions, like Java?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(In fact, this was the &lt;a href=&quot;https://youtu.be/odmlf_ezsBo?t=1921&quot;&gt;first question&lt;/a&gt; I was asked at my &lt;a href=&quot;https://jez.io/talks/state-of-sorbet-2019/&quot;&gt;first conference talk&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The answer: Sorbet doesn’t support checked exceptions, and I don’t think it ever should.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Before I dive in, there are two pretexts I’m assuming: either you asked this question and someone linked you this post, or the post title was enough to catch your attention. Either way, I’m going to take for granted that you know what I mean by “checked exceptions.” If you want a quick refresher, jump down to the &lt;a href=&quot;#appendix&quot;&gt;Appendix&lt;/a&gt; and then come back.&lt;/p&gt;
&lt;p&gt;My claim is that checked exceptions are a poor man’s ad hoc union types, that since Sorbet has ad hoc union types it doesn’t need checked exceptions. I’ll discuss this claim in three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I’ll give some background on what it means for union types to be “ad hoc,” which applies to Sorbet’s union types but are somewhat rare.&lt;/li&gt;
&lt;li&gt;I’ll describe a translation from checked exceptions in Java to union-typed returns in Ruby with a concrete example.&lt;/li&gt;
&lt;li&gt;I’ll give evidence for why the union types approach is better.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(If you want to skip straight to the good stuff, the analysis &lt;a href=&quot;#analysis&quot;&gt;is down here&lt;/a&gt;.)&lt;/p&gt;
&lt;h1 id=&quot;background-sorbets-union-types&quot;&gt;Background: Sorbet’s union types&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The throws clause is the only point in the entire Java language that allows union types. You can tack “throws A,B,C” onto a method signature meaning it might throw A or B or C, but outside of the throws clause you cannot say “type A or B or C” in Java.&lt;/p&gt;
&lt;p&gt;— James Iry, &lt;em&gt;&lt;a href=&quot;http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html&quot;&gt;Checked Exceptions Might Have Their Place, But It Isn’t In Java&lt;/a&gt;&lt;/em&gt; (2012)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sorbet supports &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;union types&lt;/a&gt;. More specifically, Sorbet’s union types are ad hoc: any number of types can be unioned together on demand:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;returns(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(A, B, C))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo; &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By contrast, many languages with union types require predeclaring a union’s variants, for example in Rust:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode rust&quot;&gt;&lt;code class=&quot;sourceCode rust&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; AorBorC &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    A(A)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    B(B)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    C(C)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That Sorbet allows defining union types on demand is similar to Java’s &lt;code&gt;throws&lt;/code&gt; clause, but more powerful: &lt;code&gt;throws A, B, C&lt;/code&gt; is not a type, while &lt;code&gt;T.any(A, B, C)&lt;/code&gt; is. We’ll see why that matters below.&lt;/p&gt;
&lt;h1 id=&quot;example-from-checked-exceptions-to-union-types&quot;&gt;Example: From checked exceptions to union types&lt;/h1&gt;
&lt;p&gt;Using Sorbet’s ad hoc union types, it’s mechanical to convert Java-style checked exceptions to Sorbet-annotated Ruby. To demonstrate:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;parseCurrency&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;String&lt;/span&gt; currencyStr) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; currency = KNOWN_CURRENCIES.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(currencyStr);&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (currency == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;          &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39;&amp;quot;&lt;/span&gt; currencyStr + &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39; is not a valid currency&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; currency;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a somewhat contrived Java method, but it’ll be good enough to demonstrate the concepts.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;parseCurrency&lt;/code&gt; is given a string it can’t handle, it raises a &lt;code&gt;ParseException&lt;/code&gt;. It declares this with &lt;code&gt;throws&lt;/code&gt; because &lt;code&gt;ParseException&lt;/code&gt; is a checked exception. If the currency string is recognized, it returns some &lt;code&gt;Currency&lt;/code&gt; object.&lt;/p&gt;
&lt;p&gt;Here’s how we’d write that in Sorbet:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (0) Ruby&amp;#39;s standard library doesn&amp;#39;t have `ParseException`,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# so I&amp;#39;ve re-implemented it.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Struct&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  const &lt;span class=&quot;wa&quot;&gt;:message&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  const &lt;span class=&quot;wa&quot;&gt;:offset&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (1) return type + `throws` becomes just `returns`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (2) Return type uses `T.any`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;currency_str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Currency&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb4-13&quot;&gt;&lt;a href=&quot;#cb4-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-14&quot;&gt;&lt;a href=&quot;#cb4-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; parse_currency(currency_str)&lt;/span&gt;
&lt;span id=&quot;cb4-15&quot;&gt;&lt;a href=&quot;#cb4-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;KNOWN_CURRENCIES&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;currency_str&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-16&quot;&gt;&lt;a href=&quot;#cb4-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; currency&lt;span class=&quot;at&quot;&gt;.nil?&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-17&quot;&gt;&lt;a href=&quot;#cb4-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# (3) `throw` becomes `return`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-18&quot;&gt;&lt;a href=&quot;#cb4-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb4-19&quot;&gt;&lt;a href=&quot;#cb4-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;message: &lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;currency_str&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;#39; is not a valid currency&amp;quot;&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb4-20&quot;&gt;&lt;a href=&quot;#cb4-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;offset: &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-21&quot;&gt;&lt;a href=&quot;#cb4-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&quot;cb4-22&quot;&gt;&lt;a href=&quot;#cb4-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-23&quot;&gt;&lt;a href=&quot;#cb4-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-24&quot;&gt;&lt;a href=&quot;#cb4-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency&lt;/span&gt;
&lt;span id=&quot;cb4-25&quot;&gt;&lt;a href=&quot;#cb4-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important changes:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Where Java had a return type and a &lt;code&gt;throws&lt;/code&gt; clause, Sorbet just has a return type.&lt;/li&gt;
&lt;li&gt;Sorbet’s return type is a union type (&lt;code&gt;T.any(...)&lt;/code&gt;). It mentions the Java method’s return type and all the exceptions mentioned in the &lt;code&gt;throws&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Where the Java example uses &lt;code&gt;throw&lt;/code&gt;, the Ruby example uses &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Our translation isn’t complete until we see how the &lt;code&gt;parseCurrency&lt;/code&gt; caller side changes. In Java, we call &lt;code&gt;parseCurrency&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;Charge &lt;span class=&quot;fu&quot;&gt;createCharge&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; amount, &lt;span class=&quot;bu&quot;&gt;String&lt;/span&gt; currencyStr) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; currency = &lt;span class=&quot;fu&quot;&gt;parseCurrency&lt;/span&gt;(currencyStr);&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Charge&lt;/span&gt;(amount, currency);&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With Sorbet, this snippet becomes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;amount: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;currency_str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Charge&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; create_charge(amount, currency_str)&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; parse_currency(currency_str)&lt;/span&gt;
&lt;span id=&quot;cb6-7&quot;&gt;&lt;a href=&quot;#cb6-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; currency &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; currency&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Currency&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb6-8&quot;&gt;&lt;a href=&quot;#cb6-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-9&quot;&gt;&lt;a href=&quot;#cb6-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;dt&quot;&gt;Charge&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;amount: &lt;/span&gt;amount, &lt;span class=&quot;wa&quot;&gt;currency: &lt;/span&gt;currency)&lt;/span&gt;
&lt;span id=&quot;cb6-10&quot;&gt;&lt;a href=&quot;#cb6-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before, the &lt;code&gt;throws&lt;/code&gt; clause in Java becomes a union-typed return in Ruby.&lt;/p&gt;
&lt;p&gt;The new bit is the explicit &lt;code&gt;return ... unless ...&lt;/code&gt;. Whereas uncaught exceptions implicitly bubble up to the caller, return values only bubble up if explicitly returned. This is a key benefit of the union types approach, which brings us to our next section.&lt;/p&gt;
&lt;h1 id=&quot;analysis&quot;&gt;Analysis: Why the union types approach is better&lt;/h1&gt;
&lt;p&gt;To recap, Sorbet’s union types are ad hoc, much in the same sense as the classes mentioned in Java’s &lt;code&gt;throws&lt;/code&gt; clause. When converting from &lt;code&gt;Java&lt;/code&gt; to &lt;code&gt;Ruby&lt;/code&gt;, a single, union-typed return takes the place of a separate return type and &lt;code&gt;throws&lt;/code&gt; clause.&lt;/p&gt;
&lt;p&gt;First off, this translation preserves the best parts of checked exceptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A method’s failure modes still appear in an &lt;strong&gt;explicit, public API&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In both Java and Ruby, the method signature behaves as machine-checked error documentation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ad hoc error specifications enable &lt;strong&gt;low-friction composition&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In both Java and Ruby, if our method is the first to combine two methods with unrelated failure modes, there’s no ceremony to predeclare that combination. Instead, we just mention one more class in the method’s signature.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But this approach is not only as good, it’s better, because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;As a language feature, &lt;strong&gt;union types are not special&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Union types are types. Like other types, we can store them in variables. We can factor common error recovery code into helper functions. We can map functions returning union types over lists. We can write type aliases that abbreviate commonly-grouped error classes. We can’t do any of this with checked exceptions, and this is the most common complaint against them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Union types have &lt;strong&gt;call-site granularity&lt;/strong&gt;, not method-body granularity.&lt;/p&gt;
&lt;p&gt;The union types approach forces a choice of how to handle errors at each call site. This is more robust in the face of changing code, because new call sites should not necessarily inherit the error handling logic of existing call sites. Just because one &lt;code&gt;ParseException&lt;/code&gt; was uncaught and mentioned in the &lt;code&gt;throws&lt;/code&gt; does not mean all of them should be.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And finally, let me get out ahead of some common counter arguments.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The union types approach requires more typing at the call site!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yep. But I’ve already counted this as a blessing, not a curse.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But real-world Ruby code already uses exceptions!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yep. But in Java too, the world is already split into checked and unchecked exceptions. In both Java and Ruby, exceptions are a fact of life, and you’ll always need a way to deal with unexpected exceptions (e.g., comprehensive tests, automated production alerting, etc.).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With checked exceptions, I could handle all the failures at once!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s true; with checked exceptions, it’s easy to write a single &lt;code&gt;catch&lt;/code&gt; statement that handles all failures due to, say, a &lt;code&gt;ParseException&lt;/code&gt; in a whole region of code, avoiding the need for code repetition.&lt;/p&gt;
&lt;p&gt;The upshot is that with union types, we can just use functions. Take everything in the &lt;code&gt;catch&lt;/code&gt; body, put it in a helper function, and call it at each call site. This cuts down on duplication, and I already mentioned how call-site granularity is a win.&lt;/p&gt;
&lt;p&gt;That’s pretty much it. Sorbet doesn’t need checked exceptions, it already has ad hoc union types.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;appendix&quot;&gt;Appendix: Checked Exceptions&lt;/h1&gt;
&lt;p&gt;As a quick refresher, &lt;a href=&quot;https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions&quot;&gt;checked exceptions&lt;/a&gt; are a feature popularized by Java. The syntax looks like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doThing&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; MyException {&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;throws&lt;/code&gt; keyword is a part of the method’s signature, just like argument and return types. It declares that this method might throw &lt;code&gt;MyException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since it’s a part of this method’s signature the &lt;code&gt;throws&lt;/code&gt; annotation will be checked at all call sites (just like argument and return types). A method containing calls to &lt;code&gt;doThing&lt;/code&gt; must either &lt;code&gt;catch&lt;/code&gt; all mentioned exceptions or repeat any maybe-thrown-but-uncaught exceptions in its own &lt;code&gt;throws&lt;/code&gt; clause.&lt;/p&gt;
&lt;p&gt;If a method throws multiple classes of exceptions, they can all be listed:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doThing&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; MyException, YourException, AnotherException {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The argument in favor of checked exceptions is that they’re explicit and machine-checked. Users don’t have to guess at what a method might throw, or hope that there’s accurate documentation—all benefits shared by static typing in general, which is a sympathetic goal.&lt;/p&gt;
&lt;p&gt;Checked exceptions seem like a good feature on paper. In practice, they’re generally regretted. I’m nowhere near the first person to come to this conclusion, so instead I’ll link you to some previous discussions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.artima.com/articles/the-trouble-with-checked-exceptions&quot;&gt;The Trouble with Checked Exceptions&lt;/a&gt;, A Conversation with Anders Hejlsberg&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html&quot;&gt;Checked Exceptions Might Have Their Place, But It Isn’t In Java&lt;/a&gt;, by James Iry&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ericlippert.com/2008/09/10/vexing-exceptions/&quot;&gt;Vexing Exceptions&lt;/a&gt;, by Eric Lippert&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(The last one isn’t actually about checked exceptions: it’s just about exceptions and I like it, so I included it.)&lt;/p&gt;
&lt;p&gt;Java has been copied and imitated for decades. Among all the features we see other languages copy from Java, checked exceptions are absent.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home Here’s a common question I get asked about Sorbet:</summary></entry><entry><title type="html">Exploring Ruby with clangd</title><link href="https://blog.jez.io/clangd-ruby/" rel="alternate" type="text/html" title="Exploring Ruby with clangd" /><published>2020-07-21T18:40:23-04:00</published><updated>2020-07-21T18:40:23-04:00</updated><id>https://blog.jez.io/clangd-ruby</id><content type="html" xml:base="https://blog.jez.io/clangd-ruby/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#steps&quot;&gt;Steps&lt;/a&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#install-bear&quot;&gt;1. Install &lt;span&gt;Bear&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#clone-the-ruby-source-code.&quot;&gt;2. Clone the Ruby source code.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#configure-the-ruby-build.&quot;&gt;3. Configure the Ruby build.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#use-bear-to-invoke-make&quot;&gt;4. Use &lt;code&gt;bear&lt;/code&gt; to invoke &lt;code&gt;make&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thats-it&quot;&gt;5. That’s it!&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-building-bear-from-source&quot;&gt;Appendix: Building Bear from source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-lsp-in-neovim-with-languageclient-neovim&quot;&gt;Appendix: LSP in Neovim with LanguageClient-neovim&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’ve managed to get LSP-based IDE features powered by &lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; working for the Ruby VM’s source code (in my case, in Vim). Here’s how I did it!&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;I’ve been making a point to learn more about &lt;a href=&quot;/search-down-the-stack/&quot;&gt;things I depend on&lt;/a&gt; recently. Today, that means learning about Ruby. And what better way to learn than to check out the source code, and jump around?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; is an editor-agnostic language server that uses the &lt;a href=&quot;https://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt; to power IDE-like features in your preferred text editor. All it needs is a &lt;code&gt;compile_commands.json&lt;/code&gt;, which is basically a mapping of filename to options to pass to &lt;code&gt;clang&lt;/code&gt; so that it knows things like which warnings to enable and where to search for header files.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; works best for projects built using &lt;code&gt;cmake&lt;/code&gt;, but the Ruby VM doesn’t use &lt;code&gt;cmake&lt;/code&gt;. Regardless, we can make a &lt;code&gt;compile_commands.json&lt;/code&gt; file by using &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt; to trace the execution of a Ruby build, and use the trace information to write out a &lt;code&gt;compile_commands.json&lt;/code&gt; file.&lt;/p&gt;
&lt;h1 id=&quot;steps&quot;&gt;Steps&lt;/h1&gt;
&lt;p&gt;I could only get these steps to work for Linux, as the Bear README mentions that on macOS you have to disable System Integrity Protection to get it to work.&lt;/p&gt;
&lt;h2 id=&quot;install-bear&quot;&gt;1. Install &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I describe how I built Bear from source in the Appendix.&lt;/p&gt;
&lt;h2 id=&quot;clone-the-ruby-source-code.&quot;&gt;2. Clone the Ruby source code.&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; clone https://github.com/ruby/ruby&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; ruby&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;configure-the-ruby-build.&quot;&gt;3. Configure the Ruby build.&lt;/h2&gt;
&lt;p&gt;We have to tell the &lt;code&gt;configure&lt;/code&gt; script to use Clang to compile (or if you’re confident that your system compiler toolchain is Clang, you can just run &lt;code&gt;./configure&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Create the ./configure file&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;autoconf&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This only works when using clang to build Ruby&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;./configure&lt;/span&gt; CC=clang&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;use-bear-to-invoke-make&quot;&gt;4. Use &lt;code&gt;bear&lt;/code&gt; to invoke &lt;code&gt;make&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Bear will use a dynamically preloaded library to trace system calls that exec &lt;code&gt;clang&lt;/code&gt; processes, looking at things like the command line arguments given to Clang.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;bear&lt;/span&gt; make&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;thats-it&quot;&gt;5. That’s it!&lt;/h2&gt;
&lt;p&gt;The output is &lt;code&gt;./compile_commands.json&lt;/code&gt;, which should be non-empty. If it’s empty or just has &lt;code&gt;[]&lt;/code&gt;, it didn’t work. There’s some troubleshooting in the &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt; README.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;compile_commands.json&lt;/code&gt; file will be consumed by &lt;code&gt;clangd&lt;/code&gt; in your editor. Check &lt;a href=&quot;https://langserver.org&quot; class=&quot;uri&quot;&gt;https://langserver.org&lt;/a&gt; to find an LSP client for your preferred editor, and follow its setup instructions.&lt;/p&gt;
&lt;p&gt;Once you’ve built the &lt;code&gt;compile_commands.json&lt;/code&gt; file and configured your editor to use LSP with &lt;code&gt;clangd&lt;/code&gt;, you should be able to do things like Jump to Definition and Hover on the Ruby source code!&lt;/p&gt;
&lt;h1 id=&quot;appendix-building-bear-from-source&quot;&gt;Appendix: Building Bear from source&lt;/h1&gt;
&lt;p&gt;This is probably common knowledge for people who use &lt;code&gt;cmake&lt;/code&gt; regularly, but this is how I built Bear from source, because I built it on a machine where I didn’t have root so I couldn’t write to &lt;code&gt;/usr/local&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; clone https://github.com/rizsotto/Bear&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; Bear&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; build&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; build&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Install to $HOME/.local/bin instead of /usr/local/bin&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;cmake&lt;/span&gt; .. &lt;span class=&quot;st&quot;&gt;&amp;quot;-DCMAKE_INSTALL_PREFIX=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/.local&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt; -j&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;ex&quot;&gt;nproc&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt; install&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# → $HOME/.local/bin/bear exists now&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;appendix-lsp-in-neovim-with-languageclient-neovim&quot;&gt;Appendix: LSP in Neovim with LanguageClient-neovim&lt;/h1&gt;
&lt;p&gt;I use Neovim. My preferred LSP client is &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;. Here’s the parts of my Neovim config files that setup &lt;code&gt;clangd&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jez/dotfiles/blob/865a74d93d8ab1c28713ae0dcd53797b6c26dc6a/vim/plug-settings.vim#L576-L587&quot;&gt;→ &lt;code&gt;vim/plug-settings.vim&lt;/code&gt; in jez/dotfiles&lt;/a&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="vim" /><category term="debugging" /><summary type="html">← Return home I’ve managed to get LSP-based IDE features powered by clangd working for the Ruby VM’s source code (in my case, in Vim). Here’s how I did it!</summary></entry></feed>