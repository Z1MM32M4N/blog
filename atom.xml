<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2022-12-12T21:30:47-05:00</updated><id>https://blog.jez.io/atom.xml</id><title type="html">Jake Zimmerman</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Some Old Sorbet Compiler Notes</title><link href="https://blog.jez.io/old-compiler-notes/" rel="alternate" type="text/html" title="Some Old Sorbet Compiler Notes" /><published>2022-12-10T17:38:00-05:00</published><updated>2022-12-10T17:38:00-05:00</updated><id>https://blog.jez.io/old-compiler-notes</id><content type="html" xml:base="https://blog.jez.io/old-compiler-notes/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;‚Üê Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;From January 2020 to December 2021 I was primarily working on the &lt;a
href=&quot;https://sorbet.org/blog/2021/07/30/open-sourcing-sorbet-compiler&quot;&gt;Sorbet
Compiler&lt;/a&gt;, an experimental, ahead-of-time compiler for Ruby,
targeting native code. For most of that time, it was a mostly-secret,
internal-only project. Today I‚Äôm publishing a few of my old,
internal-facing notes about the compiler here to my blog.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;In July 2021 we open sourced the Sorbet Compiler,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;‚Ä¶ not so much because it was ready for widespread
adoption but largely because it made some internal logistics
easier!&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; but there‚Äôs not much written about it outside of Stripe.
It‚Äôs basically just the above blog post and this talk that Trevor
Elliott and I presented at RubyConf 2021:&lt;/p&gt;
&lt;!-- https://stackoverflow.com/a/38149485 --&gt;
&lt;div
style=&quot;position:relative; padding-bottom: 56.25%; height: 0; overflow: hidden;&quot;&gt;
&lt;p&gt;&lt;iframe
    style=&quot;position: absolute; top: 0; left: 0; width: 100%; height:100%;&quot;
    src=&quot;https://www.youtube-nocookie.com/embed/BH8S1htcHXY&quot;
    title=&quot;YouTube video player&quot;
    frameborder=&quot;0&quot;
    allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
    allowfullscreen&gt; &lt;/iframe&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;While I was working on the compiler internally, I wrote up some
informal notes about how the compiler worked and the potential it could
have. None of those notes were particularly privy to confidential
information‚Äîit was just that the compiler was not a public project at
the time, so it didn‚Äôt make sense to post them publicly.&lt;/p&gt;
&lt;p&gt;I‚Äôve gone back and taken those internal notes and published them here
to my blog. (Mostly, I just wanted to fill in the gaps on my blog.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Before reposting these Sorbet Compiler posts, I only
posted publicly five times in 2020 and twice in 2021 üòû&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;) Note that they are all quite old now, and may not be as
accurate as they were at the time of writing. I‚Äôve dated them with the
date they were published internally to reflect that, which means you‚Äôll
have to find them in the archives.&lt;/p&gt;
&lt;p&gt;Note that the compiler is &lt;strong&gt;still&lt;/strong&gt; not a project that
we would encourage anyone to use. At this point, it &lt;a
href=&quot;https://github.com/sorbet/sorbet/commits/master/compiler&quot;&gt;hasn‚Äôt
seen active development&lt;/a&gt; for the better part of the last year as
we‚Äôve focused on improvements to Sorbet itself (though we have kept the
test suite running, so things are unlikely to have slipped into complete
disrepair).&lt;/p&gt;
&lt;p&gt;The official word is still what‚Äôs written in the &lt;a
href=&quot;https://sorbet.org/blog/2021/07/30/open-sourcing-sorbet-compiler&quot;&gt;sorbet.org
blog post&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We want to be clear up front: the code is nowhere near ready for
external use right now, but we welcome you to read the code and give us
feedback on our approach!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Anyways, maybe you‚Äôll enjoy the assorted notes digging into some of
the compiler‚Äôs guts. If you have questions, feel free to reach out.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="meta" /><category term="sorbet" /><category term="sorbet-compiler" /><summary type="html">‚Üê Return home From January 2020 to December 2021 I was primarily working on the Sorbet Compiler, an experimental, ahead-of-time compiler for Ruby, targeting native code. For most of that time, it was a mostly-secret, internal-only project. Today I‚Äôm publishing a few of my old, internal-facing notes about the compiler here to my blog.</summary></entry><entry><title type="html">Don‚Äôt bury the lede in technical docs</title><link href="https://blog.jez.io/dont-bury-the-lede/" rel="alternate" type="text/html" title="Don‚Äôt bury the lede in technical docs" /><published>2022-11-29T21:21:10-05:00</published><updated>2022-11-29T21:21:10-05:00</updated><id>https://blog.jez.io/dont-bury-the-lede</id><content type="html" xml:base="https://blog.jez.io/dont-bury-the-lede/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;‚Üê Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I‚Äôve noticed that programmers really like to bury the lede. An easy
way to make technical writing stronger is to &lt;strong&gt;figure out the main
point, and then just say it&lt;/strong&gt; (before anything else). All the
supporting information can come after. Why does this strengthen the
piece?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Readers will find it easier to read.&lt;/strong&gt; Readers won‚Äôt
have to store all your supporting evidence in a mental queue while
waiting for a point to be made. Instead, they‚Äôll read the main point,
then check supporting evidence against that claim piece by piece (only
holding one piece of evidence in mind at a time).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The piece will sound more authoritative.&lt;/strong&gt; This falls
somewhat naturally out of the new structure‚Äîit‚Äôs a lot harder to use
weasel words to water down your main claims when they come first.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Skimming the piece will be more effective.&lt;/strong&gt; Skimming
becomes ineffective if the topic sentence is buried somewhere in a
paragraph, because skimmers will skip it.&lt;/p&gt;
&lt;p&gt;A suggestion: go so far as to write the claims into section headers.
Sometimes, this is just a technique I use while drafting, and I‚Äôll
change the section headers before publishing. But sometimes I‚Äôll
actually keep those headings in the finished product. It‚Äôs nice because
headings have to be short: short headings imply short, focused claims,
which are strong claims. This doc isn‚Äôt long enough for section headers,
but I still did this for the title itself.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;I learned this technique from one of my college
professor‚Äôs ‚Äú&lt;a
href=&quot;https://graphics.stanford.edu/~kayvonf/misc/cleartalktips.pdf&quot;&gt;Tips
for Giving Clear Talks&lt;/a&gt;‚Äù presentation. It‚Äôs worth a read, as a lot of
the tips work for long-form writing as well as presentations. (I have a
local recording of the talk I can share if you‚Äôd like more than just the
slides.)&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Another suggestion: before publishing, try bolding the topic sentence
in each paragraph. First, it‚Äôll expose whether a paragraph‚Äôs main point
is buried at the bottom. But also, it‚Äôll expose whether your topic
sentence is a succinct: if a paragraph‚Äôs main point isn‚Äôt succinct,
there will be bold all over the place and maybe even bold in multiple
places. Like with the previous tip, sometimes I‚Äôll keep and sometimes
I‚Äôll drop these bolded claims before publishing (as you can see
above).&lt;/p&gt;
&lt;p&gt;Burying the lede manifests most frequently by programmers putting the
‚ÄúWhy‚Äù before the ‚ÄúWhat.‚Äù I have various theories why this is, but I
think it‚Äôs mostly because programmers feel like logical proofs need to
flow from assumptions to conclusions‚Äîthat by introducing the claim first
and supporting it second, they‚Äôre not being rigorous. Another theory:
people think that they need to make their writing more entertaining by
making it ‚Äúsuspenseful.‚Äù Suspense rarely improves technical writing,
where the focus is on conveying facts quickly.&lt;/p&gt;
&lt;p&gt;Here‚Äôs two common examples of putting why before what, and how
inverting things makes the writing stronger:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A ‚Äúlook at what I did‚Äù email that puts the ‚Äúbackground‚Äù section
ahead of the ‚Äúimpact‚Äù section.&lt;/p&gt;
&lt;p&gt;Unless you‚Äôre really good at narration (funny, clever, etc.), the
background is going to be more boring than the impact you‚Äôre announcing.
Leading with impact is the easiest tool you have in an email to wow the
reader and capture their attention. Once captivated, they‚Äôll continue
with your background for more details, or decide that they don‚Äôt need
to.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A help doc structured like ‚ÄúHere‚Äôs something incorrect that you
could do you do. Here‚Äôs why it‚Äôs a problem. You need to do this
instead.‚Äù&lt;/p&gt;
&lt;p&gt;Writing the claim first anchors all further examples on what to pay
attention to. Here‚Äôs an &lt;a
href=&quot;https://sorbet.org/docs/attached-class#tattached_class-as-an-argument&quot;&gt;example
in the Sorbet docs&lt;/a&gt; about using &lt;code&gt;T.attached_class&lt;/code&gt; in an
argument. Note how the first sentence is ‚Äúyou can‚Äôt do this, because of
soundness problems.‚Äù The alternative would be to dive into the bad
example immediately, leaving readers wondering what the final point will
eventually be.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Don‚Äôt bury the lede. Instead, start by saying what you want to say,
and then follow up by supporting it. Your piece will sound stronger and
be more effective, and your readers will thank you.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="writing" /><summary type="html">‚Üê Return home I‚Äôve noticed that programmers really like to bury the lede. An easy way to make technical writing stronger is to figure out the main point, and then just say it (before anything else). All the supporting information can come after. Why does this strengthen the piece?</summary></entry><entry><title type="html">Tips for large-scale codemods</title><link href="https://blog.jez.io/codemods-tips/" rel="alternate" type="text/html" title="Tips for large-scale codemods" /><published>2022-11-12T21:34:51-05:00</published><updated>2022-11-12T21:34:51-05:00</updated><id>https://blog.jez.io/codemods-tips</id><content type="html" xml:base="https://blog.jez.io/codemods-tips/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#the-unreasonable-effectiveness-of-regular-expressions&quot;
  id=&quot;toc-the-unreasonable-effectiveness-of-regular-expressions&quot;&gt;1. The
  unreasonable effectiveness of regular expressions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#when-regex-arent-good-enough&quot;
  id=&quot;toc-when-regex-arent-good-enough&quot;&gt;2. When regex aren‚Äôt good
  enough&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#managing-the-life-cycle-of-a-codemod&quot;
  id=&quot;toc-managing-the-life-cycle-of-a-codemod&quot;&gt;3. Managing the life
  cycle of a codemod&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#how-will-i-know-if-the-change-is-okay&quot;
  id=&quot;toc-how-will-i-know-if-the-change-is-okay&quot;&gt;4. How will I know if
  the change is okay?&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I get the sense that a lot of people looking for advice on how to run
a codemod are simply asking to be told, ‚Äúdon‚Äôt worry, they‚Äôre actually
easy.‚Äù Sometimes they are, but usually the people desperate for codemod
tips are also the people faced with running the gnarliest codemods.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The biggest tip I can offer is to shift your mindset. Some of the
tips below help make codemods less painful, but after a certain scale,
codemods are never going to be pain-free. In fact &lt;strong&gt;that‚Äôs
okay&lt;/strong&gt;, because it means the work is high-leverage‚Äîyou‚Äôre one
person sucking up the pain for the benefit of dozens, hundreds, or even
thousands of others. They get to ignore all the pain, and you get to
claim all the impact.&lt;/p&gt;
&lt;p&gt;That‚Äôs tip 0: don‚Äôt let the fact that you know a codemod will be
painful keep you from doing it. Like anything else, balance the pain
with the payoff, and make a judgement call.&lt;/p&gt;
&lt;p&gt;Alright cool now let‚Äôs dive into some more tactical tips.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h1 id=&quot;the-unreasonable-effectiveness-of-regular-expressions&quot;&gt;1. The
unreasonable effectiveness of regular expressions&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;A regex-based, find-and-replace tool supporting multiline
matches&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;If you don‚Äôt have a preferred tool that meets these
criteria, just use &lt;a
href=&quot;https://github.com/facebookincubator/fastmod&quot;&gt;fastmod&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; is often the only tool you need.&lt;/p&gt;
&lt;p&gt;You probably already know how to use regular expressions, so you can
get started quickly and usually finish just as fast‚Äîeither regex will be
powerful enough to solve the problem outright, or let you prototype fast
enough to realize, ‚Äúyeah no, I‚Äôm definitely gonna need something more
powerful for this.‚Äù&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don‚Äôt give up so quickly on regex.&lt;/p&gt;
&lt;p&gt;Three or four oddly-specific regex can often take the place of an
impossibly perfect regex. If you‚Äôre struggling to find one regex that
magically works in all cases, try making the regex so specific that you
know it won‚Äôt handle all the cases. The aim is to knock out the easiest
80% of cases, and then either repeat or fix the rest manually.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use age-old tricks like using &lt;code&gt;def foo\b&lt;/code&gt;,
&lt;code&gt;\.foo\(\b&lt;/code&gt;, &lt;code&gt;= foo\(\b&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;The first one matches method definitions with the name
&lt;code&gt;foo&lt;/code&gt;. The latter two match calls to &lt;code&gt;foo&lt;/code&gt; methods
but not definitions.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Mostly. But again, that‚Äôs the whole point.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; (This is basically the same tip as the last one.)&lt;/p&gt;
&lt;p&gt;This won‚Äôt be as robust as using some sort of AST-based codemod tool,
but it‚Äôs way easier to remember than whatever the API of such a tool is,
so you can start making progress quickly.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let the parser sanity-check your find-and-replace result.&lt;/p&gt;
&lt;p&gt;Here‚Äôs a trick for when your regex sometimes fails in a way that
causes a syntax error. First, run the regex and commit the result. Then
run the language‚Äôs parser over all the files, and list the files that
now have syntax errors.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;If the language doesn‚Äôt have a way to list only the
files with errors (and not the errors), just use &lt;code&gt;sed&lt;/code&gt; to
filter the command output.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Revert all the changes the regex made to those files.&lt;/p&gt;
&lt;p&gt;Chances are that a huge portion of the original find and replace
change was valid. The files whose changes had to be reverted can be
handled separately (either with another oddly-specific regex, or by
hand).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let the type checker be an input to your regex.&lt;/p&gt;
&lt;p&gt;Here‚Äôs another trick.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;I like these tricks because they‚Äôre easy to remember.
Just run a tool that your codebase already uses and post-process its
output. There‚Äôs basically no additional setup nor time spent learning an
esoteric codemod API.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; introduce a type error in such a way that the type
checker will report an error at every place you want to codemod.
(Sometimes this is as easy as changing a method definition‚Äôs name, and
sometimes it‚Äôs the fact that there are the type errors that you‚Äôre doing
the codemod in the first place.)&lt;/p&gt;
&lt;p&gt;Then, run the type checker to get a list of locations, and then
&lt;strong&gt;only&lt;/strong&gt; run the regex on those locations.&lt;/p&gt;
&lt;p&gt;This might mean simply ‚Äúrun on any matching files‚Äù but sometimes you
need something even more specific: ‚Äúrun on only the exact lines with
type errors.‚Äù I‚Äôve written some tools to do &lt;a
href=&quot;/surgery-on-code/&quot;&gt;exactly that&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let your test suite be an input to your regex.&lt;/p&gt;
&lt;p&gt;Like the previous tip, except using test-only print statements to get
the list of locations.&lt;/p&gt;
&lt;p&gt;For example, maybe we want to replace calls to
&lt;code&gt;old_method&lt;/code&gt; with &lt;code&gt;new_method&lt;/code&gt;. In Ruby, we could
do something like edit the implementation of &lt;code&gt;old_method&lt;/code&gt; to
log &lt;a
href=&quot;https://ruby-doc.org/core-2.7.2/Kernel.html#method-i-caller&quot;&gt;caller(1..1)&lt;/a&gt;
every time it‚Äôs called. After running our tests, the log will list every
call site to &lt;code&gt;old_method&lt;/code&gt; covered by our test suite, which we
can then use to selectively apply our regex (using those &lt;a
href=&quot;/surgery-on-code/&quot;&gt;custom codemod tools&lt;/a&gt; mentioned
before).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Let production logs be an input to your regex.&lt;/p&gt;
&lt;p&gt;This involves doing the same thing as the previous two tips above,
but using production log lines.&lt;/p&gt;
&lt;p&gt;When dealing with production you might want to specifically avoid
materializing a stack trace (because it can be slow), which is why you
probably want to try with test-only logging first. Of course, if
performance isn‚Äôt a problem, or it can tolerate a short-term degradation
during a codemod, go ahead.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;when-regex-arent-good-enough&quot;&gt;2. When regex aren‚Äôt good
enough&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;A few manual fixes are actually okay.&lt;/p&gt;
&lt;p&gt;The goal is to finish the codemod, not to 100% automate the
codemod.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This is true for most individuals doing codemods on
large, proprietary codebases. This might not apply to you if you
maintain some open-source tool and want to release an automated codemod
alongside a breaking API change.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; If you‚Äôve tried and failed to entirely automate the
codemod, there‚Äôs no shame in doing a little bit of manual work to fix
the rest of the cases.&lt;/p&gt;
&lt;p&gt;In my experience, anything smaller than ~75 files worth of things to
codemod can usually be done by hand in an afternoon in a pinch
(depending on how involved the change is). If the point is to finish the
migration as quickly as possible, you might get further by just rolling
up your sleeves for that last 10% than sinking another 3 days into
figuring out how to automate it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Your linter might have an API for writing auto-correctable lint
rules.&lt;/p&gt;
&lt;p&gt;Here are the docs for how to write fixers attached to custom &lt;a
href=&quot;https://eslint.org/docs/latest/developer-guide/working-with-rules#applying-fixes&quot;&gt;ESLint&lt;/a&gt;
and &lt;a
href=&quot;https://docs.rubocop.org/rubocop/development.html#autocorrect&quot;&gt;Rubocop&lt;/a&gt;
lint rules. The downside is that sometimes these APIs can be a little
foreign or confusing. But compared to regex they‚Äôre far less likely to
be brittle.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-5&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-5&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;A nice side effect of writing a custom linter rule is
that it can remain behind in the codebase, teaching people (via an error
message) what the replacement for an old API is after the original
codemod lands.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Note that just like with regex scripts, you can use information from
the type checker or the test suite to limit which files you use the lint
rule on if you have to.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It might finally be time for a language-specific, AST-based
codemod tool.&lt;/p&gt;
&lt;p&gt;While most languages have pluggable linters, some languages go a step
further and have dedicated codemod tools. These tend to be more common
in languages like JavaScript that already have a rich ecosystem of
source-to-source translation tools, but it‚Äôs possible to find them in
other languages too.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Maybe use Vim?&lt;/p&gt;
&lt;p&gt;If you‚Äôre already comfortable with Vim, it‚Äôs a great way to partially
automate the parts of the codemod that need manual intervention. Some
tools you might want to look at:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:help gf
  Edit the file whose name is under the cursor

:help gF
  Same as gf, but also position the cursor on the line number
  following the filename

:help CTRL-W_gf
:help CTRL-W_gF
  Prefixing gf or gF with &amp;lt;C-W&amp;gt; opens in a new tab (instead
  of the current buffer)

:help %
  Jump to the matching paren or bracket under the cursor.

:help q
:help @
  Record and replay arbitrary keys.&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;rg&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;-n&lt;/span&gt; ... &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;vim&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;-&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#               ^ reads content from stdin&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#  ^^ prefixes each result with filename:line&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check if your language supports pluggable static analyzers.&lt;/p&gt;
&lt;p&gt;This is basically the same approach as above, but as a first-class
feature of your language‚Äôs compiler. For example, Clang supports writing
&lt;a href=&quot;https://clang.llvm.org/docs/ClangPlugins.html&quot;&gt;compiler
plugins&lt;/a&gt; and C# has a &lt;a
href=&quot;https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/tutorials/how-to-write-csharp-analyzer-code-fix&quot;&gt;rich
static analyzer&lt;/a&gt; API. These APIs tend to be maximally powerful, as
they can leverage nearly everything the compiler knows about a codebase,
and sometimes more. You pay for it by these APIs tending to be the
hardest to learn to use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is an oddly specific suggestion, but since I do it a
lot:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt; does not support pluggable
static analyzers, but it does have an &lt;a
href=&quot;https://sorbet.org/docs/cli#accepting-autocorrect-suggestions&quot;&gt;autocorrect
mechanism&lt;/a&gt;, where autocorrects are tied to error messages.&lt;/p&gt;
&lt;p&gt;In the past I‚Äôve temporarily patched Sorbet (on a branch) to
introduce a new, fake error&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-6&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-6&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Had the &lt;em&gt;goal&lt;/em&gt; been to introduce an error in the
first place, then I would of course land both the error and the
autocorrect.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; that includes an autocorrect which can take advantage of
everything Sorbet knows. I run the patched version of Sorbet, apply the
autocorrects, then throw away the patch.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;managing-the-life-cycle-of-a-codemod&quot;&gt;3. Managing the life cycle
of a codemod&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Split the change into commits which are either entirely automated
or entirely manual.&lt;/p&gt;
&lt;p&gt;Be very rigorous and do not edit an automated change in the same
commit. This makes fixing conflicts easier (automated commits with
conflicts are simply thrown away and regenerated).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Clearly label which commits are automated and which are
manual.&lt;/p&gt;
&lt;p&gt;This makes it easier for your reviewer, and for you to figure out the
best way to resolve conflicts.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Put the full command itself in the commit title for automated
commits.&lt;/p&gt;
&lt;p&gt;That when a rebase fails midway, you‚Äôll see the command used to
generate that commit directly in the status message. It‚Äôs also nice for
your reviewer, because they can review both the command that generated
the change and the change itself.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When rebasing, don‚Äôt &lt;code&gt;pick&lt;/code&gt; the automated commits,
re-generate them.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-7&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-7&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This is also another reason why regex-based tooling is
great, as regex commands are usually fast enough to run during a rebase
without having to pause and wait for the codebase to rebuild mid
rebase.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is not simply to avoid conflicts, but also to catch any new
locations that have been added between when you started the codemod and
now.&lt;/p&gt;
&lt;p&gt;If you‚Äôre using the previous convention for Git commit messages, this
is as easy as using &lt;code&gt;git rebase -i&lt;/code&gt; and changing
&lt;code&gt;pick abc123 ...&lt;/code&gt; lines to simply
&lt;code&gt;exec ...&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run the codemod in three phases: prep, codemod, cleanup.&lt;/p&gt;
&lt;p&gt;Say you want to delete a deprecated method and replace it with a new
one. Prep by adding the new method in its own change, and land that
change. Run and land the codemod, but don‚Äôt delete the old method.
Finally cleanup by removing the method.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Land enough prep changes that it‚Äôs possible to run old and new
code simultaneously.&lt;/p&gt;
&lt;p&gt;This won‚Äôt always be possible, but it‚Äôs worth striving for in every
change. If the old and new code can live side by side, it‚Äôll be easier
to land the change and importantly, to revert &lt;em&gt;parts&lt;/em&gt; of a change
(if there are problems) without having to rollback the entire
change.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Consider ignoring conflicts and fixing them later.&lt;/p&gt;
&lt;p&gt;Sometimes right as you‚Äôre about to land a codemod, another change
sneaks in that conflicts with it. Rather than re-running the whole
codemod or attempting to fix the conflicts, consider just getting rid of
your changes in files with conflicts, and landing the remaining files
that don‚Äôt have conflicts.&lt;/p&gt;
&lt;p&gt;After the first lands, you can land a second codemod change which
modifies only the files that got dropped from the previous change.&lt;/p&gt;
&lt;p&gt;(This obviously only works if you‚Äôve landed enough prep
changes.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If you expect a codemod to be &lt;strong&gt;really&lt;/strong&gt; long-lived,
structure the whole thing as one big script.&lt;/p&gt;
&lt;p&gt;It might look something like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre
class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Always run the migration fresh against origin/master&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; reset &lt;span class=&quot;at&quot;&gt;--hard&lt;/span&gt; origin/master&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# These prep branches are are still being reviewed and landed&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Merge instead of rebase because it&amp;#39;s simpler in the script.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (They might not all be stacked on each other, so they can be reviewed&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# and landed on their own.)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# As these branches land upstream, delete them from the script.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; merge prep-branch-1 prep-branch-2&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# An example automated commit.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;#cb3-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Commit messages don&amp;#39;t have to be full commands anymore,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-15&quot;&gt;&lt;a href=&quot;#cb3-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# because we have the complete script anyways.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-16&quot;&gt;&lt;a href=&quot;#cb3-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;fastmod&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;some thing&amp;#39;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;other thing&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-17&quot;&gt;&lt;a href=&quot;#cb3-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; commit &lt;span class=&quot;at&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;replace with other thing&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-18&quot;&gt;&lt;a href=&quot;#cb3-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-19&quot;&gt;&lt;a href=&quot;#cb3-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# These commits are manual fixes to the automated commits.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-20&quot;&gt;&lt;a href=&quot;#cb3-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-21&quot;&gt;&lt;a href=&quot;#cb3-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Each manual patch get a branch name so the ref can be&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-22&quot;&gt;&lt;a href=&quot;#cb3-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# updated by the script each time.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-23&quot;&gt;&lt;a href=&quot;#cb3-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;! &lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; cherry-pick manual-patch-1&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;then&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-24&quot;&gt;&lt;a href=&quot;#cb3-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;bu&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;Fix conflicts and commit in another session, then press Enter...&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-25&quot;&gt;&lt;a href=&quot;#cb3-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-26&quot;&gt;&lt;a href=&quot;#cb3-26&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; checkout &lt;span class=&quot;at&quot;&gt;-B&lt;/span&gt; manual-patch-1&lt;/span&gt;
&lt;span id=&quot;cb3-27&quot;&gt;&lt;a href=&quot;#cb3-27&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-28&quot;&gt;&lt;a href=&quot;#cb3-28&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Note: now you can intermix automated and manual commits as needed,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-29&quot;&gt;&lt;a href=&quot;#cb3-29&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# growing the script as needed.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you should never need to rebase, and can always re-run the script
when the code changes.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;how-will-i-know-if-the-change-is-okay&quot;&gt;4. How will I know if the
change is okay?&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Rely on your existing safety rails.&lt;/p&gt;
&lt;p&gt;Ideally, your codebase has a type checker, a great test suite, some
sort of gradual deploy procedures, and automated alerting.&lt;/p&gt;
&lt;p&gt;If not, maybe take the ‚Äúmove fast and break things‚Äù approach, where
you land the codemod, and if landing it causes problems, the breakage
has shown you the specific places in your infra that could be improved
(like which tests to write, or which alerts to add). Also if you landed
enough prep work, hopefully it‚Äôs possible to only revert the problems,
not the entire change.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For some codemods, it‚Äôs possible to write some sort of sanity
check.&lt;/p&gt;
&lt;p&gt;For example, when rolling out a code formatter, you might be able to
write a tool that says that the parsing the unformatted and formatted
files produces equivalent ASTs.&lt;/p&gt;
&lt;p&gt;Another trick is to add some sort of debug assertion that an old
method is never called (or that a method is always called in some
post-codemod way), but still pass through to the old behavior in
production.&lt;/p&gt;
&lt;p&gt;It‚Äôs common to write these debug assertions such that they cause hard
failures in tests, but in production only log an error. These logs can
then be collected and fixed in a follow-up change.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Like I said up front, codemods involve pain. Some of the tips
mentioned here can help ease the pain, but the codemod is only really
going to succeed if you embrace the pain and power through. With any
luck, you‚Äôll find that you had fun&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-8&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-8&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;For further reading, &lt;a
href=&quot;https://www.rei.com/blog/climb/fun-scale&quot;&gt;The Fun Scale&lt;/a&gt;. With
any luck, you‚Äôll manage to avoid type 3 fun, and come back to run
another codemod in the future.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; when you get to announce that it‚Äôs finished.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="codemods" /><category term="devprod" /><summary type="html">‚Üê Return home I get the sense that a lot of people looking for advice on how to run a codemod are simply asking to be told, ‚Äúdon‚Äôt worry, they‚Äôre actually easy.‚Äù Sometimes they are, but usually the people desperate for codemod tips are also the people faced with running the gnarliest codemods.</summary></entry><entry><title type="html">Sorbet‚Äôs weird approach to exception handling</title><link href="https://blog.jez.io/sorbet-rescue-control-flow/" rel="alternate" type="text/html" title="Sorbet‚Äôs weird approach to exception handling" /><published>2022-09-04T23:12:12-04:00</published><updated>2022-09-04T23:12:12-04:00</updated><id>https://blog.jez.io/sorbet-rescue-control-flow</id><content type="html" xml:base="https://blog.jez.io/sorbet-rescue-control-flow/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#control-flow-and-rescue-in-sorbet&quot;
  id=&quot;toc-control-flow-and-rescue-in-sorbet&quot;&gt;Control flow and
  &lt;code&gt;rescue&lt;/code&gt; in Sorbet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#a-brief-history-of-rescue-in-sorbet&quot;
  id=&quot;toc-a-brief-history-of-rescue-in-sorbet&quot;&gt;A brief history of
  &lt;code&gt;rescue&lt;/code&gt; in Sorbet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-bigger-picture&quot; id=&quot;toc-the-bigger-picture&quot;&gt;The
  bigger picture&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Here‚Äôs a fun bug in Sorbet:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource ruby numberLines hl-11 hl-12&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; example&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;    loop_count &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;      loop_count &lt;span class=&quot;kw&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;rescue&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Interrupt&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; loop_count&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Looped &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;loop_count&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; times&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: This code is unreachable&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a
href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0A%0Adef%20example%0A%20%20begin%0A%20%20%20%20loop_count%20%3D%200%0A%0A%20%20%20%20while%20true%0A%20%20%20%20%20%20sleep%281%29%0A%20%20%20%20%20%20loop_count%20%2B%3D%201%0A%20%20%20%20end%0A%20%20rescue%20Interrupt%0A%20%20%20%20if%20loop_count%0A%20%20%20%20%20%20puts%28%22Looped%20%23%7Bloop_count%7D%20times%22%29%0A%20%20%20%20end%0A%20%20end%0Aend&quot;&gt;‚ÜíView
on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Sorbet thinks that &lt;code&gt;loop_count&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; at the
start of the &lt;code&gt;rescue&lt;/code&gt; block, which causes it to declare the
&lt;code&gt;puts&lt;/code&gt; line unreachable (because &lt;code&gt;nil&lt;/code&gt; is never
truthy).&lt;/p&gt;
&lt;p&gt;But why? Clearly we can see that &lt;code&gt;loop_count&lt;/code&gt; is an
&lt;code&gt;Integer&lt;/code&gt;. We‚Äôd expect Sorbet to &lt;em&gt;at least&lt;/em&gt; think
&lt;code&gt;loop_count&lt;/code&gt; has type &lt;code&gt;T.nilable(Integer)&lt;/code&gt;, if not
simply &lt;code&gt;Integer&lt;/code&gt; outright.&lt;/p&gt;
&lt;p&gt;Sometimes Sorbet takes shortcuts‚Äîespecially when the short cut is
good enough 99% of the time while being simple and fast. Sorbet‚Äôs
approach to &lt;code&gt;rescue&lt;/code&gt; and exception handling is one of these
shortcuts.&lt;/p&gt;
&lt;h1 id=&quot;control-flow-and-rescue-in-sorbet&quot;&gt;Control flow and
&lt;code&gt;rescue&lt;/code&gt; in Sorbet&lt;/h1&gt;
&lt;p&gt;I mentioned in &lt;a href=&quot;/syntactic-control-flow/&quot;&gt;my last post&lt;/a&gt;
that Sorbet builds a &lt;span class=&quot;smallcaps&quot;&gt;&lt;strong&gt;control flow
graph&lt;/strong&gt;&lt;/span&gt; (CFG) in order to model control-flow sensitive
types throughout the body of a method. For &lt;code&gt;rescue&lt;/code&gt; nodes, it
pretends that there are only two jumps into the &lt;code&gt;rescue&lt;/code&gt;
block: once &lt;strong&gt;before any&lt;/strong&gt; any code in the
&lt;code&gt;begin&lt;/code&gt; block has run, and once after all the code in
&lt;code&gt;begin&lt;/code&gt; block has run. It looks a little something like
this:&lt;/p&gt;
&lt;div class=&quot;only-light-mode&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/img/rescue-cfg-light-mode.png&quot;
alt=&quot;An example CFG with a rescue block&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;An example CFG with a &lt;code&gt;rescue&lt;/code&gt;
block&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;only-dark-mode&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/img/rescue-cfg-dark-mode.png&quot;
alt=&quot;An example CFG with a rescue block&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;An example CFG with a &lt;code&gt;rescue&lt;/code&gt;
block&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;This is a simplified view of a CFG in Sorbet.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;If you have &lt;a
href=&quot;https://graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; installed, you can get Sorbet
to dump its internal CFG for a given file with the
&lt;code&gt;cfg-view.sh&lt;/code&gt; script in the Sorbet repo. The CFG for the
example above looks like &lt;a
href=&quot;/assets/img/rescue-example-01.svg&quot;&gt;like this&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; The boxes contain hunks of straight-line code (code
without control flow), and all control flow is made explicit by
branching on a specified variable at the end of each block. For the case
of &lt;code&gt;rescue&lt;/code&gt;, the branches read from a magical
&lt;code&gt;&amp;lt;exn-value&amp;gt;&lt;/code&gt; variable, which Sorbet treats as &lt;span
class=&quot;smallcaps&quot;&gt;&lt;strong&gt;unanalyzable&lt;/strong&gt;&lt;/span&gt;: Sorbet doesn‚Äôt
attempt to track how the value is initialized nor how control flow
affects it.&lt;/p&gt;
&lt;p&gt;Knowing this, we can explain the weird dead code error from the
snippet above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first jump into the &lt;code&gt;rescue&lt;/code&gt; block happens before any
code in the &lt;code&gt;begin&lt;/code&gt; block runs. At that point, the
&lt;code&gt;loop_count&lt;/code&gt; variable is still uninitialized, and thus has
type &lt;code&gt;NilClass&lt;/code&gt; when taking that branch.&lt;/li&gt;
&lt;li&gt;The second jump into the &lt;code&gt;rescue&lt;/code&gt; block happens after the
&lt;code&gt;begin&lt;/code&gt; block finishes. But from Sorbet‚Äôs point of view, the
&lt;code&gt;begin&lt;/code&gt; block in the &lt;code&gt;loop_count&lt;/code&gt; snippet never
finishes! Sorbet sees the infinite &lt;code&gt;while true&lt;/code&gt; loop and
says, ‚Äúit doesn‚Äôt matter where to branch at the end of the
&lt;code&gt;begin&lt;/code&gt; block‚Äîthe infinite loop won‚Äôt allow control to flow
there.‚Äù&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;If you‚Äôre fearless, you can prove that this is what‚Äôs
happening in the &lt;a href=&quot;/assets/img/rescue-example-01.svg&quot;&gt;rendered
CFG&lt;/a&gt; for the above example.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Despite it being able to tell that
&lt;code&gt;loop_count&lt;/code&gt; has type &lt;code&gt;Integer&lt;/code&gt; inside the
&lt;code&gt;begin&lt;/code&gt;, only the &lt;code&gt;NilClass&lt;/code&gt; branch is live in the
&lt;code&gt;rescue&lt;/code&gt; block.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That second point about &lt;code&gt;while true&lt;/code&gt; is &lt;a
href=&quot;https://github.com/sorbet/sorbet/issues/4108&quot;&gt;simply a bug&lt;/a&gt;.
Sorbet should be smart enough to suspend the normal flow-sensitivity
rules for infinite loops while checking code in a &lt;code&gt;begin&lt;/code&gt;
block that has a &lt;code&gt;rescue&lt;/code&gt;.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Of course, easier said than done.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; But still, fixing that bug would only fix half the
problem: Sorbet would think that &lt;code&gt;loop_count&lt;/code&gt; has type
&lt;code&gt;T.nilable(Integer)&lt;/code&gt; in the &lt;code&gt;rescue&lt;/code&gt; body, but we
said the best outcome would be for Sorbet to know that
&lt;code&gt;loop_count&lt;/code&gt; is &lt;strong&gt;always&lt;/strong&gt; initialized, having
type &lt;code&gt;Integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Before we can see what it would take for Sorbet to infer
&lt;code&gt;Integer&lt;/code&gt;, some history.&lt;/p&gt;
&lt;h1 id=&quot;a-brief-history-of-rescue-in-sorbet&quot;&gt;A brief history of
&lt;code&gt;rescue&lt;/code&gt; in Sorbet&lt;/h1&gt;
&lt;p&gt;Sorbet‚Äôs &lt;a
href=&quot;https://github.com/sorbet/sorbet/commit/9189734a6c061071c3d3cd4398a5d7874a8c0c49&quot;&gt;first
commit&lt;/a&gt; dates to October 3, 2017. Six weeks later, the &lt;a
href=&quot;https://github.com/sorbet/sorbet/commit/afb234741f4ccd98ca2903d1621746c64a2da5ab&quot;&gt;initial
support for &lt;code&gt;rescue&lt;/code&gt;&lt;/a&gt; landed. The pull request description
is from a time when all pull requests were not public, so I‚Äôll quote it
here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This does most of the work in the CFG, preserving the semantics in
the desugarer. [‚Ä¶]&lt;/p&gt;
&lt;p&gt;It introduces a series of uncomputable &lt;code&gt;if&lt;/code&gt;s since 0 or
more instructions from the first block will execute then one of the
&lt;code&gt;rescue&lt;/code&gt;s could match and then if none do the
&lt;code&gt;else&lt;/code&gt; will match.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The approach it‚Äôs describing is what most people might do
intuitively: any instruction in a &lt;code&gt;begin&lt;/code&gt; might raise,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This is not quite true: &lt;code&gt;x = 0&lt;/code&gt; doesn‚Äôt
raise, and Sorbet can &lt;a href=&quot;/syntactic-control-flow/&quot;&gt;see that
syntactically&lt;/a&gt;. This might be something to take advantage of in the
future.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; so let‚Äôs record an unanalyzable jump after each
instruction, into the &lt;code&gt;rescue&lt;/code&gt; block. In picture form:&lt;/p&gt;
&lt;div class=&quot;only-light-mode&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/img/rescue-cfg-multi-block-light-mode.png&quot;
alt=&quot;A diagram depicting the implementation described in the above commit&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;A diagram depicting the implementation
described in the above commit&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;div class=&quot;only-dark-mode&quot;&gt;
&lt;figure&gt;
&lt;img src=&quot;/assets/img/rescue-cfg-multi-block-dark-mode.png&quot;
alt=&quot;A diagram depicting the implementation described in the above commit&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;A diagram depicting the implementation
described in the above commit&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;Note how every line of the &lt;code&gt;begin&lt;/code&gt; body gets its own, tiny
basic block with an unanalyzable jump to the &lt;code&gt;rescue&lt;/code&gt; block,
or to the next line of the body. This implementation wouldn‚Äôt have
exhibited the bug in our &lt;code&gt;loop_count&lt;/code&gt; example‚Äîthere would be
a jump after the &lt;code&gt;loop_count = 0&lt;/code&gt; assignment into the
&lt;code&gt;rescue&lt;/code&gt; block, which would have been enough for Sorbet to
infer a type of &lt;code&gt;Integer&lt;/code&gt; (regardless of whether that
&lt;code&gt;while true&lt;/code&gt; bug were fixed method).&lt;/p&gt;
&lt;p&gt;But importantly, this original approach was thrown out, &lt;a
href=&quot;https://github.com/sorbet/sorbet/commit/a6ed41e0b8deee28ff592063934b28676ac77927#diff-c9b037996e9c16464e031136abe5d9df567c72f283d572b070d108228b733127R335-R342&quot;&gt;almost
exactly 9 months later&lt;/a&gt;&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;And only two days after I joined the team üòÖ&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;, when the shortcut we‚Äôve been discussing arrived. In
fact, a comment from that commit persists unchanged in the codebase
today:&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;p&gt;We have a simplified view of the control flow here but in practise it
has been reasonable on our codebase. We don‚Äôt model that each expression
in the &lt;code&gt;body&lt;/code&gt; or &lt;code&gt;else&lt;/code&gt; could throw, instead we
model only never running anything in the body, or running the whole
thing. To do this we have a magic Unanalyzable variable at the top of
the body using &lt;code&gt;rescueStartTemp&lt;/code&gt; and one at the end of the
else using &lt;code&gt;rescueEndTemp&lt;/code&gt; which can jump into the rescue
handlers.&lt;/p&gt;
&lt;figcaption&gt;
&lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e63d2893edecc30e3eda5cd3378e02b8996e866f/cfg/builder/builder_walk.cc#L761-L768&quot;&gt;‚Üí
View in &lt;code&gt;cfg/builder/builder_walk.cc&lt;/code&gt;&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;p&gt;Why adopt this shortcut approach if it &lt;em&gt;causes&lt;/em&gt; bugs like this
to happen? Well for starters, the original approach had an even more
insidious bug. Consider this example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;begin&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; might_raise()&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;rescue&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# Sorbet would assume `x` was always set&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(x)&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, the first instruction in the block is an assignment
(&lt;code&gt;x = ...&lt;/code&gt;). But Sorbet would only record the jump after the
assignment entirely, not between the method call and the assignment.
This meant Sorbet would think that &lt;code&gt;x&lt;/code&gt; was unconditionally
set, but in fact it‚Äôs &lt;strong&gt;not&lt;/strong&gt; set when
&lt;code&gt;might_raise()&lt;/code&gt; does actually raise. At the time, Sorbet
tripped this bug all the time on real-world code‚Äîthere were beta users
of Sorbet chiming in on the PR eagerly waiting for the bug to be fixed.
Meanwhile, code that looked like our &lt;code&gt;loop_count&lt;/code&gt; example
either did not exist or was simply rewritten&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-5&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-5&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;There‚Äôs an easy workaround: use &lt;code&gt;T.let&lt;/code&gt; to
pin the type of the variable outside the &lt;code&gt;begin&lt;/code&gt; block.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to avoid the bug.&lt;/p&gt;
&lt;p&gt;But this still doesn‚Äôt quite paint the full picture. I‚Äôve told you,
‚ÄúThere was a bug, and Sorbet fixed it by introducing another bug.‚Äù Which
leads us to out second point: having a lot of tiny, jumpy basic blocks
is slow to typecheck. There are lots of reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;After building a CFG, Sorbet does a bunch of post-processing on
it. For example, it computes which variables each basic block reads and
writes, tries to dealias variable writes, and merges adjacent blocks if
possible. When there are fewer basic blocks, these post-processing steps
run faster to begin with, and are more likely to drastically shrink the
CFG size (making type inference run faster).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When typechecking a method, every basic block in the CFG requires
its own &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/master/infer/environment.h#L127&quot;&gt;&lt;code&gt;Environment&lt;/code&gt;&lt;/a&gt;
data structure, which maps variables to their types within that block.
Sorbet either has to allocate a separate &lt;code&gt;Environment&lt;/code&gt; per
block (what it currently does) or incur complexity from making them &lt;a
href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;copy-on-write&lt;/a&gt;. &lt;a
href=&quot;https://blog.nelhage.com/post/why-sorbet-is-fast/&quot;&gt;Allocating is
slow&lt;/a&gt; and we really like to avoid complexity.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Before typechecking a basic block, Sorbet has to merge the
environments of all incoming blocks. Merging environments involves doing
slow type checking operations, like checking whether two
possibly-arbitrary types are subtypes of each other and allocating union
types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Not only are there more basic blocks, there are more
instructions! Each &lt;code&gt;&amp;lt;exn-value&amp;gt;&lt;/code&gt; variable has to be
populated before Sorbet can branch on it, and that each tiny basic block
has not only the single instruction inside it, but also an extra
instruction to initialize the &lt;code&gt;&amp;lt;exn-valu&amp;gt;&lt;/code&gt; variable.
That basically doubles the number of instructions Sorbet emits for a
&lt;code&gt;begin&lt;/code&gt; block, making more work for type inference.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The new ‚Äúonly before and after‚Äù shortcut is pretty clever. In
practice, it models the case when even the very first assignment might
raise, while generating far fewer basic blocks, thus running much
faster.&lt;/p&gt;
&lt;h1 id=&quot;the-bigger-picture&quot;&gt;The bigger picture&lt;/h1&gt;
&lt;p&gt;There are a lot of these clever ‚Äúgood enough‚Äù tricks in Sorbet. Many
of them are only possible because of the stakes: Sorbet &lt;em&gt;already&lt;/em&gt;
allows &lt;a
href=&quot;https://sorbet.org/docs/gradual&quot;&gt;&lt;code&gt;T.untyped&lt;/code&gt;&lt;/a&gt;, so
depending on your viewpoint, either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is already the holy grail of all hacks in the type system, so
why not cut more corners when it makes sense.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Because&lt;/em&gt; &lt;code&gt;T.untyped&lt;/code&gt; is in the type system, at
least the user can use &lt;code&gt;T.untyped&lt;/code&gt; to not be completely
blocked from writing the code they need to write.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Either way, in some sense the stakes are low. In a compiler where the
stakes for being wrong are higher (the code computes the wrong answer),
maybe shortcuts aren‚Äôt the best idea. And in fact, &lt;a
href=&quot;https://github.com/sorbet/sorbet/pull/2962&quot;&gt;multiple&lt;/a&gt; &lt;a
href=&quot;https://github.com/sorbet/sorbet/pull/3044&quot;&gt;distinct&lt;/a&gt; &lt;a
href=&quot;https://github.com/sorbet/sorbet/pull/4488&quot;&gt;exception&lt;/a&gt; &lt;a
href=&quot;https://github.com/sorbet/sorbet/pull/4531&quot;&gt;changes&lt;/a&gt; landed in
Sorbet‚Äôs CFG code to support the Sorbet Compiler.&lt;/p&gt;
&lt;p&gt;It‚Äôs now been over four years since we shipped the change to model
&lt;code&gt;rescue&lt;/code&gt; this way. I‚Äôm not aware of a single incident caused
by this shortcut, and I can only even remember explaining this behavior
to a confused Sorbet user twice. I can‚Äôt find any performance numbers
from when the original change landed, but we can still put it into
perspective: it‚Äôs the difference between a handful of people being
confused over the course of 4 years, or thousands of people getting
faster typechecking results thousands of times per day. Seems like a
reasonable trade-off.&lt;/p&gt;
&lt;p&gt;Though eventually it would be nice to at least fix &lt;a
href=&quot;https://github.com/sorbet/sorbet/issues/4108&quot;&gt;that
&lt;code&gt;while true&lt;/code&gt; bug&lt;/a&gt;. üòÖ&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">‚Üê Return home Here‚Äôs a fun bug in Sorbet:</summary></entry><entry><title type="html">Control Flow in Sorbet is Syntactic</title><link href="https://blog.jez.io/syntactic-control-flow/" rel="alternate" type="text/html" title="Control Flow in Sorbet is Syntactic" /><published>2022-08-24T17:30:43-04:00</published><updated>2022-08-24T17:30:43-04:00</updated><id>https://blog.jez.io/syntactic-control-flow</id><content type="html" xml:base="https://blog.jez.io/syntactic-control-flow/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#properties-and-attributes-in-other-languages&quot;
  id=&quot;toc-properties-and-attributes-in-other-languages&quot;&gt;Properties and
  attributes in other languages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extra-thoughts&quot; id=&quot;toc-extra-thoughts&quot;&gt;Extra
  thoughts&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;People always ask me, ‚ÄúWhy does Sorbet think this is nil? I just
checked that it‚Äôs not!‚Äù So much so, that it‚Äôs at the very top of the &lt;a
href=&quot;https://sorbet.org/docs/faq&quot;&gt;Sorbet FAQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That doc answers what is happening and what to do to fix it, but
doesn‚Äôt really answer why its like that. A common follow up question
looks something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Having to use local variables as mentioned in Sorbet‚Äôs &lt;a
href=&quot;https://sorbet.org/docs/flow-sensitive#limitations-of-flow-sensitivity&quot;&gt;limitations
of flow-sensitivity&lt;/a&gt; docs is annoying. Idiomatic Ruby doesn‚Äôt use
local variables nearly as much as Sorbet requires. What gives?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: Sorbet‚Äôs type inference algorithm requires
being given a fixed data structure modeling control flow inside a
method. Type inference doesn‚Äôt get to change that structure, so the
things Sorbet learns while from inference don‚Äôt retroactively change
Sorbet‚Äôs view of control flow. (This is in line with the other popular
type systems for dynamically typed languages.) As a result control flow
must be a function of local syntax alone (variables), not global nor
semantic information (methods).&lt;/p&gt;
&lt;p&gt;But that‚Äôs packing a lot in at once, so let‚Äôs take a step back.&lt;/p&gt;
&lt;p&gt;In this post whenever I say type inference I basically mean assigning
types to variables, and using the types of variables to resolve calls to
methods. Type inference in Sorbet needs two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A symbol table, which maps names to global program definitions
(like classes and methods, and their types). Sorbet spends a ton of time
building a symbol table representing an entire codebase before it ever
starts running type inference.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A control flow graph, which is a data structure that models the
flow of control through a single method. Sorbet builds these graphs on
the fly right before running type inference.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since type inference requires the control flow graph, clearly
building the control flow graph can‚Äôt require type inference. Instead,
it has to build a control flow graph using only the method‚Äôs abstract
syntax tree (or AST). Since all Sorbet has is an AST, the control flow
only reflects syntax-only observations, like ‚Äúthese two variables are
the same‚Äù and ‚Äúan if condition branches on the value of this variable.‚Äù
Sorbet can draw these observations exclusively from the syntactic
structure of the current method, with no need to consult the symbol
table, let alone run inference.&lt;/p&gt;
&lt;p&gt;This brings us to our central conflict: knowing which method (or
methods!) a given call site resolves to is &lt;strong&gt;not&lt;/strong&gt; a
syntactic property. Consider this snippet:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.sample&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The meaning of &lt;code&gt;x.even?&lt;/code&gt; depends on the type of
&lt;code&gt;x&lt;/code&gt;, which depends on the earlier control flow in the method.
That means that if a program branches on a &lt;strong&gt;method return
value&lt;/strong&gt;, Sorbet cannot draw any interesting observations about
control flow.&lt;/p&gt;
&lt;p&gt;This gets to be a problem for methods whose meaning involves some
claim like, ‚ÄúI always return the same thing every time I‚Äôm called.‚Äù
Sorbet can‚Äôt know whether &lt;code&gt;x.foo&lt;/code&gt; refers to one of those
constant methods or a method that returns a random number every time, so
it has to assume the worst.&lt;/p&gt;
&lt;p&gt;Here‚Äôs a pathological example:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource ruby numberLines hl-25 hl-26 hl-27&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FooIsAttr&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;returns(T&lt;span class=&quot;at&quot;&gt;.nilable&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ot&quot;&gt;attr_accessor&lt;/span&gt; &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FooIsMethod&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot;&gt;&lt;/a&gt;  sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;returns(T&lt;span class=&quot;at&quot;&gt;.nilable&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# Returns something different every call&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-10&quot;&gt;&lt;a href=&quot;#cb2-10&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.sample&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-11&quot;&gt;&lt;a href=&quot;#cb2-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-12&quot;&gt;&lt;a href=&quot;#cb2-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-13&quot;&gt;&lt;a href=&quot;#cb2-13&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-14&quot;&gt;&lt;a href=&quot;#cb2-14&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.void&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-15&quot;&gt;&lt;a href=&quot;#cb2-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; takes_integer(x); &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-16&quot;&gt;&lt;a href=&quot;#cb2-16&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-17&quot;&gt;&lt;a href=&quot;#cb2-17&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Have to run inference to get type of `x`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-18&quot;&gt;&lt;a href=&quot;#cb2-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (running inference requires control flow)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-19&quot;&gt;&lt;a href=&quot;#cb2-19&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.sample&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-20&quot;&gt;&lt;a href=&quot;#cb2-20&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FooIsAttr&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-21&quot;&gt;&lt;a href=&quot;#cb2-21&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-22&quot;&gt;&lt;a href=&quot;#cb2-22&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;FooIsMethod&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-23&quot;&gt;&lt;a href=&quot;#cb2-23&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-24&quot;&gt;&lt;a href=&quot;#cb2-24&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-25&quot;&gt;&lt;a href=&quot;#cb2-25&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# x.foo returns the same thing only if x is `FooIsAttr`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-26&quot;&gt;&lt;a href=&quot;#cb2-26&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-27&quot;&gt;&lt;a href=&quot;#cb2-27&quot;&gt;&lt;/a&gt;  takes_integer(x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-28&quot;&gt;&lt;a href=&quot;#cb2-28&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a
href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20Module%3B%20include%20T%3A%3ASig%3B%20end%0Aextend%20T%3A%3ASig%0A%0Aclass%20FooIsAttr%0A%20%20sig%20%7Breturns%28T.nilable%28Integer%29%29%7D%0A%20%20attr_accessor%20%3Afoo%0Aend%0A%0Aclass%20FooIsMethod%0A%20%20sig%20%7Breturns%28T.nilable%28Integer%29%29%7D%0A%20%20def%20foo%0A%20%20%20%20%23%20Returns%20something%20different%20every%20call%0A%20%20%20%20%5B0%2C%20nil%5D.sample%0A%20%20end%0Aend%0A%0Asig%20%7Bparams%28x%3A%20Integer%29.void%7D%0Adef%20takes_integer%28x%29%3B%20end%0A%0A%23%20Have%20to%20run%20inference%20to%20get%20type%20of%20%60x%60%0A%23%20%28running%20inference%20requires%20control%20flow%29%0Aif%20%5Btrue%2C%20false%5D.sample%0A%20%20x%20%3D%20FooIsAttr.new%0Aelse%0A%20%20x%20%3D%20FooIsMethod.new%0Aend%0A%0A%23%20x.foo%20returns%20the%20same%20thing%20only%20if%20x%20is%20%60FooIsAttr%60%0Aif%20x.foo%0A%20%20takes_integer%28x.foo%29%20%23%20error%0Aend&quot;&gt;‚Üí
View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Note the two calls to &lt;code&gt;x.foo&lt;/code&gt; at the very end of the
snippet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Knowing whether the second call to &lt;code&gt;x.foo&lt;/code&gt; is non-nil
requires knowing whether &lt;code&gt;x.foo&lt;/code&gt; returns the same thing
across subsequent calls.&lt;/li&gt;
&lt;li&gt;Knowing &lt;em&gt;that&lt;/em&gt; requires knowing whether &lt;code&gt;foo&lt;/code&gt;
refers to an &lt;code&gt;attr_accessor&lt;/code&gt; method or some other
method.&lt;/li&gt;
&lt;li&gt;Knowing &lt;em&gt;that&lt;/em&gt; requires knowing the type of
&lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Knowing &lt;em&gt;that&lt;/em&gt; requires understanding the control flow in the
method.&lt;/li&gt;
&lt;li&gt;So we can‚Äôt make understanding the control flow in the method
require knowing whether the second call to &lt;code&gt;x.foo&lt;/code&gt; returns
the same thing.
&lt;ul&gt;
&lt;li&gt;But we &lt;em&gt;can&lt;/em&gt; make it require knowing whether a variable has
been assigned to between two variable accesses.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;properties-and-attributes-in-other-languages&quot;&gt;Properties and
attributes in other languages&lt;/h1&gt;
&lt;p&gt;Unfortunately, this all means that Sorbet can only track control
flow-sensitive types on variables, not methods. This is the exact same
limitation that other popular gradual type checkers
&lt;strong&gt;except&lt;/strong&gt; for one difference: both JavaScript and Python
make a &lt;strong&gt;syntactic&lt;/strong&gt; distinction between method calls
(which have parentheses) versus property/attribute access (which
don‚Äôt):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;# &amp;lt;- syntactically a property (JS) or attribute (Python)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;# &amp;lt;- syntactically a method call&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Ruby, &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;x.foo&lt;/code&gt; and
&lt;code&gt;x.foo()&lt;/code&gt; correspond to method calls,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This is true even if &lt;code&gt;foo&lt;/code&gt; was defined with
&lt;code&gt;attr_reader :foo&lt;/code&gt;!&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; so Sorbet models them as such. But in TypeScript, Flow,
and Mypy,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;And maybe other control-flow sensitive type systems,
too. Feel free to send me more examples.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; that small, syntactic difference is enough to allow
treating properties and attributes different from methods.&lt;/p&gt;
&lt;p&gt;&lt;a
href=&quot;https://www.typescriptlang.org/play?#code/MYGwhgzhAECC0G8BQ1oQPYFsCmAFATugA7b4AuAngFzQB2ArpgEanQA+09tAJtgGYBLWtm4BuFGizYAstjIALdNwAUAShoNmrDl16Dh3RNHxz6+WqOgBfJDaR8uwMgPS1owLEXplssNTXhkVBMyMzdhAHc4NXEbB1onFzcyMABrbAgAOUYWfGUADw0c0lVECQ9aDBBsADoQdABzAtVYpHtHZ1dobHywTCJqgEZlMADSoOgBPmgRmowcAmJSSnGJVBT0rOK8sDmpRZJyChaJG3W0jOytHb2FwkOV1vaEzrcevoHsACY1MtQpmYefreXxqW54e7LY5-VDQDaXbbKIFeHx+VTgg5Qk6oM5wi5ba5IzwgtEYyFHE52eKJLrvfrVADMIzGMIBs3mMjkihUqlWsLxmyuuXZUlkCiUamx1gk8IJwt2HLF3MlsSAA&quot;&gt;‚Üí
View example in TypeScript Playground&lt;/a&gt;&lt;br /&gt;
&lt;a
href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjGBDAzrsAQTAG9Uwxc4BbAUwAUAnOAB1sYBcBPALjAH4AdgFdqAI3YBucpRq0AsrQ4ALOABMAFAEo+Q0RMakAvqhOoowwRg4BLOILAYaLYR1qFtfYmQqMlwxgdBWiQPLWkTCytbezAObABrWlwAOX12DQAPPhFxdi1SGSdBKhhaADp4AHMs8NN0KOs7B1pM7GoWMoBGDWwvAp8wGygwXvKqOiZWdm4BmQp4pNT0xjGJhmY2Ti46ihMFxOS0vNXscbkprdmIhssm2Nb2ztoAJm1CimHRpw7Xd21zpNNjMdh8KHFDssThofi43GFARtpttdmB9hClscDDDnH8EetLiC6mZGjEWm0OmUAMy9fpgr5rOSKFTqbRzcEYo4rRl0ZmqTRaVHoxZc6FndZ81mCiJAA&quot;&gt;‚Üí
View example in Try Flow&lt;/a&gt;&lt;br /&gt;
&lt;a
href=&quot;https://mypy-play.net/?mypy=latest&amp;amp;python=3.10&amp;amp;flags=strict&amp;amp;gist=3e149c861a4f10dc474fd473021b0345&quot;&gt;‚Üí
View example in mypy Playground&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;In all the above examples, we see that the type of
&lt;code&gt;variable.property&lt;/code&gt; is aware of control flow, the types of
&lt;code&gt;expression().property&lt;/code&gt; and &lt;code&gt;variable.method()&lt;/code&gt;
are not.&lt;/p&gt;
&lt;p&gt;Unfortunately, the direct analogue to properties in Ruby are instance
variables like &lt;code&gt;@property&lt;/code&gt;, which have the limitation that
they can can only be accessed inside their owning class. It‚Äôs like if
JavaScript only allowed &lt;code&gt;this.property&lt;/code&gt; instead of allowing
the call site to be any arbitrary expression like
&lt;code&gt;x.property&lt;/code&gt;. In Ruby, you can‚Äôt write
&lt;code&gt;x.@property&lt;/code&gt;.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;You can do something similar:
&lt;code&gt;x.instance_variable_get(:@property)&lt;/code&gt;, but again this is a
method, not a property access‚Äîsomeone could have overridden the
&lt;code&gt;.instance_variable_get&lt;/code&gt; method!&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If you &lt;strong&gt;do&lt;/strong&gt; use instance variables in Ruby with
Sorbet, they behave comparably&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;There‚Äôs a &lt;a
href=&quot;https://github.com/sorbet/sorbet/issues/1374&quot;&gt;known bug&lt;/a&gt; in the
implementation at the time of writing, but it occurs somewhat rarely in
practice so we haven‚Äôt prioritized fixing it.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to their counterparts in other languages:&lt;/p&gt;
&lt;p&gt;&lt;a
href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0A%0Aclass%20A%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20initialize%0A%20%20%20%20%40some_property%20%3D%20T.let%28nil%2C%20T.nilable%28Integer%29%29%0A%20%20end%0A%0A%20%20sig%20%7Bparams%28x%3A%20Integer%29.void%7D%0A%20%20def%20takes_number%28x%29%0A%20%20%20%20puts%20x%0A%20%20end%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20example1%0A%20%20%20%20if%20%40some_property%0A%20%20%20%20%20%20takes_number%28%40some_property%29%0A%20%20%20%20end%0A%20%20%20%20takes_number%28%40some_property%29%0A%20%20end%0Aend&quot;&gt;‚Üí
View example on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Seen from this lens, I think it‚Äôs fair to say that Sorbet is doing
the best it can with what it has. If you disagree and have a suggestion
for how Sorbet could do better, feel free to reach out.&lt;/p&gt;
&lt;h1 id=&quot;extra-thoughts&quot;&gt;Extra thoughts&lt;/h1&gt;
&lt;p&gt;It‚Äôs maybe worth noting that even the Ruby VM itself cheats a little
here: yes &lt;code&gt;x.foo&lt;/code&gt; is technically a method call, but if that
method was defined via &lt;code&gt;attr_reader&lt;/code&gt;, the Ruby VM has special
handling to make it run much, much faster than had the method been
defined manually. So while you can think of these two things as doing
the same thing, the first one will run much faster:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ot&quot;&gt;attr_reader&lt;/span&gt; &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo; &lt;span class=&quot;ot&quot;&gt;@foo&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I take this to mean that even the Ruby VM itself realizes that there
is value in having something property like. It just unfortunately didn‚Äôt
make it into the language itself.&lt;/p&gt;
&lt;p&gt;It‚Äôs interesting to imagine a future where Sorbet treats
&lt;code&gt;x.foo&lt;/code&gt; and &lt;code&gt;x.foo()&lt;/code&gt; separately. For example, it
could &lt;strong&gt;require&lt;/strong&gt; that non-constant, nullary methods be
written with trailing &lt;code&gt;()&lt;/code&gt; even though Ruby doesn‚Äôt require
it. Then a follow up change might be able to build on that invariant, to
treat &lt;code&gt;x.foo&lt;/code&gt; like a property access instead of a method
call.&lt;/p&gt;
&lt;p&gt;But not only are there some high-level design and low-level technical
problems standing in the way of implementing this right now, there‚Äôs
also a social problem: almost every Ruby style guide and linter requires
the opposite, namely that nullary methods &lt;strong&gt;never&lt;/strong&gt; be
called with &lt;code&gt;()&lt;/code&gt; explicitly. Solving social problems tends to
involve waging holy wars, which is never all that fun.&lt;/p&gt;
&lt;p&gt;And to throw another wrench into the picture: recent versions of
JavaScript added getters, which allow executing an arbitrary method on
property access. Python has had computed &lt;code&gt;@property&lt;/code&gt;
declarations since version 2.2. Notably, TypeScript, Flow, and mypy
simply do not implement getters the same way as methods, even though
they arguably should for soundness:&lt;/p&gt;
&lt;p&gt;&lt;a
href=&quot;https://www.typescriptlang.org/play?#code/MYGwhgzhAECC0G8BQ1oQPYFsCmAFATugA7b4AuAngFzQB2ArpgEanQA+09tAJtgGYBLWtm4BuFGizYAstjIALdNwAUAShoNmrDl16Dh3RNHxz6+WqOgBfCQHM5knAHE5ZUmo2MW+dpx78hEUQJVAE+aGVpMAUAOnwwHiw1aAAeaAAGGIBWVWDUfPyTMjNaaABGcQKraGwQCGw8gsLTc0r8m1QbGyQ+LmAyAXRS4CwiejdYDzhGopK6bAB3ODVxG17afsHSsjAAa2wIADkvdwAPTy18XORUEdoMEGwYkHRbZVPVVaQevoGhmtOYEwREeZWUYBosGuEjCETAMQwOAIxFIlGhBR2+yOJ3w4IRUmRJHIFE+Eg60ExB2OlzxiLwhCJaK+Pw2f1K2EBwMeACZkjdoLDlCNgeNsJNVPikQzUSTGqhKdiacKxhM1JL6SjiaTOhIFdTvELRqLxerCTLSd11pt-hygSDsABmcGQ9EC8K0qSyBRKNSu+V7Kk4j04L2KFSqbXWXUBxUG+F00M+iPMq1sgF2x4AFmdcFdgvjUhcZDcVzlFJj+vcBecrlIkfJeqD1ewRZLFqAA&quot;&gt;‚Üí
View example on TypeScript Playground&lt;/a&gt;&lt;br /&gt;
&lt;a
href=&quot;https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjGBDAzrsAQTAG9Uwxc4BbAUwAUAnOAB1sYBcBPALjAH4AdgFdqAI3YBucpRq0AsrQ4ALOABMAFAEo+Q0RMakAvjIDmS2XQDiSju226R49qRkUAllDAb52FQDpGbEE1Gm0wAB4wAAZ-AFYtVwpk5MYlYUZBMABGaRSjMFoYXFoklNT0zLzkkwoTE1QoYUEMDnc4LIwaFmE7QgciMrSODKzBWiR+rWkTJpa2jrAObABrWlwAOX17AA8+JwNEsgouwSoYWn94Uw0d6dQGudb2rNod7GoWC+yNbD5CI4yTzebD+Kh0JisdjcQEpZZrTbbRi-MFySFsThce51GTw9ZbZzI0HghjMDEwmboJ4LV7vT4XABM4WOYGBGi6n16tCmqIhZOhWLKFDxiMJ7O6XJ5JPRAuxYFqS1W+KR4s5fW0vNJUMx90ezWeizeHy+tAAzL9-rDWV4USTFCp1NorcKlaKDLa5PbVJotHKFSKCe7iZ6lN6nZTGvqaYU6SaACwWohWtnB6y2djOxUIwP2VO0GwcOyMP24105omagtF3VAA&quot;&gt;‚Üí
View example on Try Flow&lt;/a&gt;&lt;br /&gt;
&lt;a
href=&quot;https://mypy-play.net/?mypy=latest&amp;amp;python=3.10&amp;amp;flags=strict&amp;amp;gist=753c6fdd9c640d3c5cfba896894e95bd&quot;&gt;‚Üí
View example on mypy Playground&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;If it were not so common in Ruby for &lt;strong&gt;all&lt;/strong&gt; nullary
methods to be called without &lt;code&gt;()&lt;/code&gt;, instead of just those
defined with &lt;code&gt;attr_reader&lt;/code&gt; or something similar, maybe Sorbet
could have chosen the same trade-off.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">‚Üê Return home People always ask me, ‚ÄúWhy does Sorbet think this is nil? I just checked that it‚Äôs not!‚Äù So much so, that it‚Äôs at the very top of the Sorbet FAQ</summary></entry><entry><title type="html">Parse Error Recovery in Sorbet: Part 4</title><link href="https://blog.jez.io/error-recovery-part-4/" rel="alternate" type="text/html" title="Parse Error Recovery in Sorbet: Part 4" /><published>2022-06-06T01:56:49-04:00</published><updated>2022-06-06T01:56:49-04:00</updated><id>https://blog.jez.io/error-recovery-part-4</id><content type="html" xml:base="https://blog.jez.io/error-recovery-part-4/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#bisons-error-recovery-algorithm&quot;
  id=&quot;toc-bisons-error-recovery-algorithm&quot;&gt;Bison‚Äôs error recovery
  algorithm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#figure-out-the-most-common-edit-paths&quot;
  id=&quot;toc-figure-out-the-most-common-edit-paths&quot;&gt;Figure out the most
  common edit paths&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-error-token-is-usually-last&quot;
  id=&quot;toc-the-error-token-is-usually-last&quot;&gt;The &lt;code&gt;error&lt;/code&gt; token
  is usually last&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#consider-using-yyclearin&quot;
  id=&quot;toc-consider-using-yyclearin&quot;&gt;Consider using
  &lt;code&gt;yyclearin&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#invent-a-special-ast-node-for-errors&quot;
  id=&quot;toc-invent-a-special-ast-node-for-errors&quot;&gt;Invent a special AST
  node for errors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#read-the-generated-parsers-source&quot;
  id=&quot;toc-read-the-generated-parsers-source&quot;&gt;Read the generated parser‚Äôs
  source&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;This is the fourth post in a series about ‚Äúthings I‚Äôve learned while
making improvements to Sorbet‚Äôs parser.‚Äù With the last post, I talked
about some tools and techniques that I‚Äôve found useful while hacking on
Sorbet‚Äôs &lt;a href=&quot;https://www.gnu.org/software/bison/&quot;&gt;Bison&lt;/a&gt;-based
parser. This post is going to continue that theme by explaining in a
little more detail the primary tool Bison has for adding error recovery
to a parser: the special &lt;code&gt;error&lt;/code&gt; token.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;You don‚Äôt &lt;em&gt;really&lt;/em&gt; need to read the previous posts for this
post to be useful, but if in case you want to queue them up to read
later, here‚Äôs the list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-1/&quot;&gt;Part 1: Why Recover from Syntax
Errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-2/&quot;&gt;Part 2: What I Didn‚Äôt Do&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;Part 3: Tools and Techniques for
Debugging a (Bison) Parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;/error-recovery-part-4/&quot;&gt;Part 4: Bison‚Äôs
&lt;code&gt;error&lt;/code&gt; Token&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks&lt;/li&gt;
&lt;li&gt;(&lt;em&gt;coming soon&lt;/em&gt;) Part 6: Falling Back on Indentation, aka More
Lexer Hacks&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That being said, if you‚Äôre also trying to hack on a Bison parser to
make it recover from errors, I hate to say it but this post is not going
to be a substitute for the &lt;a
href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery&quot;&gt;official
docs on Error Recovery&lt;/a&gt;. You‚Äôre going to want to spend some time
skimming that section of the docs if you haven‚Äôt already.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Bison needs explicit annotations within a grammar to provide syntax
error recovery. This is in contrast with parser tools like &lt;a
href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt;,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;If you‚Äôre curious, I‚Äôve written some assorted &lt;a
href=&quot;/categories/#tree-sitter&quot;&gt;thoughts on tree-sitter&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; which automatically include error recovery. Concretely,
Bison requires inserting special &lt;code&gt;error&lt;/code&gt; tokens in production
rules that should participate in error recovery.&lt;/p&gt;
&lt;p&gt;To get the most out of Bison‚Äôs error recovery mode, it‚Äôs crucial to
understand what it‚Äôs actually doing with those &lt;code&gt;error&lt;/code&gt;
tokens.&lt;/p&gt;
&lt;h1 id=&quot;bisons-error-recovery-algorithm&quot;&gt;Bison‚Äôs error recovery
algorithm&lt;/h1&gt;
&lt;p&gt;There‚Äôs a vague description of the algorithm &lt;a
href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Error-Recovery&quot;&gt;in
the docs&lt;/a&gt;, but I found that I had to make the algorithm more explicit
before I could understand what was and wasn‚Äôt possible.&lt;/p&gt;
&lt;p&gt;At a high level, this is what Bison does:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;It encounters an error. By which we mean: neither shifting the
lookahead token nor reducing the current stack is a valid action given
the current lookahead token).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It reports the error by calling the (user-defined)
&lt;code&gt;yyerror&lt;/code&gt;&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;In C++ parsers, this is called
&lt;code&gt;parser::error&lt;/code&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; function.&lt;/p&gt;
&lt;p&gt;Importantly, this function is &lt;strong&gt;always&lt;/strong&gt; called.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Other parser generators, for example &lt;a
href=&quot;https://www.haskell.org/happy/&quot;&gt;Happy&lt;/a&gt; for Haskell do not
necessarily report an error when an &lt;code&gt;error&lt;/code&gt; token is
produced.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Even if a production rule eventually consumes the error
token and successfully recovers from the parse error, an error will have
been reported.&lt;/p&gt;
&lt;p&gt;Also note that it‚Äôs impossible&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Sorbet gets around this limitation by appending parse
errors to a temporary queue, only flushing them to the user once parsing
has completed. Sorbet sometimes &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1976-L1981&quot;&gt;mutates&lt;/a&gt;
the last element of the queue inside semantic actions to improve the
error message with specific information about the parse failure.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to delay calling &lt;code&gt;yyerror&lt;/code&gt; until it‚Äôs clear
that no production rule matched the &lt;code&gt;error&lt;/code&gt; token, since the
&lt;code&gt;yyerror&lt;/code&gt; function is called even before attempting to
&lt;strong&gt;shift&lt;/strong&gt; the &lt;code&gt;error&lt;/code&gt; token, less reduce a rule
that uses it. For similar reasons, this makes it more complicated to
allow the eventual error rule to provide extra context on the error
message.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, Bison looks to see it can shift the &lt;code&gt;error&lt;/code&gt;
token, given what the current stack contents and parser state are. It
leaves the current lookahead token untouched for the time being.&lt;/p&gt;
&lt;p&gt;If it can shift the &lt;code&gt;error&lt;/code&gt; token, it does so. Bison has
finished recovering from the syntax error. The parse continues, using
the untouched lookahead token.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If it &lt;strong&gt;can‚Äôt&lt;/strong&gt; shift the &lt;code&gt;error&lt;/code&gt; token,
Bison &lt;strong&gt;completely discards&lt;/strong&gt; the object on the top of the
stack.&lt;/p&gt;
&lt;p&gt;To make that clear, if the parser stack looked something like
this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# def foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#   x.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;stack &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;def&amp;#39;&lt;/span&gt;, identifier, &lt;span class=&quot;ch&quot;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, expression, &lt;span class=&quot;ch&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;lookahead &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and Bison found no matching error production rule, it would throw
away the &lt;code&gt;'.'&lt;/code&gt; token that it had already shifted onto the
parser stack:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;stack &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;def&amp;#39;&lt;/span&gt;, identifier, &lt;span class=&quot;ch&quot;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;, expression&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;lookahead &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then loop back to the previous step, checking to see whether it‚Äôs
now possible to shift the &lt;code&gt;error&lt;/code&gt; token. This process repeats
until Bison has gobbled up the whole stack or some production rule
consumes the error token.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If Bison‚Äôs &lt;a
href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Tracking-Locations&quot;&gt;Location
Tracking&lt;/a&gt; feature is on (which allows using &lt;code&gt;@1&lt;/code&gt;,
&lt;code&gt;@2&lt;/code&gt;, etc. in semantic actions to get the locations
associated with components of the rule), it‚Äôs worth knowing how the
&lt;code&gt;error&lt;/code&gt; token‚Äôs location is set. Bison sets the error
location to span from the last thing it discarded from the stack all the
way to the lookahead token that induced the error. If it discarded
nothing, then the range would just be the location of the lookahead
token.&lt;/p&gt;
&lt;p&gt;Using the example above, if the &lt;code&gt;'.'&lt;/code&gt; token was the only
token Bison needed to discard, the error token‚Äôs location would be set
to span from that &lt;code&gt;'.'&lt;/code&gt; token all the way to the
&lt;code&gt;'end'&lt;/code&gt; lookahead token.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Most Bison grammars have a catch all &lt;code&gt;| error&lt;/code&gt; production
somewhere, like this one in Sorbet‚Äôs parser:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource yacc numberLines hl-4&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot;&gt;&lt;/a&gt;stmts: &lt;span class=&quot;kw&quot;&gt;%empty&lt;/span&gt; { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot;&gt;&lt;/a&gt;     | stmt { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot;&gt;&lt;/a&gt;     | stmts newline stmt { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot;&gt;&lt;/a&gt;     | error { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet‚Äôs parser. &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L653-L657&quot;&gt;View
on GitHub ‚Üí&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The nice thing about a rule like this is that it provides coarse
grained error recovery at a high level without requiring special cases
for every production in the grammar. It works because no matter what
happens to be on the stack, it‚Äôll always eventually match (as long as
we‚Äôre in the parser state corresponding to &lt;code&gt;stmts&lt;/code&gt;) because
eventually Bison will have discarded the entire stack.&lt;/p&gt;
&lt;p&gt;It‚Äôll definitely throw away a lot of stuff, but at least it‚Äôll let
the parse continue instead of failing to produce any parse result. For
example, if there was no parse error further down in the file, and the
error occurred near the top, this rule gets us lots of error recovery
for little work. But yeah, it‚Äôs not great to throw that much stuff
away.&lt;/p&gt;
&lt;p&gt;We‚Äôre going to want to put more &lt;code&gt;error&lt;/code&gt; tokens in more
targeted places. For that, I‚Äôve come up with a handful of strategies to
make the most of Bison‚Äôs error recovery.&lt;/p&gt;
&lt;h1 id=&quot;figure-out-the-most-common-edit-paths&quot;&gt;Figure out the most
common edit paths&lt;/h1&gt;
&lt;p&gt;Even though Bison requires a lot of &lt;code&gt;error&lt;/code&gt; annotations to
get good parse results, you can get good bang for your buck by figuring
out the most common edit paths. For example, here‚Äôs every intermediate
edit when the user adds a keyword argument to a Ruby method:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x) &lt;span class=&quot;co&quot;&gt;# contents before edit&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x,)&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, y)&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, y:)&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo(a, &lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;x, &lt;span class=&quot;wa&quot;&gt;y: &lt;/span&gt;y) &lt;span class=&quot;co&quot;&gt;# edit finished&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ideally there‚Äôs an &lt;code&gt;error&lt;/code&gt; production for every
intermediate state, because adding a keyword argument to a method call
is common. On the other hand, you can likely get away not adding rules
for uncommon syntax errors.&lt;/p&gt;
&lt;p&gt;If you want, you can take the guesswork out of what‚Äôs common and
what‚Äôs not by measuring, assuming you have a corpus of syntax errors you
can sample from.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;For example, we gather usage metrics from every Sorbet
user at Stripe.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; The semi-automated approach to measurement, which is what
I‚Äôve personally used: when there‚Äôs a syntax error and the parse result
is ‚Äúbad‚Äù according to some heuristic (like: the parse is completely
empty, or there was a partial parse result but it was too bad to find
any completion suggestions at the user‚Äôs cursor), log the bad source
buffer to a file, and then go triage the logged files, fixing the most
common errors first.&lt;/p&gt;
&lt;p&gt;The annoying part about that approach is the manual triage work of
opening up the logged buffers, identifying which part of the file had
the parse error, and blaming it to some section of the parser. An idea
I‚Äôve had (but not implemented) for a more automatic approach: when
there‚Äôs a syntax error that‚Äôs never recovered (or that‚Äôs handled by some
‚Äúcatch all‚Äù production rule), log the lookahead token and parser state
where the error happened. Cross reference parser states with what‚Äôs in
the &lt;a
href=&quot;https://www.gnu.org/software/bison/manual/bison.html#Understanding&quot;&gt;textual
report&lt;/a&gt; on the parser to get approximate line numbers in the grammar
that need to be updated. States that show up the most commonly are the
ones in need of dedicated &lt;code&gt;error&lt;/code&gt; rules.&lt;/p&gt;
&lt;h1 id=&quot;the-error-token-is-usually-last&quot;&gt;The &lt;code&gt;error&lt;/code&gt; token is
usually last&lt;/h1&gt;
&lt;p&gt;With the most common edit paths in hand, I‚Äôve usually had the most
success by following two tips for crafting the error rules.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Put the &lt;code&gt;error&lt;/code&gt; token as the very last token in the
production rule. It can be tempting to try writing rules like this,
where the &lt;code&gt;error&lt;/code&gt; token is followed by some other stuff:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre
class=&quot;sourceCode yacc&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  | args &amp;#39;,&amp;#39; arg { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  | args &amp;#39;,&amp;#39; error arg  { &lt;span class=&quot;co&quot;&gt;/* ... */&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sometimes this works, but in my experience, it‚Äôs much easier to
reason about conflicts when the &lt;code&gt;error&lt;/code&gt; token is the last
token in a rule.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Put the &lt;code&gt;error&lt;/code&gt; token &lt;strong&gt;only&lt;/strong&gt; after
terminals. There‚Äôs almost never conflicts in the grammar when putting
the &lt;code&gt;error&lt;/code&gt; token after a &lt;code&gt;','&lt;/code&gt; or
&lt;code&gt;'='&lt;/code&gt; token, but there usually are when putting it after
something like an &lt;code&gt;args&lt;/code&gt; non-terminal.&lt;/p&gt;
&lt;p&gt;Intuitively this makes sense, because the &lt;code&gt;args&lt;/code&gt;
production itself probably has a bunch of rules that have consume an
&lt;code&gt;error&lt;/code&gt; token at the end, causing the conflicts. The
non-terminal might even have a catch-all &lt;code&gt;| error&lt;/code&gt;
rule.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In situations where I haven‚Äôt been able to trivially follow these
rules, I‚Äôve usually been able to go into the preceding non-terminal rule
(like &lt;code&gt;args&lt;/code&gt;) and sprinkle &lt;code&gt;error&lt;/code&gt; tokens
judiciously inside &lt;em&gt;that&lt;/em&gt; rule to allow following these
rules.&lt;/p&gt;
&lt;p&gt;Unfortunately, there have definitely been times where that hasn‚Äôt
worked, which will be the topic of a future post.
&lt;!-- TODO(jez) Link to the part 6 indentation post here, when written --&gt;&lt;/p&gt;
&lt;h1 id=&quot;consider-using-yyclearin&quot;&gt;Consider using
&lt;code&gt;yyclearin&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;After recovering from a parse error using the &lt;code&gt;error&lt;/code&gt;
token, the lookahead token will still be set to whatever it was that
caused the error to happen in the first place.&lt;/p&gt;
&lt;p&gt;If for whatever reason you think that attempting to continue the
parse with that token would just screw things up again, you can use the
&lt;code&gt;yyclearin&lt;/code&gt; macro&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-5&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-5&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;In the C++ skeleton, this is available using
&lt;code&gt;yyla.clear()&lt;/code&gt; instead.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; to clear out the lookahead token, which will cause Bison
to request another token from the lexer.&lt;/p&gt;
&lt;p&gt;We‚Äôre not currently using this in Sorbet because I‚Äôve replaced most
places where it might have been useful with some even more powerful
techniques (discussed in a future part), but I figured I may as well
mention it. &lt;!-- TODO(jez) Link to part 5 lexer hacks here --&gt;&lt;/p&gt;
&lt;h1 id=&quot;invent-a-special-ast-node-for-errors&quot;&gt;Invent a special AST node
for errors&lt;/h1&gt;
&lt;p&gt;Consider this parse error:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rule for parsing an assignment with no error looks like this, and
produces an &lt;code&gt;assign&lt;/code&gt; node in the AST:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource yacc numberLines&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet‚Äôs parser. &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1285-L1288&quot;&gt;View
on GitHub ‚Üí&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;To handle the error case, we still have the &lt;code&gt;lhs&lt;/code&gt; and the
&lt;code&gt;'='&lt;/code&gt;, but we don‚Äôt have the &lt;code&gt;arg_rhs&lt;/code&gt;. The parser
will detect that &lt;code&gt;'end'&lt;/code&gt; is not a valid &lt;code&gt;arg_rhs&lt;/code&gt;,
and shift the &lt;code&gt;error&lt;/code&gt; token for us to recognize:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource yacc numberLines hl-5 hl-7&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot;&gt;&lt;/a&gt;   | lhs &amp;#39;=&amp;#39; error&lt;/span&gt;
&lt;span id=&quot;cb8-6&quot;&gt;&lt;a href=&quot;#cb8-6&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb8-7&quot;&gt;&lt;a href=&quot;#cb8-7&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, &lt;span class=&quot;co&quot;&gt;/* ... ? ... */&lt;/span&gt;);&lt;/span&gt;
&lt;span id=&quot;cb8-8&quot;&gt;&lt;a href=&quot;#cb8-8&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb8-9&quot;&gt;&lt;a href=&quot;#cb8-9&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It‚Äôs unclear what to use in place of &lt;code&gt;$3&lt;/code&gt;, because
&lt;code&gt;error&lt;/code&gt; doesn‚Äôt have an associated semantic value. To fill
the void, we can invent a special AST &lt;code&gt;error_node&lt;/code&gt; type.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-6&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-6&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Slight fib; Sorbet actually creates a &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/Builder.cc#L911-L913&quot;&gt;constant
literal node&lt;/a&gt; with a magic name for backwards compatibility
reasons.&lt;br /&gt;
&lt;br /&gt;
‚ÄúWhat‚Äôs up with that &lt;code&gt;endPos&lt;/code&gt; stuff?‚Äù&lt;br /&gt;
There‚Äôs some discussion in the full source on GitHub.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource yacc numberLines hl-7 hl-8&quot;&gt;&lt;code class=&quot;sourceCode yacc&quot;&gt;&lt;span id=&quot;cb9-1&quot;&gt;&lt;a href=&quot;#cb9-1&quot;&gt;&lt;/a&gt;arg: lhs &amp;#39;=&amp;#39; arg_rhs&lt;/span&gt;
&lt;span id=&quot;cb9-2&quot;&gt;&lt;a href=&quot;#cb9-2&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb9-3&quot;&gt;&lt;a href=&quot;#cb9-3&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, $3);&lt;/span&gt;
&lt;span id=&quot;cb9-4&quot;&gt;&lt;a href=&quot;#cb9-4&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb9-5&quot;&gt;&lt;a href=&quot;#cb9-5&quot;&gt;&lt;/a&gt;   | lhs &amp;#39;=&amp;#39; error&lt;/span&gt;
&lt;span id=&quot;cb9-6&quot;&gt;&lt;a href=&quot;#cb9-6&quot;&gt;&lt;/a&gt;       {&lt;/span&gt;
&lt;span id=&quot;cb9-7&quot;&gt;&lt;a href=&quot;#cb9-7&quot;&gt;&lt;/a&gt;         auto enode = driver.build.error_node(self, @2.endPos(), @3.endPos());&lt;/span&gt;
&lt;span id=&quot;cb9-8&quot;&gt;&lt;a href=&quot;#cb9-8&quot;&gt;&lt;/a&gt;         $$ = driver.build.assign(self, $1, $2, enode);&lt;/span&gt;
&lt;span id=&quot;cb9-9&quot;&gt;&lt;a href=&quot;#cb9-9&quot;&gt;&lt;/a&gt;       }&lt;/span&gt;
&lt;span id=&quot;cb9-10&quot;&gt;&lt;a href=&quot;#cb9-10&quot;&gt;&lt;/a&gt;   | ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
Snippet of Sorbet‚Äôs parser. &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/e961ac4ee7c4e425e5b5f14a03b7ce20c3bdbbc2/parser/parser/cc/grammars/typedruby.ypp#L1289-L1303&quot;&gt;View
on GitHub ‚Üí&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;This special AST node allows phases downstream of the parser to
pretend the parse succeeded. In particular, it‚Äôs easy to detect where
the syntax error occurred when responding to completion requests (which
is important, because in the above example, the syntax error is also
where the user‚Äôs cursor is).&lt;/p&gt;
&lt;h1 id=&quot;read-the-generated-parsers-source&quot;&gt;Read the generated parser‚Äôs
source&lt;/h1&gt;
&lt;p&gt;To close, I‚Äôd like to point out that everything in this post that I
didn‚Äôt find in the official docs, I taught myself by browsing the source
code generated by Bison. Despite being generated, it‚Äôs actually pretty
well commented, and with a bit of elbow grease you might even be able to
get your IDE to let you use jump to def in it.&lt;/p&gt;
&lt;p&gt;Some nice things about browsing the source:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It‚Äôs never out of sync with the version of Bison you‚Äôre using
(unlike the official docs, which only track the latest
version).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can see exactly what happens and in what order. For example,
reading the source is how I convinced a colleague that no, using
&lt;code&gt;error&lt;/code&gt; productions did not mean we would be preventing
errors from being reported. It was faster to read the source than
attempt to find whether the docs mentioned this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can see what fun, undocumented APIs are actually available to
you. For example, the docs talk about &lt;code&gt;yylval&lt;/code&gt; and
&lt;code&gt;yylloc&lt;/code&gt;, which are supposed to store the semantic value and
location of the lookahead token. But in the C++ skeleton, these things
have been renamed (without documentation) to &lt;code&gt;yyla.value&lt;/code&gt; and
&lt;code&gt;yyla.location&lt;/code&gt;, respectively.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reading the generated parser‚Äôs source code reinforced my
understanding of Bison‚Äôs parsing algorithm and made it easier to debug
when things went wrong.&lt;/p&gt;
&lt;p&gt;All this being said, I‚Äôve run into plenty of limitations when
attempting to improve Sorbet‚Äôs parser. In the next post, I‚Äôll explain
one such example, why using &lt;code&gt;error&lt;/code&gt; tokens alone wasn‚Äôt
enough, and how I tweaked Sorbet‚Äôs lexer to aid the parser in error
recovery.&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: left; text-align: left;&quot;&gt;
&lt;a href=&quot;/error-recovery-part-3/&quot;&gt;‚Üê Part 3: Tools and Techniques for
Debugging a (Bison) Parser&lt;/a&gt;
&lt;/p&gt;
&lt;p style=&quot;width: 50%; float: right; text-align: right;&quot;&gt;
(&lt;em&gt;coming soon&lt;/em&gt;) Part 5: Backtracking, aka Lexer Hacks ‚Üí
&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="parsing" /><summary type="html">‚Üê Return home This is the fourth post in a series about ‚Äúthings I‚Äôve learned while making improvements to Sorbet‚Äôs parser.‚Äù With the last post, I talked about some tools and techniques that I‚Äôve found useful while hacking on Sorbet‚Äôs Bison-based parser. This post is going to continue that theme by explaining in a little more detail the primary tool Bison has for adding error recovery to a parser: the special error token.</summary></entry><entry><title type="html">With types, seeing is believing</title><link href="https://blog.jez.io/seeing-is-believing/" rel="alternate" type="text/html" title="With types, seeing is believing" /><published>2022-06-04T23:31:51-04:00</published><updated>2022-06-04T23:31:51-04:00</updated><id>https://blog.jez.io/seeing-is-believing</id><content type="html" xml:base="https://blog.jez.io/seeing-is-believing/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;‚Üê Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;From time to time I get asked something like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I write a lot of Ruby at work. In past projects I‚Äôve really enjoyed
and benefited from a statically typed language. But on my current team,
people aren‚Äôt as excited.&lt;/p&gt;
&lt;p&gt;What can I say to them to get them to change their mind, so we can
start using types in Ruby?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In my experience, this framing is backwards. You don‚Äôt first convince
everyone that types are good, and then start adopting types. Instead,
you put them to sleep, enter their dream, and plant the idea that types
are good‚Äîah, wait, wrong storyline. Instead, you adopt types first and
then let people see for themselves what types do for them. The people
opposed to types won‚Äôt be convinced to start liking them by anything you
can tell them or ask them to read.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;In all of the cases where I‚Äôve seen Sorbet be adopted, the process
looked like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;An ambitious team (or even individual) who really, really wants
types in Ruby does the work to get an initial pass at adoption passing
in CI.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This can be somewhat of a grind, and is all too often
done during nights and weekends, though high-trust teams do a good job
of carving out time for experiments like this.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Importantly, the initial pass does a minimal amount of
work, so that it doesn‚Äôt take long to get here.&lt;/p&gt;
&lt;p&gt;For &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt;, that means only checking
at &lt;a
href=&quot;https://sorbet.org/docs/static#file-level-granularity-strictness-levels&quot;&gt;&lt;code&gt;# typed: false&lt;/code&gt;&lt;/a&gt;,
which enables Sorbet in every file but only does the most basic checks,
like checking for syntax errors and typos in constant literals.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;That initial version sits silently in the codebase over a period
of days or weeks. When new changes introduce new type errors, it pings
the enthusiastic types adoption team; they figure out whether it caught
a real bug or whether the tooling could be improved (for example, for
syncing type definitions for third-party code). It does
&lt;strong&gt;not&lt;/strong&gt; ping the unsuspecting user yet.&lt;/p&gt;
&lt;p&gt;When we did this to roll out Sorbet at Stripe, this manifested as a
job that ran on the &lt;code&gt;master&lt;/code&gt; branch&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Limiting to &lt;code&gt;master&lt;/code&gt;, instead of all
branches, is a convenient way to get a sense for whether enforcing types
would have actually blocked someone. It‚Äôs far more likely that
in-progress branches with type failures also have failing tests, and
that the type failure would have done a &lt;em&gt;better&lt;/em&gt; job at alerting
the user to the problem.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; in CI, but if it failed it would send a Slack message to
us, not tell the user that their change was broken.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This process repeats until the pings are only
&lt;strong&gt;high-signal&lt;/strong&gt; pings. When there‚Äôs an error, it represents
actual bugs (or maybe it doesn‚Äôt error at all: remember, most files are
still &lt;code&gt;# typed: false&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Double check at this point that it‚Äôs easy to configure whatever
editors your team uses to put the errors directly in the editor. You
likely already did this for yourself while working on the initial
migration.&lt;/p&gt;
&lt;p&gt;Sorbet exposes an &lt;a
href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;LSP
server&lt;/a&gt; via the &lt;code&gt;--lsp&lt;/code&gt; command line flag to allow
integrating with arbitrary editors, and also publishes a &lt;a
href=&quot;https://sorbet.org/docs/vscode&quot;&gt;VS Code extension&lt;/a&gt; for people
who want a one-click, low-config solution.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The time has come to enforce that the codebase type checks in CI.
You and your team effectively beta-tested it on behalf of the
organization and decided it wasn‚Äôt going to bring development to a halt.
Flip the switch, and if need be, remind people that this is still an
experiment. ‚ÄúWe can try it out for a while and re-evaluate later‚Äîit‚Äôs
still the same language.‚Äù&lt;/p&gt;
&lt;p&gt;Most code still has no explicit type annotations and limited type
checking (due to the &lt;code&gt;# typed: false&lt;/code&gt;), but now more teams
can experiment with enabling stricter type checking in the sections of
the codebase they own.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;This is the whole point of ‚Äúgradual‚Äù in &lt;a
href=&quot;https://sorbet.org/docs/gradual&quot;&gt;gradual type checking&lt;/a&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, the important part: &lt;strong&gt;show&lt;/strong&gt; people how
good Sorbet is, don‚Äôt tell them. Fire up Sorbet on your codebase, delete
something, and watch as the error list populates instantly. Jump to
definition on a constant. Try autocompleting something.&lt;/p&gt;
&lt;p&gt;Notice how we‚Äôre &lt;strong&gt;not&lt;/strong&gt; showing off the type system and
how expressive it might be. We‚Äôre showing off what the type system
actually lets them do! Be more productive at their job.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In my experience trying to bring static types to Ruby users, seeing
really is believing. I‚Äôve seen this exact same story or slight
variations of it play out in just about every successful adoption
case.&lt;/p&gt;
&lt;p&gt;While it‚Äôs true that the type checker is going to prevent people from
writing valid code they used to be able to write, every gradual type
system has &lt;a
href=&quot;https://sorbet.org/docs/troubleshooting#escape-hatches&quot;&gt;escape
hatches&lt;/a&gt; to opt out of those checks in some way. The argument that
people fond of type checkers want to make is that the instant feedback
and powerful editor features a type checker provides outshine the times
when the type checker gets in the way, but it‚Äôs impossible to make that
argument with words alone.&lt;/p&gt;
&lt;p&gt;One final, important note: &lt;strong&gt;be supportive&lt;/strong&gt;. Advertise
a single place for anyone to ask questions and get quick responses.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Like, actually quick. ‚ÄúNotify for new Slack every
message‚Äù quick. If you queue questions into some ticketing system and
respond tomorrow, people will lose patience with &lt;em&gt;types overall&lt;/em&gt;
not just with you.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Admit that this will likely lead to being overworked for
a bit until it takes off. In the long run as adoption and familiarity
spread, other teammates will start to help out with the evangelism as
the benefits spread outward.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="devprod" /><summary type="html">‚Üê Return home From time to time I get asked something like this:</summary></entry><entry><title type="html">Is tree-sitter good enough?</title><link href="https://blog.jez.io/tree-sitter-limitations/" rel="alternate" type="text/html" title="Is tree-sitter good enough?" /><published>2022-05-30T04:43:46-04:00</published><updated>2022-05-30T04:43:46-04:00</updated><id>https://blog.jez.io/tree-sitter-limitations</id><content type="html" xml:base="https://blog.jez.io/tree-sitter-limitations/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;‚Üê Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: no, or at the very least, ‚Äúnot for every use
case.‚Äù (Though I really wish it were for the use cases I have, because
it would save me a lot of work.)&lt;/p&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;I‚Äôm guessing you already know what tree-sitter is because you clicked
on the title. If you clicked because you were hoping to find out: &lt;a
href=&quot;https://tree-sitter.github.io/tree-sitter/&quot;&gt;tree-sitter&lt;/a&gt; is a
relatively&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Is it still new? The GitHub repo has commits dating
back to 2013, though I only first heard about it in 2017. It still has a
feeling of newness about it, but I digress.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; new project which aims to make writing fast,
error-tolerant parsers take less work. To do that, it provides both
pre-built parsers for common programming languages and a toolkit for
building new parsers. It‚Äôs known for use in various GitHub features by
way of their &lt;a href=&quot;https://github.com/github/semantic&quot;&gt;semantic&lt;/a&gt;
tool, which powers the code navigation tooltips that you sometimes see
on GitHub.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;The semantic repo actually has a &lt;a
href=&quot;https://github.com/github/semantic/blob/master/docs/why-tree-sitter.md&quot;&gt;short
overview&lt;/a&gt; of why they chose tree-sitter, along with some
drawbacks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For a lot of projects, tree-sitter is really nice!
&lt;em&gt;Especially&lt;/em&gt; for projects where the quality of the parser is less
important than the quantity of languages supported. For example: an
editor syntax highlighter. It‚Äôs more important that the editor highlight
lots of languages‚Äô syntax than it is that every language is highlighted
perfectly. Another example: building something like &lt;a
href=&quot;https://www.emacswiki.org/emacs/ParEdit&quot;&gt;ParEdit&lt;/a&gt; for arbitrary
languages. Or providing jump-to-def that‚Äôs mostly better than plain-text
code search.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Another neat use case, from work: every time a commit
is pushed to an approved PR, the approval is dismissed, unless (using
tree-sitter) the CI system detects that the parse tree hasn‚Äôt changed.
This spares comment and formatting changes the toil of a
re-review.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; For a lot of these applications it‚Äôs actually
&lt;em&gt;completely fine&lt;/em&gt; if there‚Äôs a flagrant bug in one of the
grammars, because the project is still so useful in all the other
languages.&lt;/p&gt;
&lt;p&gt;But when the goals are flipped‚Äîit has to work for exactly one
language, and the quality of the parser is paramount‚Äîtree-sitter becomes
less attractive. There are two questions I would pose to anyone curious
about using tree-sitter for their parser:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;Is serving autocompletion requests a key use cases?&lt;/p&gt;
&lt;p&gt;Serving autocompletion requests requires an unnaturally high parse
fidelity, even when the buffer is ridiculed with syntax errors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How much do you care about crafting custom messages for syntax
errors?&lt;/p&gt;
&lt;p&gt;Customizing syntax error messages becomes context-dependent very
quickly. It‚Äôs easy to maintain that context when your parser allows
running arbitrary code, and hard when the parser is constrained to a
declarative DSL.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If either of these goals are important, I‚Äôd recommend rolling your
own parser (using the technique of your choice). It comes down to
flexibility: a tree-sitter grammar, with it‚Äôs declarative specification,
provides a lot of neat features for free (like error recovery), but
places a ceiling on possibilities for future improvement.&lt;/p&gt;
&lt;p&gt;Let me show some examples.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;It‚Äôs entirely possible that I‚Äôve just been
&lt;em&gt;really&lt;/em&gt; unlucky, and that the problems I‚Äôve found are all
fixable with a few bug reports and a little ingenuity. But if it‚Äôs going
to take ingenuity anyways, isn‚Äôt that the same as writing a parser
myself?&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; The snippets of code below are exactly the kinds of
programs that people type in their editors, but which tree-sitter
doesn‚Äôt parse well enough. You can follow along on the &lt;a
href=&quot;https://tree-sitter.github.io/tree-sitter/playground&quot;&gt;tree-sitter
online playground&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Let‚Äôs start with a Ruby program, alongside its parse result:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;kw&quot;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource numberLines hl-8 hl-9&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot;&gt;&lt;/a&gt;        identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 4]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here‚Äôs what a comparable, syntactically-valid parse looks like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource numberLines hl-8 hl-9 hl-10&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot;&gt;&lt;/a&gt;program [0, 0] - [3, 0]&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot;&gt;&lt;/a&gt;  assignment [0, 0] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot;&gt;&lt;/a&gt;    left: identifier [0, 0] - [0, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot;&gt;&lt;/a&gt;    right: lambda [0, 4] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot;&gt;&lt;/a&gt;      parameters: lambda_parameters [0, 6] - [0, 9]&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot;&gt;&lt;/a&gt;        identifier [0, 7] - [0, 8]&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot;&gt;&lt;/a&gt;        call [1, 2] - [1, 7]&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot;&gt;&lt;/a&gt;          receiver: identifier [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot;&gt;&lt;/a&gt;          method: identifier [1, 4] - [1, 7]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the good parse, tree-sitter produces a &lt;code&gt;call&lt;/code&gt; node. In
the bad parse, it just produces a &lt;code&gt;block&lt;/code&gt; that has a list
containing two elements. Ideally, what we‚Äôd see here is something like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call
  receiver: identifier
  method: ERROR&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which tells us that there was a method call, what the receiver of the
method call was so we know where to start looking for methods to
autocomplete, and that the syntax error was localized to the method
call.&lt;/p&gt;
&lt;p&gt;There‚Äôs a similar problem with constant accesses:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;f &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;g &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;-&amp;gt;&lt;/span&gt;(x) &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  A&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;cn&quot;&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre
class=&quot;sourceCode numberSource numberLines&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot;&gt;&lt;/a&gt;program [0, 0] - [6, 0]&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot;&gt;&lt;/a&gt;      body: block [0, 10] - [2, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot;&gt;&lt;/a&gt;        constant [1, 2] - [1, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot;&gt;&lt;/a&gt;        ERROR [1, 3] - [1, 5]&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot;&gt;&lt;/a&gt;  # ...&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot;&gt;&lt;/a&gt;      body: block [3, 10] - [5, 1]&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot;&gt;&lt;/a&gt;        scope_resolution [4, 2] - [4, 6]&lt;/span&gt;
&lt;span id=&quot;cb7-9&quot;&gt;&lt;a href=&quot;#cb7-9&quot;&gt;&lt;/a&gt;          scope: constant [4, 2] - [4, 3]&lt;/span&gt;
&lt;span id=&quot;cb7-10&quot;&gt;&lt;a href=&quot;#cb7-10&quot;&gt;&lt;/a&gt;          name: constant [4, 5] - [4, 6]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;‚Ä¶ and a similar problem with &lt;code&gt;@&lt;/code&gt; (the start of an instance
variable access), and with &lt;code&gt;x =&lt;/code&gt; (the start of an
assignment).&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;Maybe this example was a little contrived? Comparable programs
written in JavaScript actually parse the good way, so maybe that‚Äôs just
an indictment of tree-sitter-ruby, not tree-sitter itself.&lt;/p&gt;
&lt;p&gt;But this next snippet reproduces in both Ruby and JavaScript:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb8-6&quot;&gt;&lt;a href=&quot;#cb8-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;program [0, 0] - [6, 0]
  class_declaration [0, 0] - [5, 1]
    name: identifier [0, 6] - [0, 7]
    body: class_body [0, 8] - [5, 1]
      member: method_definition [1, 2] - [4, 3]
        name: property_identifier [1, 2] - [1, 5]
        parameters: formal_parameters [1, 5] - [1, 7]
        body: statement_block [1, 8] - [4, 3]
          expression_statement [3, 2] - [3, 9]
            call_expression [3, 2] - [3, 7]
              function: identifier [3, 2] - [3, 5]
              arguments: arguments [3, 5] - [3, 7]
            ERROR [3, 8] - [3, 9]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make it more obvious why this parse tree is not great, it‚Äôs
basically the same parse tree as produced by this program:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre
class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;#cb10-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;#cb10-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;foo&lt;/span&gt;() {&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;#cb10-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;bar&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-4&quot;&gt;&lt;a href=&quot;#cb10-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    {&lt;/span&gt;
&lt;span id=&quot;cb10-5&quot;&gt;&lt;a href=&quot;#cb10-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb10-6&quot;&gt;&lt;a href=&quot;#cb10-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Even though &lt;code&gt;bar() { ... }&lt;/code&gt; is valid method syntax,
there‚Äôs no definition of a method called &lt;code&gt;bar&lt;/code&gt; in the parse.
Instead, the parser thinks that there was a &lt;strong&gt;function
call&lt;/strong&gt; to a function named &lt;code&gt;bar&lt;/code&gt; that doesn‚Äôt
exist.&lt;/li&gt;
&lt;li&gt;The syntax error shows up after the imagined call to
&lt;code&gt;bar&lt;/code&gt; (associated with the &lt;code&gt;{&lt;/code&gt; immediately after
the call to &lt;code&gt;bar&lt;/code&gt;), not associated with the &lt;code&gt;foo&lt;/code&gt;
method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the user‚Äôs cursor was inside the &lt;code&gt;bar&lt;/code&gt; method and
asking for completion results, we‚Äôd be forced to serve them completion
results as though their cursor was inside the half-formed
&lt;code&gt;foo&lt;/code&gt; method, which produces completely wrong results.&lt;/p&gt;
&lt;p&gt;This behavior is not unique to JavaScript. I‚Äôve reproduced it almost
verbatim in Ruby and Java, and partially in most other tree-sitter
parsers (C#, C++, Rust, etc.).&lt;/p&gt;
&lt;p&gt;The best behavior here would be to point out that the curly braces
are mismatched,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Indeed, that‚Äôs &lt;a
href=&quot;https://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2021&amp;amp;gist=872bd946a8789aba9d49e07aef614819&quot;&gt;exactly
the error&lt;/a&gt; on a comparable Rust example. (Rust‚Äôs parser is
hand-written.)&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and then recover assuming that the user fixed that
mismatch, preserving the &lt;code&gt;bar&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;I could turn this into a post full of weird code snippets and poor
parse results, but that‚Äôs not useful. What I‚Äôm trying to show is that
when the demands are, ‚ÄúThe one specific language I care about has lots
of idiosyncratic but common parse errors that I want to handle well,‚Äù
then prepare to devote a substantial amount of time to tweaking anyways.
I prefer doing that in a setting that gives me maximum flexibility, so
that I can be as clever as I need to eke out good parse results.&lt;/p&gt;
&lt;p&gt;Don‚Äôt get me wrong, I still think tree-sitter is a great project with
a neat new idea. I also haven‚Äôt shown how surprisingly good tree-sitter
was on a lot of the examples I tried! All I‚Äôm saying is that tree-sitter
comes with tradeoffs, and that it‚Äôs not useful to respond to every
complaint about an existing parser with, ‚ÄúIf you just used tree-sitter,
your problems would go away,‚Äù because that‚Äôs not true. For a certain
class of parsing problems, tree-sitter is not quite good enough.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If I‚Äôve overlooked something, please let me know and I‚Äôll happily
update this post (and maybe even start using tree-sitter in my
projects).&lt;/em&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="parsing" /><category term="tree-sitter" /><summary type="html">‚Üê Return home tl;dr: no, or at the very least, ‚Äúnot for every use case.‚Äù (Though I really wish it were for the use cases I have, because it would save me a lot of work.)</summary></entry><entry><title type="html">What would a type-aware Rubocop look like?</title><link href="https://blog.jez.io/type-aware-rubocop/" rel="alternate" type="text/html" title="What would a type-aware Rubocop look like?" /><published>2022-05-16T16:17:20-04:00</published><updated>2022-05-16T16:17:20-04:00</updated><id>https://blog.jez.io/type-aware-rubocop</id><content type="html" xml:base="https://blog.jez.io/type-aware-rubocop/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a
  href=&quot;#should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;
  id=&quot;toc-should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should
  every AST node (i.e., every expression) have a type associated with
  it?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-types-for-just-variables-is-enough&quot;
  id=&quot;toc-maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just
  variables is enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a
  href=&quot;#even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;
  id=&quot;toc-even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even
  if this ‚Äúgive me the type of a variable‚Äù API works, is it
  enough?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rubocop-types-or-sorbet-linter&quot;
  id=&quot;toc-rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet +
  linter?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#what-do-people-actually-want-this-for&quot;
  id=&quot;toc-what-do-people-actually-want-this-for&quot;&gt;‚Ä¶ what do people
  actually want this for?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#is-there-anything-like-this-in-another-language&quot;
  id=&quot;toc-is-there-anything-like-this-in-another-language&quot;&gt;‚Ä¶ is there
  anything like this in another language?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#competing-priorities-tend-to-win-out&quot;
  id=&quot;toc-competing-priorities-tend-to-win-out&quot;&gt;Competing priorities
  tend to win out&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#maybe-in-the-future&quot; id=&quot;toc-maybe-in-the-future&quot;&gt;‚ÄúMaybe
  in the future‚Ä¶‚Äù&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;&lt;em&gt;This post represents my opinions at a point in time. It‚Äôs not
necessarily the views of my team or my employer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;From time to time, someone asks, ‚ÄúWould &lt;a
href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt; ever allow defining some sort of
type-aware lint rules?‚Äù The answer has usually been ‚Äúno,‚Äù for a couple
of reasons.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;The biggest open question is that it‚Äôs not 100% clear what use cases
people have in mind. Most commonly people imagine ‚Äúthe full &lt;a
href=&quot;https://rubocop.org/&quot;&gt;Rubocop&lt;/a&gt; API, but with types,‚Äù but this
is underspecified, in my opinion.&lt;/p&gt;
&lt;h3
id=&quot;should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it&quot;&gt;Should
every AST node (i.e., every expression) have a type associated with
it?&lt;/h3&gt;
&lt;p&gt;This would be particularly hard to support, because Sorbet
aggressively simplifies the AST from the start to the end of its
pipeline. The Rubocop AST has something like 100 node types. Sorbet
immediately simplifies this into an AST that only has 30 or so node
types, then subsequently keeps refining the AST until it only has about
15. The thing Sorbet type checks looks nothing like the AST that you‚Äôd
want if you were trying to write a linter, because so much of it has
been desugared, rewritten, or simplified.&lt;/p&gt;
&lt;p&gt;Then finally right before type checking, Sorbet actually abandons the
(tree-based) AST, preferring to use a &lt;strong&gt;control flow
graph&lt;/strong&gt; (CFG) for type checking! A CFG is no longer
tree-based&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;It‚Äôs a graph, where nodes are basic blocks and edges
are control flow jumps between those blocks.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;, which breaks a lot of the assumptions people make about
what‚Äôs easy and hard to build in a linter rule.&lt;/p&gt;
&lt;p&gt;Because Sorbet type checks a CFG only, there‚Äôs no tree-based
structure inside Sorbet that has types. &lt;em&gt;Maybe&lt;/em&gt; it‚Äôs possible to
take the type-annotated CFG and use it to reconstruct some sort of typed
AST, but that sounds brittle and error prone.&lt;/p&gt;
&lt;p&gt;And finally, in the CFG Sorbet doesn‚Äôt associate types with
expressions, only types with variables! This works because the act of
building a CFG assigns all intermediate expressions‚Äô results to a
variable and then only dealing with variables from then on.&lt;/p&gt;
&lt;h3 id=&quot;maybe-types-for-just-variables-is-enough&quot;&gt;Maybe types for just
variables is enough?&lt;/h3&gt;
&lt;p&gt;This would likely be somewhat easier to implement, because Sorbet
already does maintain environments mapping variables to their types.&lt;/p&gt;
&lt;p&gt;However, these data structures are expensive to maintain and
therefore not long-lived.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Sorbet‚Äôs LSP editor integration gets around this by
re-typechecking an entire method every time the user hovers over a
variable. When these hover requests come as (infrequent) requests from
the user, this is fine because Sorbet is already initialized. Powering a
linter this way would either require that the Sorbet server be
initialized for variable type every request (crazy slow), or somehow
kept around persistently (brittle).&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Unlike Sorbet‚Äôs symbol table, which exists indefinitely
after creation, the environments that track variable types only last as
long as is required to type check a single method.&lt;/p&gt;
&lt;p&gt;Maybe there could be an API like ‚Äúplease give me the type of the
variable with this name,‚Äù but again this would be tricky, because
chances are the lint rule author wants to build the lint rule on some
tree-based data structure, and Sorbet only has the CFG. So there would
additionally need to be some mapping between environments (basic blocks)
and AST variable nodes, which again sounds pretty tricky and likely to
break some assumptions.&lt;/p&gt;
&lt;h3
id=&quot;even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough&quot;&gt;Even
if this ‚Äúgive me the type of a variable‚Äù API works, is it enough?&lt;/h3&gt;
&lt;p&gt;Knowing the type of a variable on its own isn‚Äôt very useful. The most
common questions you want ask of a type are:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Is is this type a subtype of this other type?&lt;/li&gt;
&lt;li&gt;If a method with a given name is called on a receiver of this type,
what are the &lt;em&gt;list&lt;/em&gt; of methods that would be dispatched to? (It‚Äôs
a list because the receiver could be a union type.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The answer to (1) requires having the entire symbol table on hand
(lots of memory). The answer to (2) is subtle and complicated‚ÄîSorbet
spends &lt;a
href=&quot;https://github.com/sorbet/sorbet/blob/master/core/types/calls.cc&quot;&gt;about
4,000 lines of code&lt;/a&gt; answering it‚Äîand &lt;em&gt;also&lt;/em&gt; requires having
the symbol table on hand.&lt;/p&gt;
&lt;p&gt;So it‚Äôs probably not enough to just, e.g., return some JSON
representation of one of Sorbet‚Äôs types. It‚Äôd also require having some
structured representation of Sorbet‚Äôs symbol table, which brings us to
our next question:&lt;/p&gt;
&lt;h3 id=&quot;rubocop-types-or-sorbet-linter&quot;&gt;Rubocop + types, or Sorbet +
linter?&lt;/h3&gt;
&lt;p&gt;So far I‚Äôve kind of assumed that we want to start with an existing
linter (Rubocop) and just add types. But what we‚Äôve seen so far is that
the things we‚Äôd need to get types into Rubocop basically amount to
exporting almost all of Sorbet‚Äôs internal data structures.&lt;/p&gt;
&lt;p&gt;Sorbet‚Äôs internal data structures change all the time as we fix bugs,
add features, and refactor things. Having to commit to a stable API for
every internal data structure mentioned above would slow down how
quickly we can improve the rest of Sorbet.&lt;/p&gt;
&lt;p&gt;So maybe instead of exporting an API that Rubocop could use, we
should build a linter into Sorbet? This just has different
tradeoffs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet has to reinvent the wheel on linter APIs (e.g., are lint
rules specified in Ruby code with some new API? Does it attempt to copy
as much of Rubocop‚Äôs API as possible? What happens when there are
papercut differences between what Sorbet‚Äôs linter allows and what
Rubocop does?)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How are rules distributed? Are the rules written in Ruby, and
Sorbet runs the Ruby code with some sort of FFI to expose the internal
data structures? Does Sorbet embed some other scripting language for
writing rules? Do people write rules as shared objects which Sorbet
dynamically loads, akin to Ruby native extensions? Are the rules
committed directly into the Sorbet repo, like how custom DSL and
rewriter passes are right now?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;what-do-people-actually-want-this-for&quot;&gt;‚Ä¶ what do people actually
want this for?&lt;/h3&gt;
&lt;p&gt;Whenever someone asks for a type-aware linter, here are a sampling of
the answers given when I ask, ‚ÄúWhat are you really trying to do?‚Äù&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;‚ÄúBan calling &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt;, because I
just spent half an hour tracking down a bug where I had a
&lt;code&gt;T.nilable(Symbol)&lt;/code&gt; that I called &lt;code&gt;to_s&lt;/code&gt; on and
got the wrong answer.‚Äù&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;‚ÄúUpdate the &lt;a
href=&quot;https://docs.rubocop.org/rubocop-performance/cops_performance.html#performanceinefficienthashsearch&quot;&gt;Performance/InefficientHashSearch&lt;/a&gt;
rule to only act on &lt;code&gt;Hash&lt;/code&gt; values. Not all calls like
&lt;code&gt;xs.values.include?&lt;/code&gt; can be safely rewritten to
&lt;code&gt;xs.value?&lt;/code&gt;.‚Äù&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;‚ÄúDo type-aware codemods, for example change all calls to
&lt;code&gt;x.merchant_&lt;/code&gt; to something like
&lt;code&gt;ClassOfX.get_merchant(x.id)&lt;/code&gt;‚Äù&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;‚ÄúEnforce that all methods returning &lt;code&gt;T::Boolean&lt;/code&gt; have
names ending in &lt;code&gt;?&lt;/code&gt;‚Äù&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It‚Äôs not clear that ‚Äújust‚Äù building a type-aware linter necessarily
solves these problems.&lt;/p&gt;
&lt;p&gt;Doing (1) is hard‚Äîshould we allow &lt;code&gt;Object#to_s&lt;/code&gt;? You could
still accidentally call &lt;code&gt;to_s&lt;/code&gt; on something that‚Äôs
&lt;code&gt;nil&lt;/code&gt; inside a method that accepts &lt;code&gt;Object&lt;/code&gt; if you
do. Also there are sometimes valid cases to call &lt;code&gt;to_s&lt;/code&gt; on
&lt;code&gt;nil&lt;/code&gt; that no type system will help you discover! This
feature seems similar to the &lt;code&gt;#poison&lt;/code&gt; pragma in C and C++,
but there the language makes it easier because &lt;code&gt;#include&lt;/code&gt;‚Äôed
files are explicitly ordered, and it‚Äôs easy to say ‚Äúafter this point,
the identifier is poisoned.‚Äù (Also I‚Äôm not even sure how
&lt;code&gt;#poison&lt;/code&gt; works with methods, not just C functions, where
things like inheritance become a problem.)&lt;/p&gt;
&lt;p&gt;Doing (2) relies on that hard feature we chatted about above: types
for arbitrary expressions, not just variables. If we don‚Äôt have types
for arbitrary expressions, detecting this case in a cop requires
essentially re-inventing Sorbet‚Äôs inference algorithm:
&lt;code&gt;input.map {...}.filter {...}.values.include?&lt;/code&gt;. We mentioned
the difficulty in exposing types for arbitrary expressions above.&lt;/p&gt;
&lt;p&gt;The situation for (3) is something I can really relate to, as there
are a lot of cases where I can imagine this being useful. But rather
than build this as a lint rule, we‚Äôve historically wanted to build these
as IDE-mode code actions: the API is much more constrained (no internal
data structures needed) and the IDE already has the type information in
memory. Sorbet supports a limited number of refactorings now, but mostly
because we haven‚Äôt spent time on it. It‚Äôs reasonable to assume we‚Äôll
build many more refactorings in the future.&lt;/p&gt;
&lt;p&gt;And finally, things like (4) can &lt;em&gt;already&lt;/em&gt; be done in Rubocop.
It‚Äôs slightly more annoying (you have to write the code to parse Sorbet
signature annotations manually) but Sorbet signature annotations are
very stable. Their syntax changes infrequently, and when it does, it‚Äôs
usually minor and/or backwards compatible changes.&lt;/p&gt;
&lt;h3 id=&quot;is-there-anything-like-this-in-another-language&quot;&gt;‚Ä¶ is there
anything like this in another language?&lt;/h3&gt;
&lt;p&gt;Here‚Äôs one of Sorbet‚Äôs explicit design principles:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;As simple as possible, but powerful enough&lt;/p&gt;
&lt;p&gt;Overall, we are not strong believers in super-complex type systems.
They have their place, and we need a fair amount of expressive power to
model (enough) real Ruby code, but all else being equal we want to be
simpler. We believe that such a system scales better, and‚Äîmost
importantly‚Äîis easier for our users to learn &amp;amp; understand.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;‚Äî &lt;a
href=&quot;https://github.com/sorbet/sorbet/#sorbet-user-facing-design-principles&quot;&gt;Sorbet
user-facing design principles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Another way to read this is, ‚Äúwe let other people blaze trails, and
then copy their good ideas.‚Äù&lt;/p&gt;
&lt;p&gt;&lt;del&gt;This question comes up often enough that it makes me want to
imagine that some sort of similar tool exists for other dynamically
typed languages? But as far as I‚Äôm aware, no sort of type-aware linter
exists for TypeScript, Flow, or Mypy.&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-2&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-2&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;&lt;del&gt;If you know of a comparable tool, please do
share!&lt;/del&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; Not having any sort of frame of reference makes it hard
to gauge expectations people have when asking for a tool like
this.&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update, 2022-05-18&lt;/strong&gt;&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-3&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-3&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Thanks to Steve Dignam for pointing out that not only
does C# have static analysis APIs, but that TypeScript does as well,
along with an ecosystem of type-aware lint rules.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; There &lt;em&gt;are&lt;/em&gt; type-aware static analysis tools for
C# and TypeScript. Both languages were designed by the &lt;a
href=&quot;https://en.wikipedia.org/wiki/Anders_Hejlsberg&quot;&gt;same person&lt;/a&gt;,
so maybe this isn‚Äôt surprising. Unfortunately for Sorbet, they were
architected to support static analysis tooling &lt;a
href=&quot;https://en.wikipedia.org/wiki/Roslyn_%28compiler%29#:~:text=Roslyn%20was%20designed%20with%20that%20intent%20from%20the%20beginning.&quot;&gt;from
the beginning&lt;/a&gt;. Sorbet‚Äôs current architecture was instead designed
for batch type checking performance on large monorepos,&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-4&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-4&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;All things considered, it‚Äôs actually quite good at
this.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; and IDE support was grafted on later. Exposing hackable
APIs has so far not been considered.&lt;/p&gt;
&lt;p&gt;For example, TypeScript offers a &lt;a
href=&quot;https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API&quot;&gt;compiler
API&lt;/a&gt;, which is then used by the TypeScript ESLint project, which
allows defining &lt;a
href=&quot;https://typescript-eslint.io/docs/development/custom-rules#type-checking&quot;&gt;custom
type-aware lint rules&lt;/a&gt;. What can we learn from this project?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The TypeScript compiler API does not have any sort of backwards
compatibility guarantee, so breaking changes are published from time to
time.&lt;/li&gt;
&lt;li&gt;It appears that all TypeScript functionality can be accessed behind
the API, including instantiating a stateful object representing the type
checker, running the type checker end-to-end on a project, spawning an
LSP server, etc.&lt;/li&gt;
&lt;li&gt;The way custom lint rules are written is by converting between
ESLint‚Äôs AST node type and TypeScript‚Äôs AST node type. The TypeScript
compiler APIs then allow asking for the type of an AST (i.e.,
expression). I haven‚Äôt confirmed, but this leads me to believe that
TypeScript itself is doing typechecking on the AST (maybe with some
auxiliary structures to track control flow), not on a CFG like Sorbet,
which makes it easier to present the kind of API that makes sense in a
lint rule.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It‚Äôs interesting to &lt;a
href=&quot;https://cs.github.com/typescript-eslint/typescript-eslint?q=%22requiresTypeChecking%3A+true%22&quot;&gt;browse
the rules that require type information&lt;/a&gt; to get a sense for what‚Äôs
possible. Things like &lt;code&gt;strict-boolean-expressions&lt;/code&gt; and
&lt;code&gt;no-floating-promises&lt;/code&gt; are examples of non-trivial lints
using type information.&lt;/p&gt;
&lt;p&gt;I have spent very limited time looking into how things work exactly,
so it‚Äôs possible I‚Äôm misrepresenting the ideas. In any case, I
personally still draw the same conclusion: clearly people in the
TypeScript community derive value from building type-aware lint rules,
and TypeScript is well-architected to enable this. As mentioned in
previous sections, Sorbet‚Äôs current architecture does not present the
same conveniences.&lt;/p&gt;
&lt;h3 id=&quot;competing-priorities-tend-to-win-out&quot;&gt;Competing priorities tend
to win out&lt;/h3&gt;
&lt;p&gt;When attempting to build this feature, we‚Äôd of course have to judge
the cost of what we‚Äôd have to give up.&lt;/p&gt;
&lt;p&gt;Overwhelmingly, the requests people have about Sorbet are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Please fix shape and tuple types.&lt;/li&gt;
&lt;li&gt;Please fix generics (classes and methods).&lt;/li&gt;
&lt;li&gt;Please make Sorbet work faster on large codebases, especially in IDE
mode.&lt;/li&gt;
&lt;li&gt;Please build more refactoring tools. If IntelliJ can do it, I‚Äôd like
Sorbet to do it too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far, these requests have taken priority over greenfield projects,
including things like a type-aware linter.&lt;/p&gt;
&lt;h3 id=&quot;maybe-in-the-future&quot;&gt;‚ÄúMaybe in the future‚Ä¶‚Äù&lt;/h3&gt;
&lt;p&gt;Those are my current thoughts on the topic. Obviously, a lot of these
reasons are just ‚Äúit‚Äôs hard,‚Äù and maybe for someone else those things
would be easy. Others are just selfish, ‚Äúit‚Äôs convenient for us to not
have to think about compatibility,‚Äù and so they‚Äôre easy to disagree
with. Some of them are, ‚Äúthere‚Äôs no clear answer to this question,‚Äù and
sometimes you can wave those away by just picking &lt;em&gt;any&lt;/em&gt; answer
and living with it, rather than searching for the best.&lt;/p&gt;
&lt;p&gt;So while I don‚Äôt think that Sorbet would &lt;em&gt;never&lt;/em&gt; get some sort
of type-aware linter, so far there are many factors that present a
pretty high barrier to building something like this. Hopefully this post
sheds some light on why a type-aware linter for Sorbet does not
currently exist.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="rubocop" /><summary type="html">‚Üê Return home This post represents my opinions at a point in time. It‚Äôs not necessarily the views of my team or my employer.</summary></entry><entry><title type="html">T::Enum Pros &amp;amp; Cons</title><link href="https://blog.jez.io/tenum-pro-con/" rel="alternate" type="text/html" title="T::Enum Pros &amp;amp; Cons" /><published>2022-03-17T19:13:16-04:00</published><updated>2022-03-17T19:13:16-04:00</updated><id>https://blog.jez.io/tenum-pro-con</id><content type="html" xml:base="https://blog.jez.io/tenum-pro-con/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;‚äï&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-cannot-be-combined-in-ad-hoc-unions.&quot;
  id=&quot;toc-tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;üëé
  &lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-is-verbose.&quot; id=&quot;toc-tenum-is-verbose.&quot;&gt;üëé
  &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;
  id=&quot;toc-its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;üëé It‚Äôs
  hard to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#every-ide-feature-sorbet-supports-works-for-tenum.&quot;
  id=&quot;toc-every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;üöÄ Every
  IDE feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tenum-guards-against-basically-all-typos.&quot;
  id=&quot;toc-tenum-guards-against-basically-all-typos.&quot;&gt;üôä
  &lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#it-requires-being-intentional.&quot;
  id=&quot;toc-it-requires-being-intentional.&quot;&gt;ü§ù It requires being
  intentional.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#its-easy-to-search-for.&quot;
  id=&quot;toc-its-easy-to-search-for.&quot;&gt;üïµÔ∏è It‚Äôs easy to search for.&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;One feature that Sorbet doesn‚Äôt have&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;Yet. The biggest limitation is just that Sorbet‚Äôs
approach to type inference is designed to run fast and be simple to
understand, sometimes sacrificing power.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span
class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span
class=&quot;sidenote&quot;&gt;‚Ä¶ but actually Sorbet already has these types
internally üòÖ It‚Äôs just that it doesn‚Äôt have syntax for people to write
them in type annotations. And lo, it‚Äôs &lt;a
href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Ax%20%3D%20%3Adefault%0A%0A1.times%20do%0A%20%20%23%20Sorbet%20does%20not%20report%20an%20error%20here%0A%20%20%23%20%28it%20would%20have%20to%20start%20doing%20so%29%0A%20%20x%20%3D%20%3Afirst%0Aend%0A%0AT.reveal_type%28x%29%20%23%20Sorbet%20shows%20the%20wrong%20type%20here%0A%0A%23%20Sorbet%20can&amp;#39;t%20tell%20the%20difference%20bewteen%20a%20hash%20literal%0A%23%20with%20a%20variable%20key%20versus%20with%20a%20symbol%20literal%20key%0A%23%20at%20the%20time%20that%20inference%20happens.%0AT.reveal_type%28%7Bx%20%3D%3E%20nil%7D%29%0AT.reveal_type%28%7B%3Adefault%20%3D%3E%20nil%7D%29&quot;&gt;because
they‚Äôre buggy&lt;/a&gt;, but for the things where Sorbet needs to use them
internally we can intentionally work around the known bugs, so it hasn‚Äôt
been worth the pain to fix.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; but gets requested frequently is support for literal
string and symbol types. Something like
&lt;code&gt;T.any(:left, :right)&lt;/code&gt;, which is a type that allows either
the symbol literal &lt;code&gt;:left&lt;/code&gt; or &lt;code&gt;:right&lt;/code&gt;, but no
other &lt;code&gt;Symbol&lt;/code&gt;s much less other types of values. The closest
that Sorbet has to this right now is typed enums:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  enums &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; new&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TypeScript, Flow, and Mypy all have literal types. You probably have
felt yourself wanting this. I don‚Äôt really have to explain why they‚Äôre
nice. But I‚Äôll do it anyways, just to prove that I hear you.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;tenum-cannot-be-combined-in-ad-hoc-unions.&quot;&gt;üëé
&lt;code&gt;T::Enum&lt;/code&gt; cannot be combined in ad hoc unions.&lt;/h2&gt;
&lt;p&gt;That‚Äôs a fancy way of saying we‚Äôd like to be able to write
&lt;code&gt;T.any(:left, :right)&lt;/code&gt; in any type annotation, without first
having to pre-declare the new union type to the world. I spoke at length
about how the existence of ad hoc union types make handling exceptional
conditions &lt;a href=&quot;/union-types-checked-exceptions/&quot;&gt;more pleasant than
checked exceptions&lt;/a&gt;, so I‚Äôm right there with you in appreciating that
feature.&lt;/p&gt;
&lt;h2 id=&quot;tenum-is-verbose.&quot;&gt;üëé &lt;code&gt;T::Enum&lt;/code&gt; is verbose.&lt;/h2&gt;
&lt;p&gt;Even if you wanted to pre-declare the enum type. Consider:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;LeftOrRight&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:left&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:right&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Boom. One line, no boilerplate. Wouldn‚Äôt that be nice?&lt;/p&gt;
&lt;h2 id=&quot;its-hard-to-have-one-tenum-be-a-subset-of-another.&quot;&gt;üëé It‚Äôs hard
to have one &lt;code&gt;T::Enum&lt;/code&gt; be a subset of another.&lt;/h2&gt;
&lt;p&gt;This comes up so frequently that there‚Äôs &lt;a
href=&quot;https://sorbet.org/docs/tenum#defining-one-enum-as-a-subset-of-another-enum&quot;&gt;an
FAQ entry&lt;/a&gt; about it. The answer is yet more verbosity and
boilerplate.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;p&gt;So I hear you. But I wanted to say a few things in defense of
&lt;code&gt;T::Enum&lt;/code&gt;, because I think that despite how nice it might be
to have literal types (and again, we may yet build them one day), there
are still &lt;em&gt;a lot of points&lt;/em&gt; in favor of &lt;code&gt;T::Enum&lt;/code&gt; as
it exists today.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h2 id=&quot;every-ide-feature-sorbet-supports-works-for-tenum.&quot;&gt;üöÄ Every IDE
feature Sorbet supports works for &lt;code&gt;T::Enum&lt;/code&gt;.&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;T::Enum&lt;/code&gt;s are just normal constants. Sorbet supports
finding all constant references, renaming constants, autocompleting
constant names, jumping to a constant‚Äôs definition, hovering over a
constant to see its documentation comment. Also all of those features
work on both the enum class itself and each individual enum value.&lt;/p&gt;
&lt;p&gt;We could &lt;em&gt;maybe&lt;/em&gt; support completion for symbol literals in
limited circumstances, but it would be the first of its kind in Sorbet.
Same goes for rename, and maybe find all references. Jump to Definition
I guess would want to jump not to the actual definition, but rather to
the signature that specified the literal type? It‚Äôs weird.&lt;/p&gt;
&lt;h2 id=&quot;tenum-guards-against-basically-all-typos.&quot;&gt;üôä
&lt;code&gt;T::Enum&lt;/code&gt; guards against basically all typos.&lt;/h2&gt;
&lt;p&gt;Even in &lt;code&gt;# typed: false&lt;/code&gt; files! Even when calling methods
that take don‚Äôt have signatures, or that have loose signatures like
&lt;code&gt;Object&lt;/code&gt;! Incidentally, this is basically the same reason why
find all references can work so well.&lt;/p&gt;
&lt;h2 id=&quot;it-requires-being-intentional.&quot;&gt;ü§ù It requires being
intentional.&lt;/h2&gt;
&lt;p&gt;Code gets out of hand really quickly when people try to cutely
interpolate strings into other strings that hold meaning. I‚Äôd much
rather deal with this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;left_or_right, up_or_down&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;than this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you try to do this with &lt;code&gt;T::Enum&lt;/code&gt; you get strings that
look like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;#&amp;lt;LeftOrRight::Left&amp;gt;__#&amp;lt;UpOrDown::Up&amp;gt;&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which confuses people, so they ask how to do the thing they‚Äôre trying
to do, which is a perfect opportunity to talk them down from that cliff.
If people decide that yes, this really is the API we need, we can be
intentional about it with &lt;code&gt;.serialize&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre
class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;direction &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;left_or_right&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;__&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;up_or_down&lt;span class=&quot;at&quot;&gt;.serialize&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;its-easy-to-search-for.&quot;&gt;üïµÔ∏è It‚Äôs easy to search for.&lt;/h2&gt;
&lt;p&gt;This is a small one, but I‚Äôll mention it anyways. It‚Äôs quick to
search the Sorbet docs for &lt;code&gt;T::Enum&lt;/code&gt; and get to the right
page. It‚Äôs similarly easy to find examples of it being used in a given
codebase, to learn from real code. There‚Äôs no unique piece of syntax in
&lt;code&gt;T.any(:left, :right)&lt;/code&gt; that is a surefire thing to search
for.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="fragment" /><category term="sorbet" /><summary type="html">‚Üê Return home One feature that Sorbet doesn‚Äôt have[^yet][^but-actually] but gets requested frequently is support for literal string and symbol types. Something like T.any(:left, :right), which is a type that allows either the symbol literal :left or :right, but no other Symbols much less other types of values. The closest that Sorbet has to this right now is typed enums:</summary></entry></feed>