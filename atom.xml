<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2021-06-05T01:58:44-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  
  <entry>
    <title type="html"><![CDATA[Typed Errors in Sorbet]]></title>
    <link href="https://blog.jez.io/typed-errors-sorbet/"/>
    <updated>2021-06-04T22:12:37-07:00</updated>
    <id>https://blog.jez.io/typed-errors-sorbet</id>
    <content type="html"><![CDATA[<!-- more -->




<p></p>


<p>I really like this post from Matt Parsons, <a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html">The Trouble with Typed
Errors</a>. It&rsquo;s written for an audience writing Haskell,
but if you can grok Haskell syntax, it&rsquo;s worth the read because the
lessons apply broadly to most statically typed programming languages.</p>

<p>If you haven&rsquo;t read it (or it&rsquo;s been a while) the setup is basically:
typing errors is hard, and nearly ever solution is either brittle,
clunky, verbose, or uses powerful type system features that we didn&rsquo;t
want to have to reach for.</p>

<p>Hidden towards the bottom of the post, we find:</p>

<blockquote><p>In PureScript or OCaml, you can use open variant types to do this
flawlessly. Haskell doesn’t have open variants, and the attempts to
mock them end up quite clumsy to use in practice.</p></blockquote>

<p>What Matt calls &ldquo;open variant types&rdquo; I call <strong>ad hoc union types</strong> (see
my previous post about <a href="https://blog.jez.io/union-types-checked-exceptions/">checked exceptions and
Sorbet</a>). Naming aside, Sorbet has them! We don&rsquo;t
have to suffer from clunky error handling!</p>

<p>I thought it&rsquo;d be interesting to show what Matt meant in this quote by
translating his example to Sorbet.</p>

<p>I wrote a complete, working example, but rather than repeat the whole
thing here, I&rsquo;m just going to exerpt the good stuff. If you&rsquo;re wondering
how something is defined in full, check the full example:</p>

<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0A%0A%23%20This%20is%20a%20re-implementation%20of%20Matt%20Parsons's%20%22The%20Trouble%20with%20Typed%0A%23%20Errors%22%20in%20Sorbet%20(Ruby)%20because%20I%20think%20Sorbet%20happens%20to%20handle%20it%0A%23%20pretty%20well%20all%20things%20considered.%0A%23%0A%23%20%20%20%20%20%3Chttps%3A%2F%2Fwww.parsonsmatt.org%2F2018%2F11%2F03%2Ftrouble_with_typed_errors.html%3E%0A%23%0A%23%20Specifically%2C%20he%20mentions%0A%23%0A%23%20%20%20%20%20In%20PureScript%20or%20OCaml%2C%20you%20can%20use%20open%20variant%20types%20to%20do%20this%0A%23%20%20%20%20%20flawlessly.%0A%23%0A%23%20and%20Sorbet%20more%20or%20less%20has%20those%20(untagged%20unions).%20It's%20interesting%0A%23%20to%20see%20what%20that%20means%20for%20being%20able%20to%20track%20errors%2C%20because%20we%0A%23%20actually%20use%20Sorbet%20in%20a%20huge%20codebase%20at%20work.%20Tracking%20all%20the%20kinds%0A%23%20of%20errors%20that%20could%20happen--and%20no%20more--can%20make%20code%20far%20easier%20to%0A%23%20understand.%0A%0A%23%20To%20run%20this%20file%3A%0A%23%0A%23%20%20%20gem%20install%20sorbet-runtime%0A%23%20%20%20ruby%20typed-errors.rb%0A%0Arequire%20'sorbet-runtime'%0A%0A%23%20There's%20a%20bug%20in%20Sorbet%20that%20forces%20us%20to%20wrap%20all%20this%20code%20in%20a%0A%23%20class%2C%20but%20I%20have%20a%20PR%20open%20to%20fix%20it.%20For%20now%2C%20we%20tolerate%20it.%0Aclass%20Main%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20%23%20-----%20Custom%20error%20types%20-----%0A%0A%20%20%23%20Defining%20custom%20data%20types%20is%20a%20little%20clunky%20in%20Ruby%20%2F%20Sorbet.%20You%0A%20%20%23%20have%20to%20chose%20whether%20you%20want%20a%20plain%20class%2C%20an%20enum%2C%20a%20sealed%0A%20%20%23%20class%20hierarchy%2C%20etc.%20In%20a%20real%20codebase%2C%20I%20think%20if%20you%20were%20going%0A%20%20%23%20to%20this%20length%20to%20care%20for%20errors%20the%20kinds%20of%20errors%20that%20you%20have%0A%20%20%23%20are%20usually%20pretty%20rich%20(e.g.%2C%20there's%20a%20message%20and%20context%20with%0A%20%20%23%20the%20failures)%2C%20so%20you'd%20probably%20go%20with%20the%20sealed%20class%20hierarchy.%0A%20%20%23%0A%20%20%23%20For%20this%20example%2C%20I%20chose%20three%20different%20ways%20to%20just%20show%20them%20all.%0A%0A%20%20class%20HeadError%0A%20%20end%0A%0A%20%20class%20LookupError%20%3C%20T%3A%3AEnum%0A%20%20%20%20enums%20do%0A%20%20%20%20%20%20KeyWasNotPresent%20%3D%20new%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20module%20ParseError%0A%20%20%20%20extend%20T%3A%3AHelpers%0A%20%20%20%20sealed!%0A%0A%20%20%20%20class%20UnexpectedChar%20%3C%20T%3A%3AStruct%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20%20%20prop%20%3Amessage%2C%20String%0A%20%20%20%20end%0A%0A%20%20%20%20class%20RanOutOfInput%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Helper%20methods%20-----%0A%0A%20%20%23%20Again%2C%20concise%20syntax%20is%20not%20Sorbet's%20strong%20suit.%20The%20signature%0A%20%20%23%20annotations%20are%20pretty%20verbose%20here%20(especially%20generics)%20but%20they%0A%20%20%23%20pretty%20much%20exactly%20map%20to%20the%20Haskell%20functions%20in%20the%20post.%0A%0A%20%20sig%20do%0A%20%20%20%20%20%20params(xs%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(String%2C%20HeadError))%0A%20%20end%0A%20%20def%20self.head(xs)%0A%20%20%20%20case%20xs.size%0A%20%20%20%20when%200%20then%20HeadError.new%0A%20%20%20%20else%20T.must(xs%5B0%5D)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters(%3AK%2C%20%3AV)%0A%20%20%20%20%20%20.params(%0A%20%20%20%20%20%20%20%20hash%3A%20T%3A%3AHash%5BT.type_parameter(%3AK)%2C%20T.type_parameter(%3AV)%5D%2C%0A%20%20%20%20%20%20%20%20key%3A%20T.type_parameter(%3AK)%0A%20%20%20%20%20%20)%0A%20%20%20%20%20%20.returns(T.any(T.type_parameter(%3AV)%2C%20LookupError))%0A%20%20end%0A%20%20def%20self.lookup(hash%2C%20key)%0A%20%20%20%20if%20hash.key%3F(key)%0A%20%20%20%20%20%20hash.fetch(key)%0A%20%20%20%20else%0A%20%20%20%20%20%20LookupError%3A%3AKeyWasNotPresent%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20params(source%3A%20String).returns(T.any(Integer%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.parse(source)%0A%20%20%20%20case%20source%0A%20%20%20%20when%20%22%22%20then%20ParseError%3A%3ARanOutOfInput.new%0A%20%20%20%20else%0A%20%20%20%20%20%20begin%0A%20%20%20%20%20%20%20%20Integer(source%2C%2010)%0A%20%20%20%20%20%20rescue%20ArgumentError%20%3D%3E%20exn%0A%20%20%20%20%20%20%20%20ParseError%3A%3AUnexpectedChar.new(message%3A%20exn.message)%0A%20%20%20%20%20%20end%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Composing%20errors%20-----%0A%0A%20%20STR_MAP%20%3D%20T.let(%7B%0A%20%20%20%20%224__%22%20%3D%3E%20%222%22%0A%20%20%7D%2C%20T%3A%3AHash%5BString%2C%20String%5D)%0A%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20HeadError%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.foo(str)%0A%20%20%20%20%23%20These%20%60return%60%20lines%20are%20definitely%20not%20as%20convenient%20as%20do%0A%20%20%20%20%23%20notation%20in%20Haskell%2C%20but%20the%20interesting%20thing%20is%20that%20they're%0A%20%20%20%20%23%20still%20pretty%20nice%3A%20because%20of%20flow-sensitive%20typing%2C%20the%20type%20of%0A%20%20%20%20%23%20%60c%60%20changes%2C%20as%20commented%3A%0A%20%20%20%20c%20%3D%20head(str)%20%23%20%3D%3E%20c%20%3A%20T.any(String%2C%20HeadError)%0A%20%20%20%20return%20c%20unless%20c.is_a%3F(String)%0A%20%20%20%20%23%20%3D%3E%20c%20%3A%20String%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(%22%23%7Bc%7D%23%7Br%7D%22)%0A%20%20end%0A%0A%20%20%23%20This%20method%20doesn't%20call%20%60head%60%20like%20before%2C%20so%20it%20doesn't%20need%20to%0A%20%20%23%20have%20%60HeadError%60%20in%20the%20return%20type.%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.bar(str)%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(r)%0A%20%20end%0A%0A%20%20p%20foo(%224__%22)%0A%20%20p%20bar(%224__%22)%0Aend%0A%0A%23%20Because%20%60T.any%60%20can%20create%20ad%20hoc%2C%20untagged%20union%20types%20anywhere%2C%0A%23%20there's%20no%20need%20to%20define%20an%20%60AllErrorsEver%60%20data%20type%20like%20the%20reader%0A%23%20was%20tempted%20to%20in%20the%20Typed%20Errors%20blog%20post.%0A%23%0A%23%20If%20you%20find%20that%20a%20particular%20set%20of%20errors%20are%20showing%20up%20super%0A%23%20frequently%2C%20you%20can%20lurk%20them%20into%20a%20type%20alias%3A%0A%23%0A%23%20%20%20%20%20MostCommonErrors%20%3D%20T.type_alias%20%7BT.any(LookupError%2C%20ParseError)%7D%0A%23%0A%23%20and%20then%20use%20this%20alias%20in%20various%20places.%0A%23%0A%23%20One%20other%20note%3A%20to%20make%20this%20pattern%20nicer%2C%20code%20might%20want%20to%0A%23%20explicitly%20box%20up%20successful%20results%2C%20with%20a%20type%20like%0A%23%0A%23%20%20%20%20%20class%20Ok%20%3C%20T%3A%3AStruct%0A%23%20%20%20%20%20%20%20extend%20T%3A%3AGeneric%0A%23%20%20%20%20%20%20%20Type%20%3D%20type_member%0A%23%20%20%20%20%20%20%20prop%20%3Aval%2C%20Type%0A%23%20%20%20%20%20end%0A%23%0A%23%20So%20then%20you'd%20have%0A%23%20%20%20%20%20T.any(Ok%5BString%5D%2C%20MostCommonErrors)%0A%23%20and%20you%20could%20do%20make%20all%20the%20%60return%60%20lines%20always%20look%20the%20same%3A%0A%23%20%20%20%20%20return%20x%20unless%20x.is_a%3F(Ok)%0A%23%20but%20the%20flipside%20would%20mean%20that%20you'd%20have%20to%20use%20%60.val%60%20at%20all%20the%0A%23%20places%20that%20you%20would%20have%20normally%20used%20%60x%60%3A%0A%23%20%20%20%20%20parse(x.val)%0A%23%20so%20it's%20maybe%20not%20worth%20it.%0A%0A">→ View on sorbet.run</a></p>

<p>First, here&rsquo;s how we&rsquo;d type the three running helper methods from Matt&rsquo;s
post:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Returns the first letter of the input,</span>
</span><span class='line'><span class="c1"># or returns `HeadError` if empty</span>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">xs: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">String</span><span class="p">,</span> <span class="no">HeadError</span><span class="p">))}</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">head</span><span class="p">(</span><span class="n">xs</span><span class="p">);</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1"># Gets the value for `key` in `hash`, or returns LookupError.</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># This is normally defined in the stdlib, and in trying to</span>
</span><span class='line'><span class="c1"># match Matt's post, it ends up not being super idiomatic,</span>
</span><span class='line'><span class="c1"># but the types still work out.</span>
</span><span class='line'><span class="n">sig</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">type_parameters</span><span class="p">(</span><span class="ss">:K</span><span class="p">,</span> <span class="ss">:V</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">params</span><span class="p">(</span>
</span><span class='line'>      <span class="ss">hash: </span><span class="no">T</span><span class="o">::</span><span class="no">Hash</span><span class="p">[</span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:K</span><span class="p">),</span> <span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:V</span><span class="p">)],</span>
</span><span class='line'>      <span class="ss">key: </span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:K</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">type_parameter</span><span class="p">(</span><span class="ss">:V</span><span class="p">),</span> <span class="no">LookupError</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">lookup</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">;</span> <span class="n">en</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1"># Convert a String to an integer, or return ParseError.</span>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">source: </span><span class="no">String</span><span class="p">).</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">))}</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">source</span><span class="p">);</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">;</span> <span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>Notice how in all three cases, we use a normal <a href="https://sorbet.org/docs/union-types">Sorbet union type</a> in the
return, like <code>T.any(String, HeadError)</code>. All of the error types are just
user-defined classes. For example,<code>HeadError</code> is just defined like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">HeadError</span><span class="p">;</span> <span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>Then at the caller side, it&rsquo;s simple to handle the errors:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">sig</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">params</span><span class="p">(</span><span class="ss">str: </span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">HeadError</span><span class="p">,</span> <span class="no">LookupError</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">foo</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'>  <span class="n">c</span> <span class="o">=</span> <span class="n">head</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="c1"># =&gt; c : T.any(String, HeadError)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">c</span> <span class="k">unless</span> <span class="n">c</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># =&gt; c : String</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="no">STR_MAP</span><span class="p">,</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">r</span> <span class="k">unless</span> <span class="n">r</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parse</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">c</span><span class="si">}#{</span><span class="n">r</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>The idea is that the return type includes the possible errors, so we
have to handle them. This example handles the errors by checking for
success and returning early with the error otherwise. This manifests in
the return type of <code>foo</code>, which mentions four outcomes:</p>

<ul>
<li>a successful result (<code>Integer</code>)</li>
<li>three kinds of failures (<code>HeadError</code>, <code>LookupError</code>, and <code>ParseError</code>)</li>
</ul>


<p>It would have worked equally well to handle and recover from any or all
of the errors: Sorbet knows exactly which error is returned by which
method, so there&rsquo;s never a burden of handling more errors than are
possible.</p>

<p>It&rsquo;s fun that what makes this work is Sorbet&rsquo;s natural <a href="https://sorbet.org/docs/flow-sensitive">flow-sensitive
typing</a>, not some special language feature. Notice how before and after
the first early return, Sorbet updates its knowledge of the type of <code>c</code>
(shown in the comments) because it knows how <code>is_a?</code> works.</p>

<p>Another example: if some other method only calls <code>lookup</code> and <code>parse</code>
(but not <code>head</code>), it doesn&rsquo;t have to mention <code>HeadError</code> in its return:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">sig</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">params</span><span class="p">(</span><span class="ss">str: </span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># does need to mention HeadError</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Integer</span><span class="p">,</span> <span class="no">LookupError</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">bar</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'>  <span class="n">r</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">(</span><span class="no">STR_MAP</span><span class="p">,</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">r</span> <span class="k">unless</span> <span class="n">r</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>  <span class="n">parse</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>And while there&rsquo;s never a <strong>need</strong> to predeclare one monolithic error type
(like <code>AllErrorsEver</code> in Matt&rsquo;s post), if it happens to be convenient,
Sorbet still lets you, using type alises. For example, maybe there are a
bunch of methods that all return <code>LookupError</code> and <code>ParseError</code>. We can
factor that out into a type alias:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">MostCommonErrors</span> <span class="o">=</span> <span class="no">T</span><span class="p">.</span><span class="nf">type_alias</span> <span class="p">{</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">LookupError</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">)}</span></span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s it! Sorbet&rsquo;s union types in method returns provide a
low-friction, high value way to model how methods can fail.</p>
]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have Checked Exceptions]]></title>
    <link href="https://blog.jez.io/union-types-checked-exceptions/"/>
    <updated>2021-05-29T01:21:41-07:00</updated>
    <id>https://blog.jez.io/union-types-checked-exceptions</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a common question I get asked about Sorbet:</p>

<blockquote><p>Does Sorbet support checked exceptions, like Java?</p></blockquote>

<p>(In fact, this was the <a href="https://youtu.be/odmlf_ezsBo?t=1921">first question</a> I was asked at my <a href="https://jez.io/talks/state-of-sorbet-2019/">first
conference talk</a>.)</p>

<p>The answer: Sorbet doesn&rsquo;t support checked exceptions, and I don&rsquo;t think
it ever should.</p>

<!-- more -->


<p>Before I dive in, there are two pretexts I&rsquo;m assuming: either you asked
this question and someone linked you this post, or the post title was
enough to catch your attention. Either way, I&rsquo;m going to take for
granted that you know what I mean by &ldquo;checked exceptions.&rdquo; If you want a
quick refresher, jump down to the <a href="#appendix">Appendix</a> and then come
back.</p>

<p>My claim is that checked exceptions are a poor man&rsquo;s ad hoc union types,
that since Sorbet has ad hoc union types it doesn&rsquo;t need checked
exceptions. I&rsquo;ll discuss this claim in three parts:</p>

<ul>
<li>I&rsquo;ll give some background on what it means for union types to be &ldquo;ad
hoc,&rdquo; which applies to Sorbet&rsquo;s union types but are somewhat rare.</li>
<li>I&rsquo;ll describe a translation from checked exceptions in Java to
union-typed returns in Ruby with a concrete example.</li>
<li>I&rsquo;ll give evidence for why the union types approach is better.</li>
</ul>


<p>(If you want to skip straight to the good stuff, the analysis <a href="#analysis">is down
here</a>.)</p>

<h2>Background: Sorbet&rsquo;s union types</h2>

<blockquote><p>The throws clause is the only point in the entire Java language that
allows union types. You can tack &ldquo;throws A,B,C&rdquo; onto a method
signature meaning it might throw A or B or C, but outside of the
throws clause you cannot say &ldquo;type A or B or C&rdquo; in Java.</p>

<p>— James Iry, <em><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t
In Java</a></em> (2012)</p></blockquote>

<p>Sorbet supports <a href="https://sorbet.org/docs/union-types">union types</a>. More specifically, Sorbet&rsquo;s union types
are ad hoc: any number of types can be unioned together on demand:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="p">,</span> <span class="no">C</span><span class="p">))}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">;</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span><span class="p">;</span> <span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>By contrast, many languages with union types require predeclaring a
union&rsquo;s variants, for example in Rust:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='rust'><span class='line'><span class="k">enum</span> <span class="n">AorBorC</span> <span class="p">{</span>
</span><span class='line'>    <span class="nf">A</span><span class="p">(</span><span class="n">A</span><span class="p">),</span>
</span><span class='line'>    <span class="nf">B</span><span class="p">(</span><span class="n">B</span><span class="p">),</span>
</span><span class='line'>    <span class="nf">C</span><span class="p">(</span><span class="n">C</span><span class="p">),</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>That Sorbet allows defining union types on demand is similar to Java&rsquo;s
<code>throws</code> clause, but more powerful: <code>throws A, B, C</code> is not a type,
while <code>T.any(A, B, C)</code> is. We&rsquo;ll see why that matters below.</p>

<h2>Example: From checked exceptions to union types</h2>

<p>Using Sorbet&rsquo;s ad hoc union types, it&rsquo;s mechanical to convert Java-style
checked exceptions to Sorbet-annotated Ruby. To demonstrate:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Currency</span> <span class="nf">parseCurrency</span><span class="o">(</span><span class="n">String</span> <span class="n">currencyStr</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="n">KNOWN_CURRENCIES</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">currencyStr</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">currency</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ParseException</span><span class="o">(</span>
</span><span class='line'>          <span class="s">"'"</span> <span class="n">currencyStr</span> <span class="o">+</span> <span class="s">"' is not a valid currency"</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">currency</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>This is a somewhat contrived Java method, but it&rsquo;ll be good enough to
demonstrate the concepts.</p>

<p>If <code>parseCurrency</code> is given a string it can&rsquo;t handle, it raises a
<code>ParseException</code>. It declares this with <code>throws</code> because
<code>ParseException</code> is a checked exception. If the currency string is
recognized, it returns some <code>Currency</code> object.</p>

<p>Here&rsquo;s how we&rsquo;d write that in Sorbet:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># (0) Ruby's standard library doesn't have `ParseException`,</span>
</span><span class='line'><span class="c1"># so I've re-implemented it.</span>
</span><span class='line'><span class="k">class</span> <span class="nc">ParseError</span> <span class="o">&lt;</span> <span class="no">T</span><span class="o">::</span><span class="no">Struct</span>
</span><span class='line'>  <span class="n">const</span> <span class="ss">:message</span><span class="p">,</span> <span class="no">String</span>
</span><span class='line'>  <span class="n">const</span> <span class="ss">:offset</span><span class="p">,</span> <span class="no">Integer</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># (1) return type + `throws` becomes just `returns`</span>
</span><span class='line'><span class="c1"># (2) Return type uses `T.any`</span>
</span><span class='line'><span class="n">sig</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">params</span><span class="p">(</span><span class="ss">currency_str: </span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Currency</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">def</span> <span class="nf">parse_currency</span><span class="p">(</span><span class="n">currency_str</span><span class="p">)</span>
</span><span class='line'>  <span class="n">currency</span> <span class="o">=</span> <span class="no">KNOWN_CURRENCIES</span><span class="p">[</span><span class="n">currency_str</span><span class="p">]</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">currency</span><span class="p">.</span><span class="nf">nil?</span>
</span><span class='line'>    <span class="c1"># (3) `throw` becomes `return`</span>
</span><span class='line'>    <span class="k">return</span> <span class="no">ParseError</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
</span><span class='line'>      <span class="ss">message: </span><span class="s2">"'</span><span class="si">#{</span><span class="n">currency_str</span><span class="si">}</span><span class="s2">' is not a valid currency"</span><span class="p">,</span>
</span><span class='line'>      <span class="ss">offset: </span><span class="mi">0</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">currency</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>The important changes:</p>

<ol>
<li>Where Java had a return type and a <code>throws</code> clause, Sorbet just has a
return type.</li>
<li>Sorbet&rsquo;s return type is a union type (<code>T.any(...)</code>). It mentions the Java
method&rsquo;s return type and all the exceptions mentioned in the <code>throws</code>.</li>
<li>Where the Java example uses <code>throw</code>, the Ruby example uses <code>return</code>.</li>
</ol>


<p>Our translation isn&rsquo;t complete until we see how the <code>parseCurrency</code>
caller side changes. In Java, we call <code>parseCurrency</code> like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Charge</span> <span class="nf">createCharge</span><span class="o">(</span><span class="kt">int</span> <span class="n">amount</span><span class="o">,</span> <span class="n">String</span> <span class="n">currencyStr</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ParseException</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Currency</span> <span class="n">currency</span> <span class="o">=</span> <span class="n">parseCurrency</span><span class="o">(</span><span class="n">currencyStr</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">Charge</span><span class="o">(</span><span class="n">amount</span><span class="o">,</span> <span class="n">currency</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>With Sorbet, this snippet becomes:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">sig</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">params</span><span class="p">(</span><span class="ss">amount: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">currency_str: </span><span class="no">String</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="nf">returns</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">Charge</span><span class="p">,</span> <span class="no">ParseError</span><span class="p">))</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">def</span> <span class="nf">create_charge</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">currency_str</span><span class="p">)</span>
</span><span class='line'>  <span class="n">currency</span> <span class="o">=</span> <span class="n">parse_currency</span><span class="p">(</span><span class="n">currency_str</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">currency</span> <span class="k">unless</span> <span class="n">currency</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Currency</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Charge</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">amount: </span><span class="n">amount</span><span class="p">,</span> <span class="ss">currency: </span><span class="n">currency</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>As before, the <code>throws</code> clause in Java becomes a union-typed return in Ruby.</p>

<p>The new bit is the explicit <code>return ... unless ...</code>. Whereas uncaught
exceptions implicitly bubble up to the caller, return values only bubble
up if explicitly returned. This is a key benefit of the union types
approach, which brings us to our next section.</p>

<h2 id="analysis">Analysis: Why the union types approach is better</h2>


<p>To recap, Sorbet&rsquo;s union types are ad hoc, much in the same sense as the
classes mentioned in Java&rsquo;s <code>throws</code> clause. When converting from <code>Java</code> to
<code>Ruby</code>, a single, union-typed return takes the place of a separate return
type and <code>throws</code> clause.</p>

<p>First off, this translation preserves the best parts of checked
exceptions:</p>

<ul>
<li><p>A method&rsquo;s failure modes still appear in an <strong>explicit, public API</strong>.</p>

<p>In both Java and Ruby, the method signature behaves as machine-checked
error documentation.</p></li>
<li><p>Ad hoc error specifications enable <strong>low-friction composition</strong>.</p>

<p>In both Java and Ruby, if our method is the first to combine two
methods with unrelated failure modes, there&rsquo;s no ceremony to
predeclare that combination. Instead, we just mention one more class
in the method&rsquo;s signature.</p></li>
</ul>


<p>But this approach is not only as good, it&rsquo;s better, because:</p>

<ul>
<li><p>As a language feature, <strong>union types are not special</strong>.</p>

<p>Union types are types. Like other types, we can store them in
variables. We can factor common error recovery code into helper
functions. We can map functions returning union types over lists. We
can write type aliases that abbreviate commonly-grouped error classes.
We can&rsquo;t do any of this with checked exceptions, and this is the most
common complaint against them.</p></li>
<li><p>Union types have <strong>call-site granularity</strong>, not method-body
granularity.</p>

<p>The union types approach forces a choice of how to handle errors at
each call site. This is more robust in the face of changing code,
because new call sites should not necessarily inherit the error
handling logic of existing call sites. Just because one
<code>ParseException</code> was uncaught and mentioned in the <code>throws</code> does not
mean all of them should be.</p></li>
</ul>


<p>And finally, let me get out ahead of some common counter arguments.</p>

<blockquote><p>The union types approach requires more typing at the call site!</p></blockquote>

<p>Yep. But I&rsquo;ve already counted this as a blessing, not a curse.</p>

<blockquote><p>But real-world Ruby code already uses exceptions!</p></blockquote>

<p>Yep. But in Java too, the world is already split into checked and
unchecked exceptions. In both Java and Ruby, exceptions are a fact of
life, and you&rsquo;ll always need a way to deal with unexpected exceptions
(e.g., comprehensive tests, automated production alerting, etc.).</p>

<blockquote><p>With checked exceptions, I could handle all the failures at once!</p></blockquote>

<p>That&rsquo;s true; with checked exceptions, it&rsquo;s easy to write a single
<code>catch</code> statement that handles all failures due to, say, a
<code>ParseException</code> in a whole region of code, avoiding the need for code
repetition.</p>

<p>The upshot is that with union types, we can just use functions. Take
everything in the <code>catch</code> body, put it in a helper function, and call it
at each call site.  This cuts down on duplication, and I already
mentioned how call-site granularity is a win.</p>

<h2>I love union types</h2>

<p>That&rsquo;s pretty much it. Sorbet doesn&rsquo;t need checked exceptions, it
already has ad hoc union types.</p>

<hr />

<h2 id="appendix">Appendix: Checked Exceptions</h2>


<p>As a quick refresher, <a href="https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions">checked exceptions</a> are a feature popularized by
Java. The syntax looks like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">void</span> <span class="nf">doThing</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">MyException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>The <code>throws</code> keyword is a part of the method&rsquo;s signature, just like
argument and return types. It declares that this method might throw
<code>MyException</code>.</p>

<p>Since it&rsquo;s a part of this method&rsquo;s signature the <code>throws</code> annotation
will be checked at all call sites (just like argument and return types).
A method containing calls to <code>doThing</code> must either <code>catch</code> all mentioned
exceptions or repeat any maybe-thrown-but-uncaught exceptions in its own
<code>throws</code> clause.</p>

<p>If a method throws multiple classes of exceptions, they can all be
listed:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">void</span> <span class="nf">doThing</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">MyException</span><span class="o">,</span> <span class="n">YourException</span><span class="o">,</span> <span class="n">AnotherException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>The argument in favor of checked exceptions is that they&rsquo;re explicit and
machine-checked. Users don&rsquo;t have to guess at what a method might throw,
or hope that there&rsquo;s accurate documentation—all benefits shared by
static typing in general, which is a sympathetic goal.</p>

<p>Checked exceptions seem like a good feature on paper. In practice,
they&rsquo;re generally regretted. I&rsquo;m nowhere near the first person to come
to this conclusion, so instead I&rsquo;ll link you to some previous
discussions:</p>

<ul>
<li><a href="https://www.artima.com/articles/the-trouble-with-checked-exceptions">The Trouble with Checked Exceptions</a>, A Conversation
with Anders Hejlsberg</li>
<li><a href="http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html">Checked Exceptions Might Have Their Place, But It Isn&rsquo;t In
Java</a>, by James Iry</li>
<li><a href="https://ericlippert.com/2008/09/10/vexing-exceptions/">Vexing Exceptions</a>, by Eric Lippert</li>
</ul>


<p>(The last one isn&rsquo;t actually about checked exceptions: it&rsquo;s just about
exceptions and I like it, so I included it.)</p>

<p>Java has been copied and imitated for decades. Among all the features we
see other languages copy from Java, checked exceptions are absent.</p>
]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Exploring Ruby with clangd]]></title>
    <link href="https://blog.jez.io/clangd-ruby/"/>
    <updated>2020-07-21T15:40:23-07:00</updated>
    <id>https://blog.jez.io/clangd-ruby</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve managed to get LSP-based IDE features powered by <a href="https://clangd.llvm.org/">clangd</a> working
for the Ruby VM&rsquo;s source code (in my case, in Vim). Here&rsquo;s how I did it!</p>

<!-- more -->


<p>I&rsquo;ve been making a point to learn more about <a href="https://blog.jez.io/search-down-the-stack/">things I depend
on</a> recently. Today, that means learning about
Ruby. And what better way to learn than to check out the source code,
and jump around?</p>

<p><a href="https://clangd.llvm.org/">clangd</a> is an editor-agnostic language server that uses the <a href="https://langserver.org/">Language
Server Protocol</a> to power IDE-like features in
your preferred text editor. All it needs is a <code>compile_commands.json</code>,
which is basically a mapping of filename to options to pass to <code>clang</code>
so that it knows things like which warnings to enable and where to
search for header files.</p>

<p><a href="https://clangd.llvm.org/">clangd</a> works best for projects built using <code>cmake</code>, but the Ruby VM
doesn&rsquo;t use <code>cmake</code>. Regardless, we can make a <code>compile_commands.json</code>
file by using <a href="https://github.com/rizsotto/Bear">Bear</a> to trace the execution of a Ruby build, and use the
trace information to write out a <code>compile_commands.json</code> file.</p>

<h2>Steps</h2>

<p>I could only get these steps to work for Linux, as the Bear README
mentions that on macOS you have to disable System Integrity Protection
to get it to work.</p>

<h3>1. Install <a href="https://github.com/rizsotto/Bear">Bear</a></h3>

<p>I describe how I built Bear from source in the Appendix.</p>

<h3>2. Clone the Ruby source code.</h3>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/ruby/ruby
</span><span class='line'><span class="nb">cd </span>ruby</span></code></pre></td></tr></table></div></figure>


<h3>3. Configure the Ruby build.</h3>

<p>We have to tell the <code>configure</code> script to use Clang to compile (or
if you&rsquo;re confident that your system compiler toolchain is Clang,
you can just run <code>./configure</code>).</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Create the ./configure file</span>
</span><span class='line'>autoconf
</span><span class='line'><span class="c"># This only works when using clang to build Ruby</span>
</span><span class='line'>./configure <span class="nv">CC</span><span class="o">=</span>clang</span></code></pre></td></tr></table></div></figure>


<h3>4. Use <code>bear</code> to invoke <code>make</code></h3>

<p>Bear will use a dynamically preloaded library to trace system calls
that exec <code>clang</code> processes, looking at things like the command line
arguments given to Clang.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>bear make</span></code></pre></td></tr></table></div></figure>


<h3>5. That&rsquo;s it!</h3>

<p>The output is <code>./compile_commands.json</code>, which should be non-empty. If
it&rsquo;s empty or just has <code>[]</code>, it didn&rsquo;t work. There&rsquo;s some
troubleshooting in the <a href="https://github.com/rizsotto/Bear">Bear</a> README.</p>

<p>The <code>compile_commands.json</code> file will be consumed by <code>clangd</code> in your
editor. Check <a href="https://langserver.org">https://langserver.org</a> to find an LSP client for your
preferred editor, and follow its setup instructions.</p>

<p>Once you&rsquo;ve built the <code>compile_commands.json</code> file and configured your
editor to use LSP with <code>clangd</code>, you should be able to do things like
Jump to Definition and Hover on the Ruby source code!</p>

<h2>Appendix: Building Bear from source</h2>

<p>This is probably common knowledge for people who use <code>cmake</code> regularly,
but this is how I built Bear from source, because I built it on a
machine where I didn&rsquo;t have root so I couldn&rsquo;t write to <code>/usr/local</code>.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone https://github.com/rizsotto/Bear
</span><span class='line'><span class="nb">cd </span>Bear
</span><span class='line'>mkdir build
</span><span class='line'><span class="nb">cd </span>build
</span><span class='line'>
</span><span class='line'><span class="c"># Install to $HOME/.local/bin instead of /usr/local/bin</span>
</span><span class='line'>cmake .. <span class="s2">"-DCMAKE_INSTALL_PREFIX=</span><span class="nv">$HOME</span><span class="s2">/.local"</span>
</span><span class='line'>make -j<span class="k">$(</span>nproc<span class="k">)</span>
</span><span class='line'>make install
</span><span class='line'>
</span><span class='line'><span class="c"># → $HOME/.local/bin/bear exists now</span></span></code></pre></td></tr></table></div></figure>


<h2>Appendix: LSP in Neovim with LanguageClient-neovim</h2>

<p>I use Neovim. My preferred LSP client is <a href="https://github.com/autozimu/LanguageClient-neovim">LanguageClient-neovim</a>. Here&rsquo;s
the parts of my Neovim config files that setup <code>clangd</code>:</p>

<p><a href="https://github.com/jez/dotfiles/blob/865a74d93d8ab1c28713ae0dcd53797b6c26dc6a/vim/plug-settings.vim#L576-L587">→ <code>vim/plug-settings.vim</code> in jez/dotfiles</a></p>
]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Linkers & Ruby C Extensions]]></title>
    <link href="https://blog.jez.io/linkers-ruby-c-exts/"/>
    <updated>2020-06-07T12:05:07-05:00</updated>
    <id>https://blog.jez.io/linkers-ruby-c-exts</id>
    <content type="html"><![CDATA[<p>I recently learned that linkers are really cool. It all started when I
saw an error message that looked something like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ rake test
</span><span class='line'>symbol lookup error: /home/jez/.../foo.so: undefined symbol bar</span></code></pre></td></tr></table></div></figure>


<p>I <a href="https://blog.jez.io/search-down-the-stack/">already wrote</a> about finding where this
error was coming from. The tl;dr is that it was coming from GNU&rsquo;s libc
implementation:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ rg -t c 'symbol lookup error'
</span><span class='line'>dl-lookup.c
</span><span class='line'>876:      _dl_signal_cexception (0, &exception, N_("symbol lookup error"));</span></code></pre></td></tr></table></div></figure>


<p>That led me to a fun exploration of how linux linkers work, and how Ruby
C extensions rely on them.</p>

<p>I always knew that Ruby C extensions existed (that they <a href="https://twitter.com/asolove/status/1261339091485917184">break all the
time</a> is a constant reminder&hellip;) but I never really connected
the dots between &ldquo;here&rsquo;s some C code&rdquo; and how Ruby actually runs that
code.</p>

<p>Ruby C extensions are just shared libraries following certain
conventions. Specifically, a Ruby C extension might look like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include "ruby.h"
</span><span class='line'></span>
</span><span class='line'><span class="n">VALUE</span> <span class="nf">my_foo</span><span class="p">(</span><span class="n">VALUE</span> <span class="n">self</span><span class="p">,</span> <span class="n">VALUE</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">rb_funcall</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">rb_intern</span><span class="p">(</span><span class="s">"puts"</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This function's name matters:
</span><span class='line'></span><span class="kt">void</span> <span class="nf">Init_my_lib</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">rb_define_method</span><span class="p">(</span><span class="n">rb_cObject</span><span class="p">,</span> <span class="s">"foo"</span><span class="p">,</span> <span class="n">my_foo</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>The important part is that the name of that <code>Init_my_lib</code> function
matters. When Ruby sees a line like</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require_relative</span> <span class="s1">'./my_lib'</span></span></code></pre></td></tr></table></div></figure>


<p>it looks for a file called <code>my_lib.so</code> (or <code>my_lib.bundle</code> on macOS),
asks the operating system to load that file as a shared library, and
then looks for a function with the name <code>Init_my_lib</code> inside the library
it just loaded.</p>

<p>When that function runs, it&rsquo;s a chance for the C extension to do
the same sorts of things that a normal Ruby file might have done if it
had been <code>require</code>&rsquo;d. In this example, it defines a method <code>foo</code> at the
top level, almost like the user had written normal Ruby code like this:</p>

<figure class='code'><figcaption><span>my_lib.rb</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="n">val</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s kind of wild! That means:</p>

<ul>
<li>C programs can load libraries dynamically at runtime, using arbitrary
user input.</li>
<li>C programs can then ask if there&rsquo;s a function defined in that library
with an arbitrary name, and get a function pointer to call it if there
is!</li>
</ul>


<p>I was pretty shocked to learn this, because my mental model of how
linking worked was that it split evenly into two parts:</p>

<ul>
<li><p>&ldquo;My application is statically linked, where all the code and libraries
my application depends on are compiled into my binary.&rdquo;</p></li>
<li><p>&ldquo;My application is dynamically linked, which means my binary
pre-declares some libraries that must be loaded before my program can
start running.&rdquo;</p></li>
</ul>


<p>There&rsquo;s actually a third option!</p>

<p>Then I looked into what code Ruby actually calls to do this. I found the
code in <code>dln.c</code>:</p>

<figure class='code'><figcaption><span>dln.c</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Load file */</span>
</span><span class='line'><span class="k">if</span> <span class="p">((</span><span class="n">handle</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">dlopen</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="o">|</span><span class="n">RTLD_GLOBAL</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">error</span> <span class="o">=</span> <span class="n">dln_strerror</span><span class="p">();</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1341">→ View on github.com</a></p>

<p>Ruby uses the <code>dlopen(3)</code> function in libc to request that an arbitrary
user library be loaded. From the man page:</p>

<blockquote><p>The function dlopen() loads the dynamic shared object (shared library)
file named by the null-terminated string filename and returns an
opaque &ldquo;handle&rdquo; for the loaded object.</p>

<p>&mdash; man dlopen</p></blockquote>

<p>The next thing Ruby does with this opaque <code>handle</code> is to find if the
thing it just loaded has an <code>Init_&lt;...&gt;</code> function inside it:</p>

<figure class='code'><figcaption><span>dln.c</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">init_fct</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())(</span><span class="n">VALUE</span><span class="p">)</span><span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">init_fct</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">errlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">error</span> <span class="o">=</span> <span class="n">dln_strerror</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">error</span> <span class="o">=</span> <span class="n">memcpy</span><span class="p">(</span><span class="n">ALLOCA_N</span><span class="p">(</span><span class="kt">char</span><span class="p">,</span> <span class="n">errlen</span><span class="p">),</span> <span class="n">error</span><span class="p">,</span> <span class="n">errlen</span><span class="p">);</span>
</span><span class='line'>    <span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span><span class='line'>    <span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1363-L1369">→ View on github.com</a></p>

<p>It uses <code>dlsym(3)</code> (again in libc) to look up a method with an arbitrary
name (<code>buf</code>) inside the library it just opened (<code>handle</code>). That function
must exist—if it doesn&rsquo;t, it&rsquo;s not a valid Ruby C extension and Ruby
reports an error.</p>

<p>If <code>dlsym</code> found a function with the right name, it stores a function
pointer into <code>init_fct</code>, which Ruby immediately dereferences and calls:</p>

<figure class='code'><figcaption><span>dln.c</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* Call the init code */</span>
</span><span class='line'><span class="p">(</span><span class="o">*</span><span class="n">init_fct</span><span class="p">)();</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1370-L1371">→ View on github.com</a></p>

<p>It&rsquo;s still kind of mind bending to think that C provides this level of
&ldquo;dynamism.&rdquo; I had always thought that being a compiled language meant
that the set of functions a C program could call was fixed at compile
time, but that&rsquo;s not true at all!</p>

<p>This search led me down a rabbit hole of learning more about linkers,
and now I think they&rsquo;re super cool—and far less cryptic! I <strong>highly</strong>
recommend <em>Chapter 7: Linking</em> from <a href="http://www.csapp.cs.cmu.edu/">Computer Systems: A Programmer&rsquo;s
Perspective</a> if this was interesting to you.</p>
]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Search Down the Stack]]></title>
    <link href="https://blog.jez.io/search-down-the-stack/"/>
    <updated>2020-06-06T19:08:20-05:00</updated>
    <id>https://blog.jez.io/search-down-the-stack</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve found it useful to search though the source code of things lower in
the stack lately. For example I saw an error something like this at work
recently:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ rake test
</span><span class='line'>symbol lookup error: /home/jez/.../foo.so: undefined symbol bar</span></code></pre></td></tr></table></div></figure>


<p>I was pretty confused. Modulo the names of commands and files, this was
pretty much all the output.</p>

<p>So I started searching. First I searched through my codebase for
<code>"symbol lookup error"</code>, but found nothing. Surely that string exists
somewhere. That must mean it&rsquo;s coming from lower in the stack?</p>

<p>The next level lower would mean third party Ruby gems. At work we use
Bundler <a href="https://bundler.io/v2.0/guides/deploying.html#manual-deployment">in a mode</a> where it installs all gems into a single
convenient folder in the current directory: <code>./vendor/bundle/</code>. But a
search in that folder turned up nothing again. So&hellip; further down?</p>

<p>If it&rsquo;s not from the app, and not from the gems, then maybe it&rsquo;s in Ruby
itself? I cloned the <a href="https://github.com/ruby/ruby">Ruby source</a>, checked out the <a href="https://github.com/ruby/ruby/tree/v2_6_5">version tag</a> for
the Ruby version we&rsquo;re running, and searched for <code>"symbol lookup error"</code>
once again. And again nothing!</p>

<p>There&rsquo;s still plenty of layers below us, so let&rsquo;s keep peeling them
back. Ruby is written in C, which means we should check libc next (the C
standard library). There are multiple libc implementations, but I was
running this on Linux, so let&rsquo;s check GNU libc (glibc). glibc is <a href="https://www.gnu.org/software/libc/sources.html">isn&rsquo;t
on GitHub</a>, but that&rsquo;s not a huge deterrant. Here&rsquo;s the search:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ rg -t c 'symbol lookup error'
</span><span class='line'>dl-lookup.c
</span><span class='line'>876:      _dl_signal_cexception (0, &exception, N_("symbol lookup error"));</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s a bit of a smoking gun! After all those layers, we found our
error message in libc itself. (This gave me a lot of leads on the problem
at hand, e.g., I had definitely ruled out a problem in my app or its
dependencies, and I was thinking, &ldquo;probably something is wrong about
how <code>foo.so</code> was compiled.&rdquo; There&rsquo;s a fun story here about how Ruby C
extensions work, but that&rsquo;s a <a href="https://blog.jez.io/linkers-ruby-c-exts/">tangent for another time</a>.)</p>

<p>My point is that <a href="https://livegrep.com/search/linux">searching all the code</a> is a super power, and it
applies to more than just searching the code we&rsquo;ve written. What a
blessing that the tools we&rsquo;re building on, like Ruby and GNU libc, are
all open source!</p>

<p>The next time it looks like a problem is outside the scope of your app&rsquo;s
code, maybe try searching the code:</p>

<ul>
<li>inside your gems or packages!</li>
<li>inside your language&rsquo;s standard library!

<ul>
<li>Some IDEs will even let you jump-to-def into core libraries 😮</li>
</ul>
</li>
<li>inside your language&rsquo;s runtime

<ul>
<li>(if you&rsquo;re using a language with a runtime like Ruby or Python or
even <a href="https://github.com/v8/v8">JavaScript</a>)</li>
</ul>
</li>
<li>powering your operating system kernel! <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
</ul>


<p>For me, I&rsquo;ve already noticed it help save me time and give me more
context when I&rsquo;m debugging.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>This might sound daunting, but sometimes it can be useful. A good thing to keep in mind: every <strong>system call</strong> like <code>open(2)</code> or <code>write(2)</code> or <code>select(2)</code> (and every other function from section 2 of the man pages) is really just a way for your program to request that the operating system do something; knowing that can be a decent place to start traipsing through code in the operating system.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Sorbet Does Not Have FixMe Comments]]></title>
    <link href="https://blog.jez.io/sorbet-fixme-comment/"/>
    <updated>2020-02-11T23:18:40-08:00</updated>
    <id>https://blog.jez.io/sorbet-fixme-comment</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Sorbet has no way to ignore an error on a specific line with a magic
comment. This is different from all other gradual static type checkers I
know about:</p>

<ul>
<li>TypeScript: <code>// @ts-ignore</code></li>
<li>Flow: <code>// $FlowFixMe</code></li>
<li>Hack: <code>// HH_FIXME</code></li>
<li>MyPy: <code># type: ignore</code></li>
</ul>


<p>When I first joined the team, I was skeptical. But having seen it play
out in practice, it&rsquo;s actually worked great.</p>

<p>Instead of ignore comments, Sorbet has <code>T.unsafe</code>, which accepts
anything and returns it unchanged (so for example <code>T.unsafe(3)</code>
evaluates to <code>3</code>). The trick is that it forces Sorbet to forget the
type of the input statically. This confers the power to silence most
errors. For example:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">1</span> <span class="o">+</span> <span class="s1">'1'</span>            <span class="c1"># error: Expected `Integer` but found `String`</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">unsafe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'1'</span>  <span class="c1"># no error</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%20%20%20%20%20%20%20%20%201%20%20%2B%20'1'%20%20%23%20error%3A%20Expected%20%60Integer%60%20but%20found%20%60String%60%0AT.unsafe(1)%20%2B%20'1'%20%20%23%20no%20error">→ View on sorbet.run</a></p>

<p>In this example, Sorbet knows that calling <code>+</code> on an Integer with a
String would raise an exception at runtime, and so it reports a static
type error. But wrapping the <code>1</code> in a call to <code>T.unsafe</code> causes Sorbet
to think that the expression <code>T.unsafe(1)</code> has type <code>T.untyped</code>. Then,
like for all untyped code, Sorbet admits the addition.</p>

<p>All Sorbet-typed Ruby programs must grapple with <code>T.untyped</code>. Every
Sorbet user has to learn how it works and what the tradeoffs of using it
are. In particular, that <code>T.untyped</code> is viral. Given a variable that&rsquo;s
<code>T.untyped</code>, all method calls on that variable will also be untyped:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># typed: true</span>
</span><span class='line'><span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">T</span><span class="p">.</span><span class="nf">untyped</span><span class="p">).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">even?</span>
</span><span class='line'><span class="c1"># ^ type: T.untyped</span>
</span><span class='line'>  <span class="n">z</span> <span class="o">=</span> <span class="o">!</span><span class="n">y</span>
</span><span class='line'><span class="c1"># ^ type: T.untyped</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.untyped).void%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20x.even%3F%0A%23%20%5E%20type%3A%20T.untyped%0A%20%20z%20%3D%20!y%0A%23%20%5E%20type%3A%20T.untyped%0Aend">→ View on sorbet.run</a></p>

<p>In this example <code>x</code> enters the method as <code>T.untyped</code>, so calling the
method <code>.even?</code> propagates the <code>T.untyped</code> to <code>y</code>. Then again because
<code>y</code> is untyped, calling<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <code>!</code> on it propgates the <code>T.untyped</code> to
<code>z</code>. There are plenty of reasons to <a href="https://sorbet.org/docs/gradual">both embrace and avoid</a>
<code>T.untyped</code> in a type system but the point is: Sorbet&rsquo;s type system
already has it.</p>

<p>Re-using <code>T.untyped</code> as the way to silence errors plays nicely with
everything else in Sorbet:</p>

<ul>
<li><p>Hover and jump to definition become tools to track down the source of
silenced errors.</p></li>
<li><p>Errors are effectively silenced at the source of the error. There are
no errors downstream that only show up because an error was silenced
earlier.</p></li>
<li><p>We plan to eventually build a tool to show which parts of a file are
untyped (to see things like which methods don&rsquo;t have signatures). That
tool will trivially take suppressed errors into account.</p></li>
</ul>


<p>The <a href="https://sorbet.org/docs/gradual">Sorbet docs</a> bill <code>T.untyped</code> as the way to &ldquo;turn off the
type system.&rdquo; By reusing <code>T.untyped</code> to supress errors, silencing one
error means silencing them all, which is a win for simplicity.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Did you know that <code>!x</code> in Ruby is syntactic sugar for <code>x.!()</code>, which means that you can override <code>!</code> to make it do something else?<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Intersection Types in Sorbet are Surprisingly Common]]></title>
    <link href="https://blog.jez.io/intersection-types-common/"/>
    <updated>2020-01-04T19:50:32-06:00</updated>
    <id>https://blog.jez.io/intersection-types-common</id>
    <content type="html"><![CDATA[<p>Conventional knowledge is that union types are common and intersection
types are rare. But actually that&rsquo;s not the case—intersection types
show up in nearly every program Sorbet type checks thanks to control
flow.</p>

<p><a href="https://sorbet.org/docs/union-types">Union types</a> in Sorbet are incredibly common, which should be no
surprise. In Sorbet, <code>T.nilable(...)</code> is sugar for <code>T.any(NilClass,
...)</code>. <code>T.nilable</code> shows up all over the place and probably catches more
bugs than any other feature in Sorbet.</p>

<p>Sorbet also has <a href="https://sorbet.org/docs/intersection-types">intersection types</a>. While union types mean &ldquo;either
this or that,&rdquo; intersection types mean &ldquo;both this and that.&rdquo; On first
glance, intersection types seem like some super niche feature which only
benefits a handful of programs. In Stripe&rsquo;s Ruby monorepo, the strings
<code>T.any</code> and <code>T.nilable</code> occur nearly 300 times more than <code>T.all</code> does.</p>

<p>But those numbers hide something critical: intersection types power
Sorbet&rsquo;s <a href="https://sorbet.org/docs/flow-sensitive">control flow-sensitive typing</a>. They&rsquo;re actually present in
every Ruby program, but just a little hard to spot. Let&rsquo;s look at how
pervasive they are with a few examples:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># typed: strict</span>
</span><span class='line'><span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Parent</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Child</span> <span class="o">&lt;</span> <span class="no">Parent</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">Parent</span><span class="p">).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">Child</span>
</span><span class='line'>    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># Revealed type: `Child`</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>Here <code>x</code> starts out having type <code>Parent</code>, but inside the <code>case</code>
statement Sorbet treats <code>x</code> as having the more specific type <code>Child</code>.
There&rsquo;s no <code>T.all</code> in sight, but that&rsquo;s because it&rsquo;s hiding. Sorbet
doesn&rsquo;t just throw away the fact that it knew <code>x &lt;: Parent</code>. Instead, it
uses <code>T.all</code> to update its type for <code>x</code> to <code>T.all(Parent, Child)</code>.</p>

<p><code>T.all(Parent, Child)</code> is equivalent to <code>Child</code> because <code>Child</code> is a
subtype of <code>Parent</code>. If types represent sets of values, then the set of
values represented by <code>Child</code> is a subset of the set of values
represented by <code>Parent</code>, so the intersection of those two sets would
just leave <code>Child</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Sorbet attempts to simplify a large type to a smaller, equivalent type
when it can for two reasons:</p>

<ul>
<li><p><strong>Usability</strong> – Most users don&rsquo;t know that <code>T.all</code> means &ldquo;intersection
type&rdquo; or even what intersection types are. (And even those who do
still end up drawing Venn diagrams from time to time!) It only gets
more complicated when <code>T.all</code>s and <code>T.any</code>s nest inside each other.</p>

<p>Meanwhile, <code>Child</code> is a super easy type to understand, and leads to
nice, short error messages.</p></li>
<li><p><strong>Performance</strong> – Checking whether one type is a subtype of another is
a super common operation, so it has to be fast. By collapsing
<code>T.all(Parent, Child)</code> to <code>Child</code>, Sorbet does at least half as much
work when checking subtyping (probably more, because of some common
path optimizations).</p>

<p>When this simplification happens, Sorbet even skips an allocation
entirely. Cnstructing <code>T.all(Parent, Child)</code> in Sorbet short
circuits and returns a reference to the already allocated <code>Child</code> type
that was passed as an argument (with ownership tracked via
<code>std::shared_ptr</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>).</p></li>
</ul>


<p>Let&rsquo;s look at another example of control flow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># typed: strict</span>
</span><span class='line'><span class="kp">extend</span> <span class="no">T</span><span class="o">::</span><span class="no">Sig</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">A</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">class</span> <span class="nc">B</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">a_or_b: </span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="p">)).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example2</span><span class="p">(</span><span class="n">a_or_b</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">a_or_b</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">A</span>
</span><span class='line'>    <span class="no">T</span><span class="p">.</span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">a_or_b</span><span class="p">)</span> <span class="c1"># Revealed type: `A`</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend">→ View on sorbet.run</a></p>

<p>This example method accepts either <code>A</code> or <code>B</code> (<code>T.any(A, B)</code>) and then
branches on whether <code>a_or_b</code> is an instance of <code>A</code>. Again: Sorbet
doesn&rsquo;t throw away that it knows <code>a_or_b &lt;: T.any(A, B)</code>. Instead it
updates its knowledge of the type of <code>a_or_b</code> using <code>T.all</code> to get
<code>T.all(T.any(A, B), A)</code>. Realizing that this is equivalent to <code>A</code> is a
bit trickier:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">B</span><span class="p">),</span> <span class="no">A</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Distribute</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">A</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">B</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># T.all(A, A) is just A (idempotence)</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">A</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">B</span><span class="p">,</span> <span class="no">A</span><span class="p">)</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># A and B are classes (not mixins) and neither inherits the other.</span>
</span><span class='line'><span class="c1"># It's impossible to have a value of that type, so it's bottom:</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">any</span><span class="p">(</span> <span class="no">A</span> <span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">noreturn</span> <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># bottom is the identity of union</span>
</span><span class='line'><span class="no">A</span></span></code></pre></td></tr></table></div></figure>


<p>You can start to see how usability and performance and might get a
little out of hand if Sorbet didn&rsquo;t keep attempting to simplify things!
The cumulative effect of all the control flow in a program would result
in huge, unweidly types.</p>

<p>Until now you could claim that I&rsquo;ve been hyping up intersection types as
the solution to problems that were self-imposed. That if we just
invented some other method for modeling control flow, it would have been
naturally usable or naturally performant, and we wouldn&rsquo;t have had
problems in the first place. So next let&rsquo;s look at some examples to see
why intersection types really are the most natural solution:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">I1</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo1</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="k">module</span> <span class="nn">I2</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo2</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">sig</span> <span class="p">{</span><span class="n">params</span><span class="p">(</span><span class="ss">x: </span><span class="no">I1</span><span class="p">).</span><span class="nf">void</span><span class="p">}</span>
</span><span class='line'><span class="k">def</span> <span class="nf">example3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  <span class="n">x</span><span class="p">.</span><span class="nf">foo1</span>  <span class="c1"># Works outside</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">I2</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="nf">foo1</span>  <span class="c1"># Should (and does) still work inside</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="nf">foo2</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A">→ View on sorbet.run</a></p>

<p>Unlike in the other examples, this is the first example where had we
tried to implement control-flow-sensitive typing by throwing away the
old type and using the new type instead it wouldn&rsquo;t have worked. The key
thing to notice: this example uses modules. Outside the <code>case</code> of course
calling <code>x.method_from_1</code> works because <code>x</code> starts out at type <code>I1</code>. But
if we treated <code>x</code> as only <code>I2</code> inside the <code>when I2</code>, we&rsquo;d start
reporting an error for calling <code>x.method_from_1</code> because it doesn&rsquo;t
exist on <code>I2</code>.</p>

<p>Unlike intersecting unrelated classes (our <code>T.all(B, A)</code> example from
earlier), intersecting unrelated modules does&rsquo;t collapse to
<code>T.noreturn</code>. There&rsquo;s nothing stopping some class from including both
<code>I1</code> and <code>I2</code>. Instances of that class would be values of type
<code>T.any(I1, I2)</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">SomeClass</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">I1</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">I2</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># This type assertion is okay:</span>
</span><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">let</span><span class="p">(</span><span class="no">SomeClass</span><span class="p">.</span><span class="nf">new</span><span class="p">,</span> <span class="no">T</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="no">I1</span><span class="p">,</span> <span class="no">I2</span><span class="p">))</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))">→ View on sorbet.run</a></p>

<p>So at least for implementing certain cases of flow sensitive typing,
we&rsquo;ll <em>need</em> intersection types anyways. Then for these certain cases
we&rsquo;d incur the usability and performance problems we discovered earlier
and have to solve them.</p>

<p>But more than that, intersection types are fundamentally easier to work
with compared to some ad hoc approach to flow sensitive typing. Type
system bugs are weird. It&rsquo;s frquently harder to figure out whether the
current behavior is buggy in the first place than it is to find the
cause!</p>

<p>In that light, intersection types present an elegant, robust model for
arriving at what the correct behavior <em>should</em> be, independent of what
Sorbet&rsquo;s existing behavior is. It&rsquo;s clear how intersection types
interact with union types, and with subtyping, and with generics, and
with variance, etc.</p>

<p>By repurposing intersection types to model control flow sensitivity,
when things go wrong there&rsquo;s a framework for discovering what&rsquo;s right.</p>

<p>(Speaking of repurposing, intersection types also play an important role
in how Sorbet <a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend">suggests potential method signatures</a>! That&rsquo;s three birds
with one stone.)</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you&rsquo;re not convinced, consider: with <code>T.all(Parent, Child)</code> we should be able to call all the methods on <code>Parent</code> and all the methods on <code>Child</code>. But <code>Child</code> inherits <code>Parent</code>&rsquo;s methods, so any method <code>Parent</code> has will already be on <code>Child</code>. So <code>Child</code> is equivalently good as <code>T.all(Parent, Child)</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If you&rsquo;re looking for a good intro to modern C++ things like <code>shared_ptr</code>, I can&rsquo;t recommend <a href="https://berthub.eu/articles/posts/cpp-intro/">this blog post series</a> enough.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[What makes type checking Ruby hard?]]></title>
    <link href="https://blog.jez.io/ruby-mutation/"/>
    <updated>2019-12-29T01:29:52-06:00</updated>
    <id>https://blog.jez.io/ruby-mutation</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Mutation makes typechecking Ruby harder than many other programming
languages. Most people will immediately think I mean mutation in the
sense of <code>x += 1</code> or something—that&rsquo;s not what I&rsquo;m referring to. In
fact, that&rsquo;s the easy kind of mutation to model in a type system.</p>

<p>What I mean is that nearly everything worth knowing statically about a
Ruby program involves mutation. Defining a class?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>That mutates the global namespace of constants. After those lines run,
all code in the project can reference the class <code>A</code>.</p>

<p>Defining a method?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s1">'hello'</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>The method <code>foo</code> is undefined just before the <code>def</code> block (at runtime!),
but defined after—mutation again.</p>

<p>Ruby provides things like <code>attr_reader</code> and <code>attr_accessor</code> to define
getter and setter methods:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">B</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:foo</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><code>attr_reader</code> is not a Ruby keyword, contrary to popular belief: it&rsquo;s a
method on the singleton class which takes an argument. It defines an
instance method called <code>foo</code> as a side effect by mutating the class <code>B</code>.</p>

<p>It&rsquo;s the same for mixing modules into classes:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">M</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">M</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p><code>include</code> is another method disguised like a keyword which mutates the
class&rsquo;s list of ancestors.</p>

<p>One of my least favorite Ruby features: you can <strong>redefine</strong> (not
override) a method:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">D</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:foo</span>
</span><span class='line'>  <span class="kp">alias_method</span> <span class="ss">:old_foo</span><span class="p">,</span> <span class="ss">:foo</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s1">'Calling D#foo'</span>
</span><span class='line'>    <span class="n">old_foo</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>Because <code>D#foo</code> is defined by the <code>attr_reader</code> line, the subsequent
<code>def</code> overwrites it (akin to mutating a local variable, like <code>x += 1</code>).
Oh and that <code>alias_method</code>? Another method looking like a keyword which
mutates the class.</p>

<p>Even the way libraries work in Ruby is powered by mutation:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">'some_gem'</span></span></code></pre></td></tr></table></div></figure>


<p><code>require</code> is a method (again, not a keyword) that looks up and runs
arbitrary Ruby code, whose result we discard. It&rsquo;s only convention that
the primary side effect of the <code>require</code>&rsquo;d code is to mutate the global
namespace, defining more classes and methods.</p>

<h2>DSLs and metaprogramming</h2>

<p>It would be one thing if Ruby constrained the places where this mutation
could occur. But instead, it provides first-class support for these
features anywhere Ruby code runs. Everything we&rsquo;ve seen so far can be
hidden behind arbitrary computation at runtime:</p>

<ul>
<li>With <code>Module#const_set</code>, a Ruby program can compute an arbitrary name
and use it to create new constant at runtime.</li>
<li><code>Module#define_method</code> does the same for methods.</li>
<li>Again <code>require</code> is a method, so it can occur wherever other methods
are called.</li>
</ul>


<p>It&rsquo;s not uncommon to see Ruby libraries embrace this rather than avoid
it (Rails definitely does). Ruby programs frequently build up large
abstractions and do tons of computation which at the end of the day
result in a <code>define_method</code> or a <code>const_set</code>.</p>

<p>Rubyists call this &ldquo;metaprogramming&rdquo; or &ldquo;building DSLs&rdquo; but I call it
like I see it: mutation.</p>

<h2>Modeling mutation</h2>

<p>Type systems are notoriously bad at modelling this kind of mutation.
Look at other typed, object-oriented languages: Java, Scala, C++, &hellip;
Each of these languages <strong>forbids</strong> this kind of mutation. (Whether
because it&rsquo;s hard to implement support for it or because they&rsquo;re making
a value judgement is beyond me.)</p>

<p>So how can Sorbet can model this? Mostly, it just cheats. Err,
&ldquo;approximates.&rdquo; From my experience working on the Sorbet team, I can
think of three main ways it cheats.</p>

<p>First, Sorbet assumes that if a class or method might exist, it does
exist, and universally throughout a project.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It pretends
that all <code>include</code>, <code>extend</code>, and <code>alias_method</code> statements in a class
run first, before all other code at the top-level of that class. It
restricts method redefinitions—the old and new methods must take the
same number and kinds of arguments. And it restricts <code>alias_method</code>: you
can only alias to a method on your class, not to a parent class. Sorbet
makes no attempt to model <code>undef_method</code> at all (another
method-not-keyword!).</p>

<p>Second, Sorbet cheats by implementing heuristics for the most common
DSLs. To support <code>attr_reader</code>, Sorbet says, &ldquo;Hey, this method call
happens to be to some method named <code>attr_reader</code>. I&rsquo;m not sure if it&rsquo;s
to <code>Module#attr_reader</code> or to some other <code>attr_reader</code> definition or to
any definition at all, but it&rsquo;s provided with a single Symbol argument,
the result is discarded, and it&rsquo;s called at the syntactic top-level of a
class, so I bet that it is a call to <code>Module#attr_reader</code>.&rdquo; It&rsquo;s similar
for many other popular DSLs: it makes decent educated guesses.</p>

<p>But after all that, it sort of gives up. Sorbet makes no attempts to
work backwards from a call to <code>define_method</code> or <code>const_set</code> inside a
method body to learn that a class or method might have been defined
somewhere. Instead, it cheats one last time and uses runtime information.</p>

<p>As a part of initializing a Sorbet project, Sorbet <code>require</code>s (read:
executes) as much code in a project as it can: all the gems listed in
the Gemfile and all the Ruby files in the current folder. Afterwards, it
can see the result of all that&rsquo;s been mutated thus far (via reflection)
and serialize what it sees into <a href="https://sorbet.org/docs/rbi">RBI files</a> to convey what it saw to the
static checker. This is still imperfect (it completely misses things
that are defined after <code>require</code> time), but empirically it finds most of
the remaining undiscovered definitions.</p>

<h2>Beyond mutation</h2>

<p>Don&rsquo;t get me wrong, those approximations are really useful and
effective. But really, the way Sorbet handles mutation in a codebase is
by incentivicing people to get rid of it.</p>

<ul>
<li><p>Sorbet can type check a project in seconds, but it takes minutes to
re-generate all RBIs files. When Sorbet can see things statically,
there&rsquo;s also a canonical place to write a type annotation for it.</p></li>
<li><p>It&rsquo;s a much better experience to click &ldquo;Go to Definition&rdquo; and jump to
the actual source definition rather than to an auto-generated RBI
file.</p></li>
<li><p>And arguably, if it&rsquo;s easy for Sorbet to understand what&rsquo;s defined and
where, it&rsquo;s easier for a programmer to understand. Understandable code
lets people iterate faster, is less brittle, and harder to break by
accident.</p></li>
</ul>


<p>Programming languages are tools to change and structure the way we
think. In the long run, all code can be changed. We adopt type systems
specifically to help guide these changes, which <a href="https://blog.jez.io/on-language-choice/">I&rsquo;ve touched on
before</a>. When it comes to mutation in Ruby, Sorbet makes a solid effort
to model the helpful parts, while providing guide rails and suggestions
to deal with the rest.</p>

<hr />

<h2>Appendix A: By comparison with typed JavaScript</h2>

<p>You might say, &ldquo;the things that you&rsquo;re talking about aren&rsquo;t unique to
Ruby! It&rsquo;s the same for all dynamic programming languages!&rdquo; But is that
true in practice?</p>

<p>Let&rsquo;s compare our Ruby snippets from before with JavaScript.</p>

<p>Ruby:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">my_dsl</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
</span><span class='line'>    <span class="n">define_method</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="k">do</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>JavaScript:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">static</span> <span class="nx">myDsl</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>First I&rsquo;ll point out: the mutation becomes way more obvious in the
JavaScript program! But second: both TypeScript and Flow report static
errors on this program. They both complain that there&rsquo;s no type
annotation declaring that it&rsquo;s ok to treat <code>this.prototype</code> as if it
were a key-value mapping.</p>

<p>The fact that both Flow and TypeScript report an error here speak to how
common this idiom is in practice. It&rsquo;s not common, and they&rsquo;d rather not
encourage programs like this, so they forbid it.</p>

<p>Here&rsquo;s another example, first in Ruby:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">'some_gem'</span>
</span><span class='line'>
</span><span class='line'><span class="no">SomeNamespace</span><span class="o">::</span><span class="no">SomeClass</span><span class="p">.</span><span class="nf">new</span></span></code></pre></td></tr></table></div></figure>


<p>And then in JavaScript:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="nx">someNamespace</span> <span class="nx">from</span> <span class="s1">'some_package'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">new</span> <span class="nx">someNamespace</span><span class="p">.</span><span class="nx">SomeClass</span><span class="p">();</span></span></code></pre></td></tr></table></div></figure>


<p>With no RBI files declaring whether <code>SomeNamespace::SomeClass</code> exists
or not, Sorbet will report an error that the class doesn&rsquo;t exist. But in
TypeScript and Flow, the code is just fine, even if there&rsquo;s no type
declaration file. Both can still see that whatever vale is imported will
be bound to the <code>someNamespace</code> variable (even if it&rsquo;s treated as
<code>any</code>).</p>

<p>Sorbet is thus forced to come up with ways to generate RBI files for all
new projects, because without them Sorbet would be crippled: it would
have no way to distinguish between a class name that has actually been
typoed vs one that is typed correctly but for which there&rsquo;s no visible
definition. Meanwhile, TypeScript and Flow work completely fine in new
codebases out of the box.</p>

<p>So my claim is that: no, these problems <strong>are</strong> unique to Ruby, because
the design of the language and the culture of its use so pervasively
promote or require mutation.</p>

<h2>Appendix B: More things that are actually mutation</h2>

<ul>
<li><p><code>freeze</code> (ironic: to prevent mutation on a class or object&hellip; we
mutate it!)</p></li>
<li><p><code>private</code> / <code>private_class_method</code> (not keywords! These are methods
that take a <strong>Symbol</strong>; it just so happens that <code>def foo; end</code> is an
expression that evaluates to the symbol <code>:foo</code>. Which is why there&rsquo;s
both <code>private</code> and <code>private_class_method</code>, because <code>def self.foo; end</code>
also evaluates to <code>:foo</code>, so <code>private def self.foo; end</code> would attempt
to mark an <strong>instance</strong> method named <code>:foo</code> private, even it didn&rsquo;t
exist!)</p></li>
</ul>


<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Frequently this assumption is backed up by an autoloader. For example, Rails includes an autoloader that loads constants lazily on demand, so that the programmer doesn&rsquo;t have to sprinkle require statements throughout the code. But how do autoloads work? Mutation again 🙂.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Surgery on Code from the Command Line]]></title>
    <link href="https://blog.jez.io/surgery-on-code/"/>
    <updated>2019-07-30T09:32:48-07:00</updated>
    <id>https://blog.jez.io/surgery-on-code</id>
    <content type="html"><![CDATA[<p>I&rsquo;m frequently faced wth problems like &ldquo;find and replace this pattern,
but only on specific lines,&rdquo; especially lines that have type errors on
them. I&rsquo;ve built three new CLI tools that fit the need to operate on a
specific set of lines in a codebase. In this post I&rsquo;ll walk through a
couple examples to show them in action.</p>

<!-- more -->


<p>For the impatient, the tools that I&rsquo;ve built are:</p>

<ul>
<li><p><a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a></p>

<p>Like <code>grep</code>, but search for a pattern only at the specified
locations, printing the locations where a match was found.</p></li>
<li><p><a href="https://github.com/jez/multi-sub"><code>multi-sub</code></a></p>

<p>Substitute a pattern with a replacement at the specified locations,
editing the file in place.</p></li>
<li><p><a href="https://github.com/jez/diff-locs"><code>diff-locs</code></a></p>

<p>Convert a unified diff (like the output of <code>git diff</code>) into a list
of locations affected by that diff.</p></li>
</ul>


<p>With the quick intros out of the way, let&rsquo;s dive into some examples.</p>

<h2><code>multi-grep</code></h2>

<p>Consider the file <code>locs.txt</code> below which is a list of <code>filename:line</code>
pairs:</p>

<figure class='code'><figcaption><span>locs.txt</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>file_a.txt:13
</span><span class='line'>file_a.txt:22
</span><span class='line'>file_a.txt:79
</span><span class='line'>file_b.txt:10
</span><span class='line'>file_b.txt:11</span></code></pre></td></tr></table></div></figure>


<p>(I call such <code>filename:line</code> pairs &ldquo;locations&rdquo; or &ldquo;locs.&rdquo;)</p>

<p>Also consider that our project is huge, and has many more files
than just <code>file_a.txt</code> and <code>file_b.txt</code>. To filter the <code>locs.txt</code> list
to only the lines that contain the pattern &ldquo;hello&rdquo;, we can use
<code>multi-grep</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ multi-grep <span class="s1">'hello'</span> locs.txt
</span><span class='line'>file_a.txt:13
</span><span class='line'>file_b.txt:10</span></code></pre></td></tr></table></div></figure>


<p>The output means that only line 13 in <code>file_a.txt</code> and line 10 in
<code>file_b.txt</code> contain <code>hello</code>, given our initial set of 5 locs. The
search completely ignored all other files in the project because they
weren&rsquo;t mentioned in <code>locs.txt</code>. Searching with <code>multi-grep</code> scales with
the size of the input list, not with the size of the codebase being
searched.</p>

<p>This was a contrived example, but let&rsquo;s keep plowing forward with the
basics so we can apply them to a real example.</p>

<h2><code>multi-sub</code></h2>

<p>If <code>multi-grep</code> is like <code>grep</code>, <code>multi-sub</code> is like <code>sed</code> but with only
the substitute command (<code>s/find/replace/</code>). Taking our previous example,
<code>multi-sub</code> finds and replaces a pattern on specific input lines:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ multi-sub <span class="s1">'hello'</span> <span class="s1">'goodbye'</span> locs.txt
</span><span class='line'><span class="c"># ... file_a.txt:13 edited: s/hello/goodbye/ ...</span>
</span><span class='line'><span class="c"># ... file_b.txt:10 edited: s/hello/goodbye/ ...</span></span></code></pre></td></tr></table></div></figure>


<p>In our previous example, only locations <code>file_a.txt:13</code> and
<code>file_b.txt:10</code> matched the pattern <code>hello</code>. So after running this
<code>multi-sub</code> command, those two files will be updated in place. On both
lines, <code>hello</code> will be replaced with <code>goodbye</code>.</p>

<h2>A larger example</h2>

<p>With the basics out of the way, let&rsquo;s tackle a real-world problem. I
work with the output of <a href="https://sorbet.org">Sorbet</a> a lot, so I&rsquo;ve used it for this next
example (Sorbet is a type checker for Ruby). When Sorbet detects type
errors in a program, it generates output like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>test/payment_methods/update.rb:648: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
</span><span class='line'>     648 |   assert_equal(nil, previous['billing_details']['address']['line1'])
</span><span class='line'>                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class='line'>
</span><span class='line'>test/payment_methods/update.rb:649: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
</span><span class='line'>     649 |   assert_equal(nil, previous['card']['checks']['address_line1_check'])
</span><span class='line'>                               ^^^^^^^^^^^^^^^^
</span><span class='line'>
</span><span class='line'>test/payment_methods/webhooks.rb:610: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
</span><span class='line'>     610 |   assert_equal(2, notification['card']['exp_month'])
</span><span class='line'>                             ^^^^^^^^^^^^^^^^^^^^
</span><span class='line'>
</span><span class='line'>... many more errors ...
</span><span class='line'>
</span><span class='line'>Errors: 253</span></code></pre></td></tr></table></div></figure>


<p>The error messages look a lot better with colors! If you don&rsquo;t believe
me, you can <a href="https://sorbet.run">try Sorbet in the browser</a> and see for
yourself.</p>

<p>The example above is inspired by real output that we saw at Stripe while
iterating on Sorbet. In this specific case, one of my coworkers had
improved Sorbet to track more information statically, which uncovered a
bunch of new type errors.</p>

<p>On the Sorbet team, we have a policy that before landing changes like
this, we modify Stripe&rsquo;s monorepo to preemptively silence the new
errors. Jordan Brown has a great article on the <a href="https://medium.com/flow-type/upgrading-flow-codebases-40ef8dd3ccd8">Flow blog</a> justifying
this technique, so I&rsquo;ll skip the why and focus only on how to carry out
codemods like this.</p>

<p>As seen above, Sorbet error output always looks like
<code>filename.rb:line:Error message</code>. With a little massaging, this will
feed directly into <code>multi-sub</code>. Also notice that on the lines with
errors, the file contents always looked something like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">foo</span><span class="p">[</span><span class="s1">'bar'</span><span class="p">]</span></span></code></pre></td></tr></table></div></figure>


<p>To tell Sorbet to silence the errors on these lines, we&rsquo;ll need to wrap
the variable in a call to <code>T.unsafe(...)</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">T</span><span class="p">.</span><span class="nf">unsafe</span><span class="p">(</span><span class="n">foo</span><span class="p">)[</span><span class="s1">'bar'</span><span class="p">]</span></span></code></pre></td></tr></table></div></figure>


<p>This instructs to Sorbet to <a href="https://sorbet.org/docs/troubleshooting#escape-hatches">forget all static type
information</a> about the variable, thus silencing the error.
The key is to only perform this edit on lines with errors&mdash;
we&rsquo;d hate to needlessly throw away type information by changing
unrelated lines! For things like this, <code>grep</code> and <code>sed</code> are often too
coarse-grained, because accessing a hash like this in Ruby is abundantly
common.</p>

<p>With <code>multi-sub</code>, we can write a really simple regex targetting these
hash lookups, but scope the regex to only lines in the error output:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># (1) Type check the project</span>
</span><span class='line'>❯ srb tc 2&gt;&amp;1 | <span class="se">\</span>
</span><span class='line'>  <span class="c"># (2) Filter the error output to only have the top-level error lines</span>
</span><span class='line'>  sed -e <span class="s1">'/^ /d; /^$/d; /^Errors:/d'</span> | <span class="se">\</span>
</span><span class='line'>  <span class="c"># (3) Chop off the error message, keeping only the filename:line</span>
</span><span class='line'>  cut -d : -f 1-2 | <span class="se">\</span>
</span><span class='line'>  <span class="c"># (4) Use multi-sub to replace things like foo[ with T.unsafe(foo)[</span>
</span><span class='line'>  multi-sub <span class="s1">'\([a-zA-Z0-9_]+\)\['</span> <span class="s1">'T.unsafe(\1)['</span></span></code></pre></td></tr></table></div></figure>


<p>Take a look through the four steps in the bash oneliner above:</p>

<ol>
<li>Type check the project, then</li>
<li>filter out every line that doesn&rsquo;t have a location, then</li>
<li>chop of the error messages, and finally</li>
<li>use <code>multi-sub</code> to perform the substitution.</li>
</ol>


<p>The net result is to update the files in place, performing the
substitution only on the lines with errors. Altogether once more, but on
one line, making use of a shell alias that I have to abbreviate the
inner two steps:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ srb tc 2&gt;&amp;1 | onlylocs | multi-sub <span class="s1">'\([a-zA-Z0-9_]+\)\['</span> <span class="s1">'T.unsafe(\1)['</span></span></code></pre></td></tr></table></div></figure>


<p>So with a super short bash oneliner, we&rsquo;ve done a mass codemod that
fixes hundreds of errors at once, without having to silence more than
necessary.</p>

<p>If <code>grep</code> and <code>sed</code> are like chainsaws, I like to think of <code>multi-grep</code>
and <code>multi-sub</code> like scalpels&mdash;ideal for performing surgery on a
codebase. Regular expressions are often super imprecise tools for
codemods. But by scoping down the regex to run only on specific lines,
it doesn&rsquo;t matter. The added precision from explicit locations makes up
for how blunt regular expressions are.</p>

<h2><code>diff-locs</code></h2>

<p>I&rsquo;ve built one more command in the same spirit as <code>multi-grep</code> and
<code>multi-sub</code>, except that instead of consuming locations, it emits them.
Specifically, given a diff it outputs one <code>filename:line</code> pair for every
line that was affected by the diff.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It&rsquo;s ideal for consuming the
output of <code>git show</code> or <code>git diff</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ git show HEAD | diff-locs
</span><span class='line'>test/payment_methods/update.rb:648
</span><span class='line'>test/payment_methods/update.rb:649
</span><span class='line'>test/payment_methods/webhooks.rb:610</span></code></pre></td></tr></table></div></figure>


<p>I frequently use <code>diff-locs</code> to tweak codemods that I&rsquo;ve already
committed. For example, we could go back and add a TODO comment above
each new <code>T.unsafe</code> call:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># (1) Generate a diff from git</span>
</span><span class='line'>❯ git show HEAD | <span class="se">\</span>
</span><span class='line'>  <span class="c"># (2) Convert the diff to a list of locations</span>
</span><span class='line'>  diff-locs | <span class="se">\</span>
</span><span class='line'>  <span class="c"># (3) Use multi-sub to insert a comment before each line</span>
</span><span class='line'>  multi-sub <span class="s1">'^\( *\)'</span> <span class="s1">$'</span><span class="se">\\</span><span class="s1">1# TODO: Unsilence this error</span><span class="se">\n\\</span><span class="s1">1'</span></span></code></pre></td></tr></table></div></figure>


<p>Recapping the pipeline above:</p>

<ol>
<li>Use <code>git show</code> to generate a diff, then</li>
<li>convert the diff to a list of locations with <code>diff-locs</code>, and finally</li>
<li>insert a comment before each location with <code>multi-sub</code>.</li>
</ol>


<p><code>diff-locs</code> is particularly handy because after the first codemod, there
won&rsquo;t be type errors anymore! So to get a list of locations to perform
the edit on, we&rsquo;d have had to check out the commit before fixing the
errors, save the list of errors to a file, go back, and finally do the
edit we wanted to in the first place.</p>

<p>Instead, we can take advantage of the fact that all that information is
already stored in git history, skipping a bunch of steps. (And asking
git to show a diff is way faster than asking Sorbet to re-typecheck a
whole project 😅)</p>

<h2>Aside: The implementations</h2>

<p>One thing I&rsquo;d like to point out is that I took some care to make sure
these commands weren&rsquo;t eggregiously slow. I prototyped these commands
with some hacky scripts, but after doing some rather large codemods I
got annoyed with them taking minutes to finish.</p>

<p>Some things that make these new commands fast:</p>

<ul>
<li><code>multi-grep</code> and <code>multi-sed</code> re-use an already opened file to avoid
reading extra information.</li>
<li><code>multi-grep</code> is written in Standard ML, <code>multi-sub</code> is written in
OCaml, and <code>diff-locs</code> is written in Haskell&mdash;all languages which
have great optimizing compilers. This means much better performance
than a scripting language.</li>
</ul>


<p>If you&rsquo;re curious, you can read through their implementations on GitHub:</p>

<ul>
<li><a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a></li>
<li><a href="https://github.com/jez/multi-sub"><code>multi-sub</code></a></li>
<li><a href="https://github.com/jez/diff-locs"><code>diff-locs</code></a></li>
</ul>


<p>As always if you have questions or notice issues please don&rsquo;t hesitate
to reach out!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>It defaults to only lines affected after the diff applies, but there&rsquo;s an option to make it show both added and removed lines.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[On Programming Language Choice]]></title>
    <link href="https://blog.jez.io/on-language-choice/"/>
    <updated>2019-06-21T09:30:25-07:00</updated>
    <id>https://blog.jez.io/on-language-choice</id>
    <content type="html"><![CDATA[<p>My opinion on programming language choice has changed over the years,
from &ldquo;Java is the only language I know&rdquo; to &ldquo;Standard ML is clearly the
right answer&rdquo; to something a little more nuanced now. Still, since this
post is largely my <strong>opinion</strong>, I withold the right to make claims
without evidence and say things you&rsquo;ll disagree with. But enough
qualifiers—let&rsquo;s get into it.</p>

<!-- more -->


<p>Earlier in my career, I thought that the answer to &ldquo;which language
should I use&rdquo; ought to be constant. That there should be One Best
Language. And while I still think it makes sense to compare languages on
the relative merits of their designs, answering the question &ldquo;which
language is <strong>best</strong> designed&rdquo; is a completely different question. The
question I&rsquo;ll answer in this post is: &ldquo;Which language should I choose to
start this new project?&rdquo;<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Answering &ldquo;which language is best designed&rdquo; is better left to
programming language theorists. To claim that I (or most people reading
this) have any authority to answer this question is absurd. Language
design is a well-studied, complex problem, with a wealth of
peer-reviewed, prior work. One semester studying programming language
theory in college is not sufficient qualification to answer this
question.</p>

<p>As it turns out, most people trying to answer the former question of
&ldquo;which language is best designed&rdquo; knowingly or unknowingly end up
answering the latter question: &ldquo;which language should I choose to start
this new project?&rdquo; Luckily, this is a much easier question to answer,
because we can narrow the choice space by asking questions like these:</p>

<ul>
<li>What languages does the initial team know?</li>
<li>What languages will future collaborators know?</li>
<li>What languages have strong package ecosystems? (Especially for our
domain?)</li>
<li>What performance properties must our solution have?</li>
</ul>


<p>But there&rsquo;s one big question missing, and it 100% overshadows all other
questions. Absolutely the most regret from choosing a programming
language has come from forgetting to ask this question:</p>

<p><strong>In this language, how easy is it to delete code?</strong></p>

<p>Code is a liability. More code means more to understand and more systems
to maintain. More moving parts means more points of failure. More
failures mean more people trying to fix old code with new code. Company
pressures to ship more features mean new code accumulating on top of old
code.</p>

<p>This is a nightmare.</p>

<p>Code is a liability, so regardless of language it must be trivial to
delete. And this means our language must be easy to statically analyze
(ideally, though not necessarily, a language with a type system). Static
analysis means that <strong>when</strong> I delete code, I can know whether other
code relied on it. Renaming a function, relocating files, deleting
unused features—I choose languages that make these operations easy.</p>

<p>As a quick aside, I&rsquo;d like to elaborate on what I mean by &ldquo;not
necessarily&rdquo; a type system. Take for example the case of JavaScript&rsquo;s
<code>package.json</code> files (specified with JSON) versus Ruby&rsquo;s <code>Gemfile</code>s
(specified with Ruby code). Neither of these configuration files are
&ldquo;typed&rdquo; in the traditional sense, but that does not mean they&rsquo;re
statically unanalyzable:</p>

<ul>
<li><p><code>package.json</code> files can be (and frequently are) parsed and analyzed
in any language with a JSON parser. It&rsquo;s easy to check that all
required keys are passed, that custom config for some specific package
has been set up correctly, etc.</p></li>
<li><p>On the other hand, <code>Gemfile</code>s can only be analyzed from Ruby and even
then only by actually running the code. <code>Gemfile</code>s can even have
different behavior based on the environment—only a simple <code>ENV[...]</code>
access away—so even running the code might not be enough to completely
analyze it.</p></li>
</ul>


<p>My point is that even though JSON is untyped<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> it&rsquo;s still
statically analyzable, which is better than nothing.</p>

<p>Going back to the case where the language <strong>does</strong> use a type system to
achieve static analysis, the set of features we get expands from &ldquo;safely
delete code&rdquo; to loads of other things:</p>

<ul>
<li>Types serve as machine-checked documentation.</li>
<li>Jump-to-def powered by a type system is fast and accurate.</li>
<li>Types power trustworthy autocompletion results, so people can rely on them.</li>
<li>&hellip;</li>
</ul>


<p>The full list is of course longer, but I want to re-iterate: choosing a
typed language is for me a downstream consequence of choosing a language
where it&rsquo;s trivial to delete code.</p>

<p>Until now I&rsquo;ve relied on an implicit assumption that only via static
analysis or type checking can we easily reason about how to delete code.
The alternative might be to use some sort of dynamic analysis, like
running tests, rolling out refactors behind feature flags, or using some
sort of manual QA checklist.</p>

<p>And while these techniques are still valuable, on their own they&rsquo;re a
poor substitute for static analysis. Why? First: they&rsquo;re opt in.
Programmers have to remember to write tests and to choose to use feature
flags. Static analysis on the other hand is opt out. Having chosen a
language with static analysis from the beginning, it applies everywhere.
This also means if we choose a language we&rsquo;re not satisfied with, it&rsquo;s
easier to change our mind in the future.</p>

<p>Second: they over-index on the quality of the data they&rsquo;re fed. An
example of &ldquo;poor data quality&rdquo; might be excessive use of mocks and stubs
in tests. I&rsquo;ve seen all too many test suites that overuse mocking and
stubbing to the point where they&rsquo;re really just testing the testing
framework.</p>

<p>Another common dynamic analysis technique we use where I work is adding
&ldquo;soft assertions&rdquo; which we define as an assertion that raises an
exception if it fails in tests, but logs to Sentry in production. Before
deleting the core code, we&rsquo;ll preface all calls to it with unconditional
soft assertions, and merge to production to see whether any assertions
fire. Our confidence is directly tied to how well the production data
collected in that time represents all production data.</p>

<p>How long spent waiting for no soft assertions is enough to get a
representative sample? A day? A week? What if we have behavior that only
executes on the first of the month? Or code paths that customers only
hit when they&rsquo;re computing quarterly accounting statements? Or yearly
when they&rsquo;re doing taxes? A week of data collected after changing tax
code might as well be useless if that week wasn&rsquo;t in March or April.</p>

<p>For these two reasons, dynamic analysis fails us when we need it the
most: when we&rsquo;re trying to delete the code that&rsquo;s untested, uncommonly
run, and yet critically important. With only dynamic analysis, the code
that we understand the least is also the code that&rsquo;s the hardest to
remove.</p>

<p>So here&rsquo;s my unsubstantiated claim: dynamic analysis techniques
(anything that involves running the code) are too weak to empower people
to delete code. If we want to delete code, and we do because code is a
liability, we want static analysis.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>The next thing to point out is that not all forms of static analysis are
created equal. Arguably Haskell&rsquo;s static analysis is more powerful than
C&rsquo;s. While I&rsquo;ll acknowledge that some languages give <strong>more</strong> static
guarantees than others, as long as a language can at least reason about
code that&rsquo;s been mistakenly deleted, I prefer to turn my attention to
other questions getting into those minutia. Comparing C and Haskell gets
back into debating language design which, again, is a bit fruitless.</p>

<p>After all that, here&rsquo;s my checklist when choosing a language to start a
new project:</p>

<ol>
<li>Rule out languages where we can&rsquo;t easily delete code.</li>
<li>Narrow the remaining languages to those that fit the circumstances.</li>
<li>Pick any language that&rsquo;s left, because according to step (2) they
all fit our project&rsquo;s needs.</li>
</ol>


<p>Optimizing for deleting code minimizes the biggest regret I&rsquo;ve seen
stemming from a language choice and keeps the door open so we can change
our mind in the future. As a consequence we usually pick up extra
benefits in the process (namely those that come from a good type
system), but choosing a language to fit the circumstances trumps
attempting to debate which type system is The Best.</p>

<p>&nbsp;</p>

<p><em>If you read this far and were hoping that I declare one winner in the
end, I&rsquo;m sorry to disappoint. I&rsquo;m happy to indulge you over lunch or
email, or you can read <a href="https://blog.jez.io/categories/#bash">the rest</a> of <a href="https://blog.jez.io/categories/#haskell">my blog</a> and <a href="https://blog.jez.io/categories/#sml">guess</a> at what I
might say. Regardless, thanks for your time.</em></p>

<!-- vim:tw=72:fdm=marker
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Fundamentally, I believe language choice <strong>only</strong> applies to new projects. Given an existing project, the question is not &ldquo;which language&rdquo; but instead &ldquo;should we rewrite,&rdquo; to which the answer is overwhelmingly <strong>no</strong>. But that&rsquo;s a topic for another post.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>I&rsquo;m aware that it&rsquo;s possible to use schemas and specs to approximate types for JSON, but this only goes to strengthen my argument: those make it <strong>even easier</strong> to statically analyze JSON.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>At this point you might think that I don&rsquo;t believe in dynamic analysis techniques at all. That&rsquo;s not the case, as <a href="https://blog.jez.io/tests-types-correctness/">I&rsquo;ve written before</a> about how I value them. I&rsquo;m only saying that relying on running the code to check if code can be deleted safely does not work. Tests are still useful for plenty of other things.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Notes on Continuations]]></title>
    <link href="https://blog.jez.io/continuations-notes/"/>
    <updated>2019-06-18T18:03:13-07:00</updated>
    <id>https://blog.jez.io/continuations-notes</id>
    <content type="html"><![CDATA[<p>These are some notes I gave out at one of my weekly recitations when I
was teaching <a href="http://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles of Programming Languages</a> at CMU in
April 2017. Continuations have a <em>fascinating</em> analogy with proofs by
contradiction that I might flesh out into a proper post in the future,
but for now here are some rough recitation notes.</p>

<p>They&rsquo;re best understood with Chapter 30 of <a href="http://www.cs.cmu.edu/~rwh/pfpl/">Practical Foundations for
Programming Languages</a> open. (Unfortunately this chapter isn&rsquo;t
available in the online preview of the 2nd edition. I&rsquo;m happy to lend
you my hard copy if I know you IRL.)</p>

<h3>→ <a href="https://blog.jez.io/notes/continuations.pdf">Continuations</a></h3>

<p><strong>Abstract</strong>:</p>

<blockquote><p>Continuations allow for lots of things. Intuitively, we can think of
continuations as &ldquo;functions that never come back.&rdquo; That is,
continuations transfer control to some other part of your program. In
a way, continuations are like a much nicer version of <code>goto</code>. But
they&rsquo;re way more than this—specifically, they reify the concept of a
&ldquo;proof by contradiction&rdquo; into the type system.</p></blockquote>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[A Debugger for Bash in Six Lines of Bash]]></title>
    <link href="https://blog.jez.io/bash-debugger/"/>
    <updated>2019-06-16T09:25:06-07:00</updated>
    <id>https://blog.jez.io/bash-debugger</id>
    <content type="html"><![CDATA[<p>I implemented a &ldquo;debugger&rdquo; for Bash in six lines of Bash. It kind of
behaves like JavaScript&rsquo;s <code>debugger</code> keyword. Here&rsquo;s how it works:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>debugger<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nb">echo</span> <span class="s2">"Stopped in REPL. Press ^D to resume, or ^C to abort."</span>
</span><span class='line'>  <span class="nb">local </span>line
</span><span class='line'>  <span class="k">while </span><span class="nb">read</span> -r -p <span class="s2">"&gt; "</span> line; <span class="k">do
</span><span class='line'>    </span><span class="nb">eval</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
</span><span class='line'>  <span class="k">done
</span><span class='line'>  </span><span class="nb">echo</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>And there it is. Add this to a script, insert a call to <code>debugger</code>
somewhere, and run the script. It&rsquo;ll pause right execution right there.
Once paused, we can do things like:</p>

<ul>
<li>print the contents of variables with <code>echo</code></li>
<li>run commands that are on our <code>PATH</code> (e.g., <code>pwd</code>, <code>ls</code>, &hellip;)</li>
<li>call functions defined in the script</li>
</ul>


<p>&hellip; and pretty much everything that we could have done if we were
editing the script directly. Here&rsquo;s a short session demonstrating how it
can be used:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/usr/bin/env bash</span>
</span><span class='line'>
</span><span class='line'>debugger<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="c"># ... implemented above ...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">foo</span><span class="o">=</span>1
</span><span class='line'>debugger
</span><span class='line'><span class="nb">echo</span> <span class="s2">"foo: </span><span class="nv">$foo</span><span class="s2">"</span></span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ foo.sh
</span><span class='line'>Stopped in REPL. Press ^D to resume, or ^C to abort.
</span><span class='line'>&gt; pwd
</span><span class='line'>/Users/jez
</span><span class='line'>&gt; echo $foo
</span><span class='line'>1
</span><span class='line'>&gt; foo=42
</span><span class='line'>&gt; ^D
</span><span class='line'>foo: 42</span></code></pre></td></tr></table></div></figure>


<h2>Stopping on failures</h2>

<p>I find that most of the time this is useful when a script is failing for
some reason. Rather than put a <code>debugger</code> call right before the failing
command, I can just add this at the top of the file:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">trap</span> <span class="s1">'debugger'</span> ERR</span></code></pre></td></tr></table></div></figure>


<p>When any command has a non-zero exit code, Bash will run <code>debugger</code> and
pause the program.</p>

<p>I&rsquo;ve been keeping this function and <code>trap</code> call commented out at the top
of my scripts and uncommenting them when needed (It uses <code>eval</code>, which
is not the best from a security perspective, which is why it&rsquo;s commented
by default).</p>

<h2>Future work</h2>

<p>Of course, I said &ldquo;debugger&rdquo; in quotes earlier because it&rsquo;s not
<strong>really</strong> a debugger:</p>

<ul>
<li><p>Using it requires editing the script we want to debug to include these
lines, and then calling <code>debugger</code> somewhere. It doesn&rsquo;t launch an
inferior process and control it, like <code>gdb</code> or <code>lldb</code> would.</p></li>
<li><p>There&rsquo;s no <code>break</code> command to edit breakpoints while stopped. All
breakpoints must have been written into the program up front.</p></li>
<li><p>There&rsquo;s also no <code>step</code> or <code>next</code> commands for stepping into or over
the next function or command.</p></li>
<li><p>When it stops, it doesn&rsquo;t show the text content of the last line that
executed, or even the line number.</p></li>
</ul>


<p>But I have some thoughts on how to implement these, too&hellip; Bash&rsquo;s <code>trap</code>
builtin has a way to trap <code>DEBUG</code>, which runs after every command. I
think I could make clever use of <code>trap</code>s to implementat least one of
<code>step</code> or <code>next</code>, and definitely something that says &ldquo;stopped on line X&rdquo;
and maybe even use that to print the source text of that line.
Implementing <code>break</code> seems to be the hardest—I don&rsquo;t have any ideas for
that one right now.</p>

<p>I&rsquo;m releasing this code into the public domain. If you want to change it
to implement any of these features, I&rsquo;d be more than interested to hear
about it!</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Improving CLIs with isatty]]></title>
    <link href="https://blog.jez.io/cli-tty/"/>
    <updated>2019-06-11T12:17:59-07:00</updated>
    <id>https://blog.jez.io/cli-tty</id>
    <content type="html"><![CDATA[<p>One thing I like to do to improve the command-line programs I maintain
is to make them aware of whether they&rsquo;re being run interactively. In
this post I&rsquo;ll show off an easy trick to make programs running
interactively more usable.</p>

<!-- more -->


<p>This always used to trip me up when I was first learning to use the
terminal:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ grep <span class="s1">'def foo'</span></span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;d drop this into the command-line and what happens? It hangs&hellip; Is it
because it&rsquo;s taking a long time to search? Nope—I&rsquo;ve forgetten to tell
<code>grep</code> what files to search in!</p>

<p>When <code>grep</code> is given only a pattern to search for and no files to search
in, it assumes we want to search for that pattern on stdin. This is
great for shell scripts and one-liners at the command-line, but it&rsquo;s
<strong>super</strong> annoying when we&rsquo;re just grepping interactively.</p>

<p>The thing is, it&rsquo;s super easy to detect when the user might have made
this mistake: if we&rsquo;re defaulting to reading from stdin <strong>and</strong> the file
corresponding to stdin represents a terminal (more specifically, a
<a href="https://unix.stackexchange.com/questions/4126/">tty</a>). And once we&rsquo;ve detected it, we can print a helpful message.</p>

<p>Here&rsquo;s how I did it when writing <a href="https://github.com/jez/diff-locs"><code>diff-locs</code></a>, one of the command-line
programs I&rsquo;ve been working on lately:</p>

<figure class='code'><figcaption><span>Check if stdin is a tty in Haskell</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fileIn</span> <span class="o">&lt;-</span> <span class="kr">case</span> <span class="n">inputStyle</span> <span class="kr">of</span>
</span><span class='line'>  <span class="kt">InputFromFile</span> <span class="n">filename</span> <span class="o">-&gt;</span> <span class="kt">IO</span><span class="o">.</span><span class="n">openFile</span> <span class="n">filename</span> <span class="kt">IO</span><span class="o">.</span><span class="kt">ReadMode</span>
</span><span class='line'>  <span class="kt">InputFromStdin</span>         <span class="o">-&gt;</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">isTTY</span> <span class="o">&lt;-</span> <span class="n">hIsTerminalDevice</span> <span class="kt">IO</span><span class="o">.</span><span class="n">stdin</span>
</span><span class='line'>    <span class="n">when</span> <span class="n">isTTY</span> <span class="o">$</span> <span class="kr">do</span>
</span><span class='line'>      <span class="n">errPutStrLn</span> <span class="s">"Warning: reading from stdin, which is a tty."</span>
</span><span class='line'>    <span class="n">return</span> <span class="kt">IO</span><span class="o">.</span><span class="n">stdin</span></span></code></pre></td></tr></table></div></figure>


<p>If we&rsquo;ve been given a file explicitly, just open it. Otherwise, fall
back to reading from stdin. But first, check if <code>IO.stdin</code> is a terminal
device and when it <strong>is</strong>, print a warning.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> The complete file
containing the snippet above is <a href="https://github.com/jez/diff-locs/blob/743bff5cb1abb6e405b0369b195614aea6ec018d/app/Main.hs#L17-L24">on GitHub</a>.</p>

<p>I&rsquo;ve implemented <code>diff-locs</code> as a standard Unix filter—it takes input on
stdin and emits output on stdout. Normal usage looks something like
this, where we pipe <code>git diff</code> into <code>diff-locs</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ git diff | diff-locs</span></code></pre></td></tr></table></div></figure>


<p>But if someone is just playing around at the terminal (maybe, trying to
get the help output to show up), they might run <code>diff-locs</code> without
args, and then be greeted with this message:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ diff-locs
</span><span class='line'>Warning: reading from stdin, which is a tty.
</span><span class='line'>█</span></code></pre></td></tr></table></div></figure>


<p>This is much better than just sitting there appearing to hang!</p>

<h2><code>isatty</code> in other languages</h2>

<p>The trick above works in pretty much every language that supports Unix
programming. Under the hood, the Haskell snippet above is powered by the
<code>isatty</code> function in the C standard library (<code>man 3 isatty</code>), which most
other languages wrap in some way. For example, three other languages I&rsquo;ve
done this in recently:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="no">STDIN</span><span class="p">.</span><span class="nf">isatty?</span>
</span><span class='line'>  <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s1">'Warning: reading from stdin, which is a tty.'</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Bash</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">if</span> <span class="o">[</span> -t 0 <span class="o">]</span>; <span class="k">then
</span><span class='line'>  </span><span class="nb">echo</span> <span class="s1">'Warning: reading from stdin, which is a tty.'</span> &gt;&amp;2
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>OCaml</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">if</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">isatty</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">stdin</span>
</span><span class='line'><span class="k">then</span> <span class="n">prerr_endline</span> <span class="s2">"Warning: reading from stdin, which is a tty."</span>
</span><span class='line'><span class="k">else</span> <span class="bp">()</span></span></code></pre></td></tr></table></div></figure>


<p>And again, a quick search for <code>isatty &lt;language&gt;</code> should suffice for any
language that supports Unix programming. It&rsquo;s little things like this
that add up and make certain command-line utilities delightful to use.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>We don&rsquo;t really need to check whether the file we&rsquo;re opening is a tty. If the user managed to pass in the <em>name</em> of a tty file, they probably know what they&rsquo;re doing.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Standard ML in Travis&nbsp;CI]]></title>
    <link href="https://blog.jez.io/sml-travis-ci/"/>
    <updated>2019-06-04T09:26:45-07:00</updated>
    <id>https://blog.jez.io/sml-travis-ci</id>
    <content type="html"><![CDATA[<p>For one of my recent projects (<a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a>) I went through the work to
get Standard ML building in Travis CI. It turned out to be not too
hard—in fact, the hardest part is already done, and I&rsquo;m happy to share
how it works.</p>

<!-- more -->


<p><a href="https://travis-ci.org/">Travis CI</a> is a service that lets a project run arbitrary code when
someone commits and pushes a change. This code can do things like make
sure the tests pass, build and publish releases, and even deploy the
code somewhere.</p>

<h2>Features</h2>

<p>The way I set up my builds for SML with Travis CI, I can:</p>

<ul>
<li>build and test with both macOS and Linux</li>
<li>build and test with both SML/NJ and MLton</li>
<li>create executables, even with SML/NJ</li>
<li>publish the resulting builds to GitHub as releases</li>
</ul>


<p>Apart from some scripts to install things on each operating system,
under the hood it&rsquo;s powered by <a href="https://github.com/jez/symbol">Symbol</a>, which is a build tool for
Standard ML I wrote which factors out most of the project-agnostic
stuff.</p>

<h2>The core setup</h2>

<p>Rather than paste the code into a snippet here and wait for it to get
out of date, see my <a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a> project on GitHub for all the
up-to-date files. In total, there are three files in that repo which set
the whole thing up:</p>

<ol>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/.travis.yml">.travis.yml</a> (kicks off the build)</li>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/Brewfile">Brewfile</a> (deps for macOS build)</li>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/tests/travis-install.sh">tests/travis-install.sh</a> (deps for Linux build)</li>
</ol>


<p>If you haven&rsquo;t used Travis CI before, you&rsquo;ll probably also want to check
out the <a href="https://docs.travis-ci.com/">Travis CI docs</a> to get a feel for how to actually set things
up, and where these pieces fit in.</p>

<p>After installing the deps on each box (like SML/NJ and MLton) and
running the tests, the command which actually builds the the whole
project is</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>./symbol install</span></code></pre></td></tr></table></div></figure>


<p>This command is provided by <a href="https://github.com/jez/symbol">Symbol</a>, a build tool I wrote for Standard
ML. I talk a little bit more about it in the section below.</p>

<h2>Why write a whole build tool?</h2>

<p>I mentioned above that I&rsquo;d written a build tool for Standard ML, called
<a href="https://github.com/jez/symbol">Symbol</a>. Why? It started as a shell script + <code>Makefile</code> for
<a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a> and then I realized that these scripts could be useful in
any Standard ML project.</p>

<p>SML/NJ and MLton are already great compilers with their own build tools.
It&rsquo;s useful to be able to build a project with both (SML/NJ for faster
builds and a REPL, and MLton for faster compiled executables). All
Symbol really does is put SML/NJ and MLton behind a unified, very
stripped down interface. It doesn&rsquo;t try to hide that, so that it&rsquo;s still
possible to fall back to those programs for more complex workflows.</p>

<p>There&rsquo;s more information <a href="https://github.com/jez/symbol">in the README</a>, but some key points:</p>

<ul>
<li>Symbol makes it easy to build and install executables, even with
SML/NJ which traditionally uses heap images.</li>
<li>Symbol is built on <code>make</code>, so if <strong>no</strong> source files change, even
recompiling with MLton is instant (e.g., changing a test and
re-running the tests doesn&rsquo;t require re-building everything).</li>
<li>Symbol also supports scaffolding new Standard ML projects, which is
nicer than starting from scratch.</li>
</ul>


<p>The usage looks something like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># initialize a new project:</span>
</span><span class='line'>❯ symbol-new hello
</span><span class='line'>❯ <span class="nb">cd </span>hello
</span><span class='line'>
</span><span class='line'><span class="c"># build with SML/NJ:</span>
</span><span class='line'>❯ ./symbol make
</span><span class='line'>❯ .symbol-work/bin/hello
</span><span class='line'>Hello, world!
</span><span class='line'>
</span><span class='line'><span class="c"># or, build with MLton:</span>
</span><span class='line'>❯ ./symbol make <span class="nv">with</span><span class="o">=</span>mlton
</span><span class='line'>❯ .symbol-work/bin/hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<p>Again, there&rsquo;s way more information <a href="https://github.com/jez/symbol">in the README</a>, so
definitely check it out if you&rsquo;re thinking about setting up a new
Standard ML project.</p>

<h2>Why Standard ML in the first place?</h2>

<p>I&rsquo;ll probably get around to <a href="https://blog.jez.io/surgery-on-code/">writing about <code>multi-grep</code></a> (and related
tools like <code>diff-locs</code> and <code>multi-sub</code>) but at the end of the day:
SML is a really pleasant language to use in a lot of ways:</p>

<ul>
<li>Type inference in Standard ML is a breath of fresh air.</li>
<li>Data types let me wonder less about how things work.</li>
<li>Pattern matching makes for concise, clean, and correct code.</li>
</ul>


<p>Standard ML was my most commonly used programming language throughout
all of my university courses, so there&rsquo;s a definite soft spot in my
heart for it. There are features that I wish it had sometimes, but it&rsquo;s
the only language that I&rsquo;ve used that doesn&rsquo;t feel fundamentally broken
in some way.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Profiling in Haskell for a 10x Speedup]]></title>
    <link href="https://blog.jez.io/profiling-in-haskell/"/>
    <updated>2019-05-20T03:13:34+08:00</updated>
    <id>https://blog.jez.io/profiling-in-haskell</id>
    <content type="html"><![CDATA[<p>I wrote up a toy project in Haskell and profiled it to learn about
Haskell&rsquo;s profiling tools and about profiling code in general.
Profiling in Haskell with Stack is super easy; to prove it I&rsquo;ll walk
through the problem I was trying to solve, my slow first solution, and
how I used Haskell&rsquo;s profiling tools to find and fix some egregiously
slow parts of the code.</p>

<!-- more -->


<p>I had three takeaways from this little project:</p>

<ul>
<li>Guessing at how to make code faster works sometimes, but:</li>
<li>profiling in Haskell is actually super painless, and is a way better
use of my time than guessing at what&rsquo;s slow.</li>
<li>With repeated profiling it&rsquo;s definitely possible to make reasonably
fast Haskell.</li>
</ul>


<p>The source code and profiling data for this project is all available
<a href="https://github.com/jez/bingo-sim">on GitHub</a>. Also the Appendix below has a bunch of links to
help you find the interesting parts of the code.</p>

<h2>Problem: simulating probabilities</h2>

<p>The problem I wanted to solve was to simulate the probability of winning
one carnival game I got to play while on vacation recently. The game
itself is super simple and purely luck-based. The rules:</p>

<ol>
<li>There&rsquo;s a 6 × 6 grid, each with a special character identifying it.</li>
<li>There are 36 tiles, each with a character matching one grid space
(and there are no duplicates, so all characters are accounted for).</li>
<li>Initially, all tiles are placed face down.</li>
<li>To play, a contestant chooses 15 of the 36 tiles and flips them
over.</li>
<li>The contestant then places the flipped tiles onto the correct spots.</li>
<li>If placing the 15 tiles forms a bingo in any row, column, or full
diagonal, it&rsquo;s a win. Otherwise, it&rsquo;s a loss.</li>
</ol>


<p>The game setup in real life looked something like this:</p>

<p><a href="https://blog.jez.io/images/taiwan-carnival-bingo.jpg"><img src="https://blog.jez.io/images/taiwan-carnival-bingo.jpg" alt="Taiwan Carnival Bingo" /></a></p>

<p>(<a href="https://www.b-kyu.com/2014/07/hua-yuan-night-market-tainan-taiwan.html">Image credit</a>)</p>

<p>My question was: how lucky should we considider ourselves if we win?
I&rsquo;m sure I could have answered this exactly with some combinatorics, but
that seemed boring. Instead, I wanted to write a program solve it:
generate random boards, and check how many of them have bingos.</p>

<h2>Naive solution</h2>

<p>In the course of playing around with this problem, I implemented a bunch
of different solutions—about 5 in total, each one faster than the last.
At a high level, each solution followed this pattern:</p>

<ul>
<li>generate a board uniformly at random</li>
<li>count how many of the generated boards had bingos</li>
</ul>


<p>All the solutions exploited the fact that we don&rsquo;t care where the
characters on the board are nor what characters are on the tiles. The
only thing that matters is whether a tile ends up on a specific grid
space, which means boards can just be vectors of bits.</p>

<p><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> was <em>really</em> slow, so we won&rsquo;t talk about it 😅</p>

<p><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was a little bit faster (but not by much, which made me
disappointed—more on this later). The solution looked like this:</p>

<ul>
<li><p>Our 6 × 6 grids are represented as bit-matrices in row-major order, so
we can store them in a 64-bit unsigned int (<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64"><code>Word64</code></a>) and only use
the 36 least significant bits. A <code>1</code> on our board means &ldquo;one of the 15
tiles we picked matched this grid spot.&rdquo;</p></li>
<li><p>To generate a random board, we start with a board of 15 consecutive
<code>1</code>&rsquo;s (<code>0x7fff</code>) and then use the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> to shuffle
the bits amongst the 36 available bits.</p>

<p>Fisher-Yates shuffle is actually really simple, which is nice.
Here&rsquo;s the <a href="https://github.com/jez/bingo-sim/blob/8886a66/src/BingoSim/Simulation.hs#L111-L126">six lines</a> to implement it in Haskell
on a bit vector:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">shuffleBits</span> <span class="o">::</span> <span class="kt">RandomGen</span> <span class="n">g</span> <span class="o">=&gt;</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="kt">Board</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Board</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="n">board</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
</span><span class='line'>  <span class="c1">-- (Maybe) swap the current MSB with one of the lesser bits</span>
</span><span class='line'>  <span class="kr">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">gen'</span><span class="p">)</span> <span class="o">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">gen</span>
</span><span class='line'>      <span class="n">bs'</span>       <span class="o">=</span> <span class="n">swapBits</span> <span class="n">bs</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">i</span>
</span><span class='line'>  <span class="c1">-- Recurse on the lesser bits</span>
</span><span class='line'>  <span class="kr">in</span>  <span class="n">shuffleBits</span> <span class="n">gen'</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs'</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>With the above method, we generate 100,000 random boards using and
check how many boards have at least one bingo.</li>
</ul>


<h2>Clever, but not in the right ways</h2>

<p>All told, I thought the approach in <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was pretty clever. It
used a single <code>Word64</code> (instead of a larger structure like a list) to
represent the board, so it shouldn&rsquo;t have had needed many allocations.
And because it was just a <code>Word64</code>, it could use bit operations to
manipulate the board and check for bingos, avoiding the need to walk a
large structure.</p>

<p>But when I ran this on my 2017 MacBook Pro (i7-7920HQ CPU @ 3.10GHz, 16
GB memory), it was still really slow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3529
</span><span class='line'>Hit rate: 0.03529
</span><span class='line'>  0.71s user  0.02s system  98% cpu  0.738 total</span></code></pre></td></tr></table></div></figure>


<p>(Note that we&rsquo;re running <code>time</code> on the compiled binary directly, instead
of running with <code>stack exec --</code>; we don&rsquo;t care for the overhead from
running via Stack).</p>

<p>So even after using a bit vector for the board, it took 738ms. To be
clear, these results for <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> were an improvement over my even
slower <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>, but not by much—maybe by 200ms. 700ms+ seemed
excessive.</p>

<h2>How to profile Haskell code</h2>

<p>Determined to make it faster, at this point I resigned myself from
guessing and looked up how to profile Haskell code. Turns out, with
Stack it&rsquo;s <strong>super</strong> simple:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Rebuild with profiling information</span>
</span><span class='line'>❯ stack build --profile
</span><span class='line'>
</span><span class='line'><span class="c"># Run the code with runtime profiling enabled</span>
</span><span class='line'>❯ stack <span class="nb">exec</span> -- bingo-sim 100000 +RTS -p -RTS</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s all it took, and it generated a <code>bingo-sim.prof</code> file that had a
bunch of lines that <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">looked like this</a>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>COST CENTRE              MODULE  SRC  no.  entries  %time %alloc   %time %alloc
</span><span class='line'>...
</span><span class='line'>  randomR                ...     ...  ...  ...       0.8    0.0    84.9   83.5
</span><span class='line'>  randomIvalIntegral     ...     ...  ...  ...       6.9   13.4    84.1   83.5
</span><span class='line'>   randomIvalInteger     ...     ...  ...  ...      21.3   29.2    77.2   70.1
</span><span class='line'>    randomIvalInteger.f  ...     ...  ...  ...      11.0    2.4    41.5   31.5</span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s a bunch of extra information in the actual <code>.prof</code> file (which
you can <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">see on GitHub</a>) but the important parts for
me were the four columns at the end. The first two are the proporion of
execution time and allocated memory attributable to this cost center
specifically. The last two are the same, but summed over all child cost
centers.</p>

<p>(I found the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">GHC User Guide</a> <em>super</em> helpful to learn everything I
wanted to know: what the columns mean, what a cost center is, and some
tips for profiling in general).</p>

<p>So the glaring realization in the data: we&rsquo;re spending 85% of our 738ms
running time <strong>generating random numbers</strong>. All my effort spent
optimizing memory, but it was the PRNG that was slow the whole time. 😣</p>

<h2>Fast PRNG in Haskell</h2>

<p>738ms × 0.849 ≈ 600ms+ spent generating random numbers seemed like an
absurd abount of time. Non-cryptographically secure pseudo random number
generation shouldn&rsquo;t take this long. And indeed, after a bit of
searching I came across <a href="https://www.reddit.com/r/haskell/comments/7ma9rd/in_your_professional_experience_how_suitable_is/">this reddit thread</a> complaining about how slow
<code>System.Random</code> in Haskell is for PRNG, and then moments later I found
<a href="https://nullprogram.com/blog/2017/09/21/">this article</a> from Chris Wellons comparing various PRNGs for
performance&hellip; Exactly what I was looking for 👌</p>

<p>So for <a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a>, I took his <a href="http://xoshiro.di.unimi.it/">suggested PRNG</a> and ported it from
<a href="http://xoshiro.di.unimi.it/xoshiro256starstar.c">C</a> to <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs">Haskell</a>.</p>

<p>And lo and behold, it was faster. A lot faster:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3670
</span><span class='line'>Hit rate: 0.0367
</span><span class='line'>  0.11s user  0.01s system  90% cpu  0.126 total</span></code></pre></td></tr></table></div></figure>


<p>Yep. That just went from 738ms to 126ms, for a 5.8x speedup 🤯</p>

<p>With a result this good, we might ask ourselves what we had to give up
in the process—things this good usually come at a price. The biggest one
that I notice is that the API I provide for random number generation is
far less generic.</p>

<p>My <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> is a direct translation of the C to Haskell. It
only generates 64-bit unsigned ints. <code>System.Random</code> has an arguably
nicer API, using type classes to generate random ints, characters, etc.,
allowing users to implement generators for their custom types, and
having helpers for generating random values within a range and sequences
of random numbers.</p>

<p>It&rsquo;s possible we could prune some of the fat from <code>System.Random</code>&rsquo;s
default implementations (without also changing the underlying random
number generator) and see a considerable speedup. It&rsquo;s also possible we
could make <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> export instances of the appropriate type
classes, and again see a speedup.</p>

<p>But considering that I wasn&rsquo;t using any of that extra stuff, I figured
I&rsquo;d just keep it simple. The code to generate random boards hardly
changed:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">shuffleBits</span> <span class="o">::</span> <span class="kt">Prng</span><span class="o">.</span><span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Board</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Board</span><span class="p">,</span> <span class="kt">Prng</span><span class="o">.</span><span class="kt">State</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="n">board</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">n'</span>           <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>      <span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="n">gen'</span><span class="p">)</span> <span class="o">=</span> <span class="n">next</span> <span class="n">gen</span>
</span><span class='line'>      <span class="c1">-- Uses `mod` instead of `randomR` to generate within a range</span>
</span><span class='line'>      <span class="n">i</span>            <span class="o">=</span> <span class="n">rand</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>      <span class="n">bs'</span>          <span class="o">=</span> <span class="n">swapBits</span> <span class="n">bs</span> <span class="n">n'</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>  <span class="n">shuffleBits</span> <span class="n">gen'</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs'</span><span class="p">)</span> <span class="n">n'</span></span></code></pre></td></tr></table></div></figure>


<h2>Further speedups</h2>

<p>Spurred on by the thrill of the previous speedup, I kept going. By this
time I&rsquo;d learned the value in following the <code>.prof</code> output. The output
led me to <a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a>, which refactored the PRNG into CPS avoid
allocating a tuple, and then <a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a>, where I added some
<code>BangPatterns</code>.</p>

<p>At the end of it all, my simulation ran in just 70ms!</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3670
</span><span class='line'>Hit rate: 0.0367
</span><span class='line'>  0.06s user   0.01s system   92% cpu   0.070 total</span></code></pre></td></tr></table></div></figure>


<p>This is a 10x speedup over my dissapointing <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a>, and a 12.8x
speedup over my super naive <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>. Not bad for a first attempt at
profiling in Haskell!</p>

<p>I found this super encouraging. Given how easy the tooling is to get
started with, how well documented things are, and my satisfaction with
the results, I&rsquo;m very likely to reach for profiling tools in the future.</p>

<h2>Appendix: Links</h2>

<p>The entire source is <a href="https://github.com/jez/bingo-sim">on GitHub</a>.</p>

<p>I wrote up all five of my attepts as separate GitHub commits, so if you
want to compare and constrast the approaches feel free:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> (899ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> (738ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a> (126ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a> (101ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a> (70ms)</li>
</ul>


<p>I also had never used Haddock before, so I used this project as an
opportunity to learn how to build and write Haddock. I published the
docs on GitHub pages if you want to browse them:</p>

<ul>
<li><a href="https://jez.io/bingo-sim/">Docs</a></li>
</ul>


<p>And I also put the source for all the <code>.prof</code> files I generated for each
attempt:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.1.prof"><code>bingo-sim.1.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof"><code>bingo-sim.2.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.3.prof"><code>bingo-sim.3.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.4.prof"><code>bingo-sim.4.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.5.prof"><code>bingo-sim.5.prof</code></a></li>
</ul>


<p>If you have any questions about anything, feel free to <a href="https://jez.io/">reach out</a>!</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Concurrent Programming in ML: A Race]]></title>
    <link href="https://blog.jez.io/cpml-race/"/>
    <updated>2018-07-17T21:23:23-07:00</updated>
    <id>https://blog.jez.io/cpml-race</id>
    <content type="html"><![CDATA[<p>Lately I&rsquo;ve been super interested in language models for concurrency,
after hearing a fascinating talk from Adam Solove on <a href="https://medium.com/@asolove/synchronizable-abstractions-for-understandable-concurrency-64ae57cd61d1">synchronizable
abstractions for UI</a>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> I&rsquo;ve been working my way through a
handful of books, including <a href="https://simonmar.github.io/pages/pcph.html">PCPH</a>, the Concurrency section of <a href="http://www.cs.cmu.edu/~rwh/pfpl.html">PFPL</a>,
and most recently <a href="http://www.cambridge.org/gb/academic/subjects/computer-science/distributed-networked-and-mobile-computing/concurrent-programming-ml?format=AR">Concurrent Programming in ML</a>, by John Reppy.</p>

<p>In particular, I think I&rsquo;ve found a race condition in one of the code
listings of Concurrent Programming in ML. After introducing the listing
itself, we&rsquo;ll walk through a trace that shows the errant behavior, then
propose a small change that prevents it from happening.</p>

<h2>Setup: Snippets from the Book</h2>

<p>Before we begin, here&rsquo;s the listing in full. It&rsquo;s a sample
implementation of a 1-element concurrent buffer, using condition
variables. It supports creation, insertion, and removal.</p>

<figure class='code'><figcaption><span>Concurrent Programming in ML, Listing 2.3</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">buffer</span> <span class="p">=</span> <span class="nc">BUF</span> <span class="kr">of</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">data</span>      <span class="p">:</span> <span class="nd">'a</span> <span class="n">option</span> <span class="n">ref</span><span class="p">,</span>
</span><span class='line'>  <span class="n">mu</span>        <span class="p">:</span> <span class="n">mutex</span><span class="p">,</span>
</span><span class='line'>  <span class="n">dataAvail</span> <span class="p">:</span> <span class="n">condition</span><span class="p">,</span>
</span><span class='line'>  <span class="n">dataEmpty</span> <span class="p">:</span> <span class="n">condition</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">buffer</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="kr">val</span> <span class="n">mu</span> <span class="p">=</span> <span class="n">mutex</span><span class="p">()</span> <span class="kr">in</span>
</span><span class='line'>    <span class="n">BUF</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">data</span>      <span class="p">=</span> <span class="n">ref</span> <span class="n">NONE</span><span class="p">,</span>
</span><span class='line'>      <span class="n">mu</span>        <span class="p">=</span> <span class="n">mu</span><span class="p">,</span>
</span><span class='line'>      <span class="n">dataAvail</span> <span class="p">=</span> <span class="n">condition</span> <span class="n">mu</span><span class="p">,</span>
</span><span class='line'>      <span class="n">dataEmpty</span> <span class="p">=</span> <span class="n">condition</span> <span class="n">mu</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">insert</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">},</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="n">NONE</span> <span class="p">=</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>      <span class="p">|</span> <span class="nc">waitLp</span> <span class="p">(</span><span class="n">SOME</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataEmpty</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">))</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">remove</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">})</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="n">NONE</span> <span class="p">=</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataAvail</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">))</span>
</span><span class='line'>      <span class="p">|</span> <span class="nc">waitLp</span> <span class="p">(</span><span class="n">SOME</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">NONE</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataEmpty</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">end</span></span></code></pre></td></tr></table></div></figure>


<p>You might also want to reference this exerpt which explains the
semantics of the concurrency primitives at play in the snippet above:
locks and condition variables. Study the listing above and exerpt below
for a moment. See if you can spot a race, or are convinced the code is
correct.</p>

<blockquote><p>The semantics of the expression</p>

<p><code>withLock mu f x</code></p>

<p>are that first the lock mu is acquired, then the function f is applied
to x, and then the function&rsquo;s result is returned after releasing the
lock.</p>

<p>The basic operations on condition variables are</p>

<p><code>val wait : condition -&gt; unit</code></p>

<p>which causes a process to block on the condition variable, and</p>

<p><code>val signal : condition -&gt; unit</code></p>

<p>which wakes up one waiting process. A condition variable is associated
with a specific mutex lock, which must be held when performing a wait
operation on the variable. The semantics of the wait operation are
that the mutex lock is released, and then the process is blocked; when
the condition is signaled, the next process in the condition&rsquo;s waiting
queue is unblocked and it reacquires the mutex lock and proceeds. A
signal operation on a condition variable that has an empty waiting
queue has no effect; in this sense condition variables are memoryless.</p>

<p>&mdash; <em>Concurrent Programming in ML</em>, section 2.4.2</p></blockquote>

<h2>A trace to expose the problem</h2>

<p>The problem I see has to do with SML&rsquo;s eager evaluation: before calling
a function <code>f e</code>, we evaluate <code>e</code> to a value <code>v</code>. Then substitution
kicks in and we substitute <code>v</code> into the body of <code>f</code>. For us,
that means that in the definition of <code>insert</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">fun</span> <span class="nf">insert</span> <span class="c">(*</span><span class="cm"> ··· *)</span> <span class="p">=</span>
</span><span class='line'>  <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="c">(*</span><span class="cm"> ··· *)</span></span></code></pre></td></tr></table></div></figure>


<p>we evaluate <code>!data</code> to a value before we run the body of <code>withLock</code> to
acquire the lock. When inserting into an empty queue, <code>!data</code> evaluates
to <code>NONE</code>. And since this happens outside the <code>withLock</code> if two calls to
insert attempt to acquire the lock at the same time, they&rsquo;ll both think
the queue is empty when they wake up! When this happens, the one to wake
up second will unknowingly overwrite what the first one inserted.</p>

<p>Here&rsquo;s a sample trace of a program allocating a buffer and then
doing two concurrent insertions:</p>

<figure class='code'><figcaption><span>Sample trace, showing that first insert gets dropped</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="c">(*</span><span class="cm"> '=&gt;' marks steps where two threads evolve concurrently  *)</span>
</span><span class='line'><span class="c">(*</span><span class="cm"> '-&gt;' marks steps where just one thread evalautes        *)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-&gt;</span> <span class="kr">val</span> <span class="nv">buf</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> Fork two threads; both have access to 'buf'.            *)</span>
</span><span class='line'>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 *)</span>                       <span class="c">(*</span><span class="cm"> thread 2 *)</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">insert</span> <span class="n">buf</span> <span class="mi">1</span>                         <span class="n">insert</span> <span class="n">buf</span> <span class="mi">2</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>           <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="n">NONE</span>              <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 acquires lock *)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="mi">1</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> {data = ref (SOME 1), ...} *)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(();</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="n">signal</span> <span class="n">dataAvail</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">()</span>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 releases lock *)</span>
</span><span class='line'>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> thread 2 acquires lock *)</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> NONE is now stale! *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> selects wrong case in function *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="mi">2</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> ==&gt; data = ref (SOME 2) *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(();</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="n">signal</span> <span class="n">dataAvail</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">()</span></span></code></pre></td></tr></table></div></figure>


<p>Notice how the stale read allowed two consecutive inserts. What we
wanted was for the second insert to wake up, see that the buffer is
full, then wait for the <code>dataEmpty</code> condition variable to wake it up.
So having the <code>!data</code> outside the lock is not good.</p>

<h2>Fixing the stale read</h2>

<p>The solution to this is to delay evaluating <code>!data</code> until the body of the
<code>waitLp</code> function, which only executes when we have the lock. This
ensures that we don&rsquo;t read a stale value for the content of the buffer.</p>

<figure class='code'><figcaption><span>Listing 2.3, updated to avoid race</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">buffer</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'><span class="nc">fun</span> <span class="n">buffer</span> <span class="p">()</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">insert</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">},</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="c">(*</span><span class="cm"> !data is now within waitLp, so it's never stale. *)</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>      <span class="kr">case</span> <span class="n">!data</span>
</span><span class='line'>        <span class="kr">of</span> <span class="n">NONE</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>         <span class="p">|</span> <span class="nc">SOME</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataEmpty</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">())</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">()</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">remove</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">})</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>      <span class="kr">case</span> <span class="n">!data</span>
</span><span class='line'>        <span class="kr">of</span> <span class="n">NONE</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataAvail</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">())</span>
</span><span class='line'>         <span class="p">|</span> <span class="nc">SOME</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">NONE</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataEmpty</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">()</span>
</span><span class='line'>  <span class="kr">end</span></span></code></pre></td></tr></table></div></figure>


<p>Pretty small bug, and it doesn&rsquo;t detract from the main point of the
listing, which is to show how to use condition variables in a sort of
&ldquo;mutually recursive&rdquo; style where <code>dataEmpty</code> wakes up <code>insert</code> which
signals on <code>dataAvail</code> which wakes up <code>remove</code>.</p>

<p>This also underscores how difficult it really is to ensure correctness
in the presence of concurrency! That&rsquo;s exactly why I&rsquo;ve been reading
about all these language models for concurrency, to better understand
how we can leverage our programming language to ensure our programs are
correct by construction.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Unfortunately, the talk isn&rsquo;t online (Adam presented it at work), so the blog post linked above is the next best thing!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Prefer .then() over .catch()]]></title>
    <link href="https://blog.jez.io/prefer-then-over-catch/"/>
    <updated>2018-05-31T15:58:52-07:00</updated>
    <id>https://blog.jez.io/prefer-then-over-catch</id>
    <content type="html"><![CDATA[<p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<figure class='code'><figcaption><span>Bad code; don&#8217;t do this</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// "Success" and "failure" types (definitions omitted)</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">OkResult</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve(...) when it worked, but</span>
</span><span class='line'>    <span class="c1">// cal reject(...) when it failed.</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span></span></code></pre></td></tr></table></div></figure>


<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">ErrResult</span> <span class="o">=</span> <span class="nx">string</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// number, not a string!</span>
</span><span class='line'><span class="nx">reject</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></span></code></pre></td></tr></table></div></figure>


<p>nor from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// boolean, not a string!</span>
</span><span class='line'><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...);</span></span></code></pre></td></tr></table></div></figure>


<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<figure class='code'><figcaption><span>Better code than before</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Helper function for exhaustiveness.</span>
</span><span class='line'><span class="c1">// See here: https://blog.jez.io/flow-exhaustiveness/</span>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">absurd</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/absurd'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Use a union type to mean "success OR failure"</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">Result</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'ok'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">OkResult</span><span class="o">|</span><span class="p">}</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'err'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">ErrResult</span><span class="o">|</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//     Use our new union type ──┐</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">Result</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'ok',  val: ...}) when it worked, and</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'err', val: ...}) when it failed</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="c1">// Use a switch statement in the result:</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'ok'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'err'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// Guarantees we covered all cases.</span>
</span><span class='line'>        <span class="nx">absurd</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">})</span></span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// If I know that throwNumber will always call `reject` with a</span>
</span><span class='line'><span class="c1">// number, I can stop the loose types from propagating further</span>
</span><span class='line'><span class="c1">// with an explicit annotation:</span>
</span><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── explicit annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span></span></code></pre></td></tr></table></div></figure>


<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── defensive annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="s1">'number'</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Reports misbehavior to an imaginary observability service</span>
</span><span class='line'>      <span class="nx">tracker</span><span class="p">.</span><span class="nx">increment</span><span class="p">(</span><span class="s1">'throwNumber.unexpected_input'</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span></span></code></pre></td></tr></table></div></figure>




<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Union Types in Flow & Reason]]></title>
    <link href="https://blog.jez.io/union-types-flow-reason/"/>
    <updated>2018-04-18T22:43:26-07:00</updated>
    <id>https://blog.jez.io/union-types-flow-reason</id>
    <content type="html"><![CDATA[<p>Union types are powerful yet often overlooked. At work, I&rsquo;ve been using
Flow which <a href="https://flow.org/en/docs/types/unions/">thankfully supports union types</a>. But as I&rsquo;ve
refactored more of our code to use union types, I&rsquo;ve noticed that our
bundle size has been steadily increasing!</p>

<!-- more -->


<p>In this post, we&rsquo;re going to explore why that&rsquo;s the case. We&rsquo;ll start
with a problem which union types can solve, flesh out the problem to
motivate why union types are definitely the solution, then examine the
resulting cost of introducing them. In the end, we&rsquo;ll compare Flow to
other compile-to-JS languages on the basis of how they represent union
types in the compiled output. I&rsquo;m especially excited about <a href="https://reasonml.github.io/">Reason</a>, so
we&rsquo;ll talk about it the most.</p>

<h2>Setup: Union Types in a React Component</h2>

<p>Let&rsquo;s consider we&rsquo;re writing a simple React 2FA<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> modal.
We&rsquo;ll be using Flow, but you can pretend it&rsquo;s TypeScript if you want.
The mockup we were given looks like this:</p>

<p><a href="https://blog.jez.io/images/2fa-mockup.jpeg"><img src="https://blog.jez.io/images/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>

<p>In this mockup:</p>

<ul>
<li>There&rsquo;s a loading state while we send the text message.</li>
<li>We&rsquo;ll show an input for the code after the message is sent.</li>
<li>There&rsquo;s no failure screen (it hasn&rsquo;t been drawn up yet).</li>
</ul>


<p>We&rsquo;ll need some way for our component to know which of the three screens
is visible. Let&rsquo;s use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Union types are a perfect fit! 🎉  Union types document intent and can
help guard against mistakes. Fellow developers and our compiler can
know &ldquo;these are all the cases.&rdquo; In particular, Flow can warn us when
we&rsquo;ve <a href="https://blog.jez.io/flow-exhaustiveness/">forgotten a case</a>.</p>

<p>Our initial implementation is working great. After sharing it with the
team, someone suggests adding a &ldquo;cancel&rdquo; button in the top corner. It
doesn&rsquo;t make sense to cancel when the flow has already succeeded, so
we&rsquo;ll exclude it from the last screen:</p>

<p><a href="https://blog.jez.io/images/2fa-close-btn.jpeg"><img src="https://blog.jez.io/images/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>

<p>No problem: let&rsquo;s write a function called <code>needsCancelButton</code> to
determine if we need to put a cancel button in the header of a
particular screen:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Recall: 'SuccessScreen' is the last screen,</span>
</span><span class='line'>  <span class="c1">// so it shouldn't have a cancel button.</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Short and sweet. 👌 Everything seems to be working great, until&hellip;</p>

<h2><code>switch</code>: Optimizing for Exhaustiveness</h2>

<p>The next day, we get some updated mocks from the design team. This time,
they&rsquo;ve also drawn up a &ldquo;failure&rdquo; screen for when the customer has
entered the wrong code too many times:</p>

<p><a href="https://blog.jez.io/images/2fa-failure-screen.jpeg"><img src="https://blog.jez.io/images/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>

<p>We can handle this&mdash;we&rsquo;ll just add a case to our <code>Screen</code> type:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span>
</span><span class='line'>  <span class="c1">// New case to handle too many wrong attempts:</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'FailureScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>But now <strong>there&rsquo;s a bug</strong> in our <code>needsCancelButton</code> function. 😧 We
should only show a close button on screens where it makes sense, and
<code>'FailureScreen'</code> is not one of those screens. Our first reaction after
discovering the bug would be to just blacklist <code>'FailureScreen'</code> too:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span> <span class="o">||</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'FailureScreen'</span>
</span><span class='line'>  <span class="p">);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>But we can do better than just fixing the <strong>current</strong> bug. We should
write code so that when we add a new case to a union type, our type
checker alerts us before a <strong>future</strong> bug even happens. What if instead
of a silent bug, we got this cheery message from our type checker?</p>

<blockquote><p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new
screen you added. <em>🙂</em></p>

<p>&mdash; your friendly, neighborhood type checker</p></blockquote>

<p>Let&rsquo;s go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell
us this when adding new cases. We&rsquo;ll use a <code>switch</code> statement with
<a href="https://blog.jez.io/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="na">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="c1">// (I named this function 'absurd' in my earlier post:</span>
</span><span class='line'>      <span class="c1">// https://blog.jez.io/flow-exhaustiveness/)</span>
</span><span class='line'>      <span class="c1">// This function asks Flow to check for exhaustiveness.</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow →)</strong></a></p>

<p>Now Flow is smart enough to give us an error! Making our code safer, one
<code>switch</code> statement at a time. 😅 Union types in Flow are a powerful way
to use types to guarantee correctness. But to get the most out of union
types, <strong>always<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> access them</strong> through a <code>switch</code> statement.
Every time we use a union type without an exhaustive switch statement,
we make it harder for Flow to tell us where we&rsquo;ve missed something.</p>

<h2>Correctness, but at what cost?</h2>

<p>You might not have noticed, but we paid a subtle cost in rewriting
our <code>needsCancelButton</code> function. Let&rsquo;s compare our two functions:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ----- before: 62 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ----- after: 240 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>With just an equality check, our function was small: 62 bytes minified.
But when we refactored to use a <code>switch</code> statement, its size shot up to
240 bytes! That&rsquo;s a 4x increase, just to get exhaustiveness. Admittedly,
<code>needsCancelButton</code> is a bit of a pathological case. But in general: as
we make our code bases <strong>more safe</strong> using Flow&rsquo;s union types of string
literals, our <strong>bundle size bloats</strong>!</p>

<h2>Types and Optimizing Compilers</h2>

<p>One of the many overlooked promises of types is the claim that by
writing our code with <strong>higher-level abstractions</strong>, we give more
information to the compiler. The compiler can then generate code that
captures our original intent, but as efficiently as possible.</p>

<p>Flow is decidedly <strong>not</strong> a compiler: it&rsquo;s only a type checker. To run
JavaScript annotated with Flow types, we first strip the types (with
something like Babel). All information about the types vanishes when we
run the code.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> What can we achieve if we were to <strong>keep the
types around</strong> all the way through compilation?</p>

<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the
benefits of the OCaml tool chain to the web. In particular, Reason
works using OCaml&rsquo;s mature optimizing compiler alongside BuckleScript
(which turns OCaml to JavaScript) to emit great code.</p>

<p>To see what I mean, let&rsquo;s re-implement our <code>Screen</code> type and
<code>needsCancelButton</code> function, this time in Reason:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">screen</span><span class="p">):</span> <span class="nx">bool</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span> <span class="o">=&gt;</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Looks pretty close to JavaScript with Flow types, doesn&rsquo;t it? The
biggest difference is that the <code>case</code> keyword was replaced with the <code>|</code>
character. Making the way we define and use union types look the same is
a subtle reminder to always pair union types with <code>switch</code> statements!
<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> Another difference: Reason handles exhaustiveness checking
out of the box. 🙂</p>

<p>What does the Reason output look like?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE</span>
</span><span class='line'><span class="s1">'use strict'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">screen</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason →)</strong></a></p>

<p>Not bad! Telling Reason that our function was exhaustive let it optimize
the entire <code>switch</code> statement back down to a single <code>if</code> statement. In
fact, it gets even better: when we run this through <code>uglifyjs</code>, it
removes the redundant <code>true</code> / <code>false</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">n</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">n</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code>
statement. Reason compiled what used to be a string literal
<code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely
because custom-defined types in Reason <strong>aren&rsquo;t</strong> strings, so it doesn&rsquo;t
matter if the names get mangled.</p>

<p>Taking a step back, Reason&rsquo;s type system delivered on the promise of
types in a way Flow couldn&rsquo;t:</p>

<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about our code&rsquo;s
correctness via exhaustiveness.</li>
<li>The compiler translated that all to tiny, performant output.</li>
</ul>


<p>I&rsquo;m really excited about Reason. 😄 It has a delightful type system and
is backed by a decades-old optimizing compiler tool chain. I&rsquo;d love to
see more people take advantage of improvements in type systems to write
better code!</p>

<hr />

<h2>Appendix: Other Compile-to-JS Runtimes</h2>

<p>The above analysis only considered Flow + Babel and Reason. But then I
got curious about how other typed languages that compile to JavaScript
compare on the optimizations front:</p>

<h3>TypeScript</h3>

<p>Despite being a language <strong>and</strong> compiler, TypeScript maintains a
goal of compiling to JavaScript that closely resembles the source
TypesScript code. TypeScript has three language constructs for working
with exhaustiveness:</p>

<ol>
<li>union types (identical to the Flow unions that we&rsquo;ve been talking
about),</li>
<li><code>enum</code>s, which are sort of like definition a group of variable
constants all at once, and</li>
<li><code>const enum</code>s which are like <code>enum</code>s except that they&rsquo;re represented
more succinctly in the compiled output.</li>
</ol>


<p>TypeScript&rsquo;s union type over string literals are represented the same
way as Flow, so I&rsquo;m going to skip (1) and focus instead on (2) and (3).</p>

<p>TypeScript&rsquo;s <code>enum</code> and <code>const enum</code> are subtly different. Not having
used the language much, I&rsquo;ll refer you to <a href="https://www.typescriptlang.org/docs/handbook/enums.html">the TypeScript
documentation</a> to learn more about the differences. But for
sure, <code>const enum</code>s compile much better than normal <code>enum</code>s.</p>

<p>Here&rsquo;s what normal <code>enum</code>s look like in TypeScript&mdash;they&rsquo;re <strong>even
worse</strong> than unions of string literals:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">Screen_</span><span class="p">;</span>
</span><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Screen_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"LoadingScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"LoadingScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"CodeEntryScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"CodeEntryScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"SuccessScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"SuccessScreen"</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="nx">Screen_</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Screen_</span> <span class="o">=</span> <span class="p">{}));</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">LoadingScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">CodeEntryScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">SuccessScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground →</strong></a></p>

<p>So for normal <code>enum</code>s:</p>

<ul>
<li>It&rsquo;s not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of
enum values at run time, in a format that doesn&rsquo;t minify well.</li>
</ul>


<p>And then here&rsquo;s what <code>const enum</code>s look like&mdash;you can see that
TypeScript represents them under the hood without any sort of <code>Screen_</code>
object:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">0</span> <span class="cm">/* LoadingScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">1</span> <span class="cm">/* CodeEntryScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">2</span> <span class="cm">/* SuccessScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.typescriptlang.org/play/#src=const%20enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground →</strong></a></p>

<ul>
<li>It uses numbers instead of strings.</li>
<li>It still uses a switch statement, instead of reducing to just an <code>if</code>
statement.</li>
</ul>


<h2>PureScript</h2>

<p>PureScript is another high-level language like Reason. Both Reason and
PureScript have data types where we can define unions with custom
constructor names. Despite that, PureScript&rsquo;s generated code is
significantly worse than Reason&rsquo;s.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">LoadingScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">LoadingScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">LoadingScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LoadingScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">LoadingScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">CodeEntryScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">CodeEntryScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">CodeEntryScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CodeEntryScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">CodeEntryScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">SuccessScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">SuccessScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">SuccessScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuccessScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">LoadingScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">CodeEntryScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">SuccessScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Failed pattern match at Main line 10, column 1 - line 10, column 39: "</span> <span class="o">+</span> <span class="p">[</span> <span class="nx">v</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="p">]);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the match is exhaustive, it still emits a
<code>throw</code> statement in case the pattern match fails!</li>
</ul>


<p>Admittedly, I didn&rsquo;t try that hard to turn on optimizations in the
compiler. Maybe there&rsquo;s a flag I can pass to get this <code>Error</code> to go
away. But that&rsquo;s pretty disappointing, compared to how small Reason&rsquo;s
generated code was!</p>

<h2>Elm</h2>

<p>I list Elm in the same class as Reason and PureScript. Like the other
two, it lets us define custom data types, and will automatically warn
when us pattern matches aren&rsquo;t exhaustive. Here&rsquo;s the code Elm
generates:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">_p0</span> <span class="o">=</span> <span class="nx">page</span><span class="p">;</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">_p0</span><span class="p">.</span><span class="nx">ctor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$SuccessScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'SuccessScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$CodeEntryScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'CodeEntryScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$LoadingScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'LoadingScreen'</span><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s using string literals, much like Flow and TypeScript.</li>
<li>It&rsquo;s smart enough to collapse the last case to just use <code>default</code>
(at least it doesn&rsquo;t <code>throw</code> in the <code>default</code> case!)</li>
<li>The variable names are long, but these would still minify well.</li>
</ul>


<p>It&rsquo;s interesting to see that even though Reason, PureScript, and Elm all
have ML-style datatypes, Reason is the only one that uses an integer
representation for the constructor tags.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>2FA: two-factor authentication<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>&ldquo;Always&rdquo; is a very strong statement. Please use your best judgement. But know that if you&rsquo;re not using a <code>switch</code>, you&rsquo;re trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it&rsquo;s not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn&rsquo;t do compile-time optimizations based on the types.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Case Exhaustiveness in Flow]]></title>
    <link href="https://blog.jez.io/flow-exhaustiveness/"/>
    <updated>2018-04-15T20:02:26-07:00</updated>
    <id>https://blog.jez.io/flow-exhaustiveness</id>
    <content type="html"><![CDATA[<p>Compared to some other languages, <a href="https://flow.org/">Flow</a>&rsquo;s story around exhaustiveness
checking within <code>if / else</code> and <code>switch</code> statements leaves something to
be desired. By default, Flow doesn&rsquo;t do any exhaustiveness checks! But
we <strong>can</strong> opt-in to exhaustiveness checking one statement at a time.</p>

<!-- more -->


<p>In this post, we&rsquo;ll discover from the ground up how Flow&rsquo;s
exhaustiveness checking behaves. But if you&rsquo;re just looking for the
result, here&rsquo;s a snippet:</p>

<h2>TL;DR</h2>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"A"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"B"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorB</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">absurd</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This function will never run!'</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">allGood</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">forgotTagB</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// B. This type is incompatible with the expected param type of empty.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<h2>How Exhaustiveness Behaves in Flow</h2>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiQrACQKYCdOnngBYCGAbnsaAC4CeADngOQCCs2AQo-gJZWHXxYoUsWzdiAOyoBnNIloNQzUAF5QAbyrEA5gC5QAImYGAvgG559PO1Uatew+1MWFeVh1vKAPqHYXEAMawEtJUoJASAIy2ABQAHvru7ACU+qFiEtqqAHwaiKCg3JDxAHT2qipqRgbJ6vkFoLhUAK7YEoYAku0ARtiSAfzGFgUmoJjQ0nh1DY2YLW2dPX0SA74Gw6AmiFtyIErQ0Pjjh5IAJqDasLCnADSg3c1h8CRhRUegxKfnlBKY8KABYiTAD8aFAADE2GM4sQALZ0aCYO4EWaQYgBKhQvgUbqwcjhbiI0AAPWoQmx93GCF0cksigAwrZNDp9AZ6c46W42Ow2Iy1N5fKAfPT-EEQmEIgAmWIJJTc3mpUDpbiZHJ5ApFUrlSpVYzJdUNJqtdoGLr3ZarIb1UbjSYGgpGhampb9fhODZbHaoPYAdWIvA+SswYtuhTCrgBhGDAGtpABCMEAFRejGklMBzTtKMzmG+AOIVAGAFpiAdQIxbZguL1XSVdmAfS9CpB3rDiNG8Jh0fwayt+Jg4gjuAFeKDUGCAKIAJSnAHkp-oZkvl6BADCkgABSQBtpIA4P6VVAy2hKoGT3DTEdPhRWsHhBe43SJ8F4-EkhXh0GHvGgNCLjt+52aEinJgkAqrmdZiqE4QSAAzDKiTytg9KKsqqoqLk0zNlqOgVLqNT2rM8wmmavaWus1pjBMeBvFhWQ6o4eEYQ6czGos5qumsHrbMg3pgAAClG8B3NIQi8KmsywiqpwqlkmbUE2BCMLgoASLAYRBOQB4fGWFKApM0h1nsAAycxiZ85wUr8-yMPSXC6ZgNLjns05zguK5uQUG47nuB5HieZ5WIUaYqkEN5UHeD5Ph87TcG+H5UF+P7MW0uagABQEgX+4HBJBEQACxwXKHAKmk+7SWqGGanEZTYXR1T6oxBEsc6bF9koZEjBRdrUVV2qVPR9X1ExhGsSRbrtZsnVUS2NE4YY7IDTMv4jRa-DspxXrAGCfoBpQkwhiUB1hnuhKHHwKqxnJBattw2iEGES1pcBoGnAmezsI8RyMPi6Uqrw4w0ACeI4ClpanVG+Z6UeuhnRI0bSQA+miAT2fWoCNldKL0swAByoCnCJaZmYG6XEM00BqUCSL3B9QLRhCcD-JioC8XOABqE6XU8eCAhIjBhNocxycDDmbYE2UShIACsBVJMV3llWhBqVdVtF9XV+FLc1o1tR6k3NqAM21U4C2GklREuq17rkZW+uG2r80a2by3sWt1uUfh8T6Jg8K0MkGwFHw2AIMpfygBO2BB9gMSMMQ3TSK0pyMH71pcajyZMIHweWWHEdsFw76-B8uL4o+Za-BpjQAXc3TBqTkxgqJaYqWEdCwNI0jhXgTMQfuzQYoGIjQM0eCwC2EYVj7NCMGCMQGOnSmiHgKnCKWw9Be0FLe3QtBBlQNSox0LYop8sDb3JF50AWVA4O0mAaTQzzA8iVbnJMXeEBeOCR6AsKYO3OiYAbkfPAkA2CXHDEIImFlQ52XCFCekItkA9yggANhlghJCJVNKKwqsUHqNU1Z6kdsNLWK0dZuy6tNfBqsqjG2IU1YiZCrYdRtg1PY9JfIf38ooC8wVryXzCvePAj4+BjEnnWGYnsxHbxoMnGYmd-jZ3DpHaOsd47YETnIzYqceL02DtfA4aZZIGCwDQO4HQ4FpUDPSOMoAADKQgLFBDJqcXmLcg74j4FdM6aZpAiNWPAIE0ISCZjCuQEoBhUbvXDFw0AAjr4LAvNId8t14oA0kCpGgZUmY5mrrXHMYc7GGRVGpfh0B-QhBFqAXIKkiwARzKcIsA46C4HbtwbK+gJyDmDNfb47QgQd20BIX+UhQBQkgABDE7T2iAjLGcS8oQuyv2IP8F8zTWkd2CAZTavpuYvhAnEc+aZugAyRpiTSFJ4k30vEzSgUZoAMGwOESZYVgiILBDHOOCcuAXgsnCbm15YTBC-KlSY5xKyPyUqAp5PjnkrFeRII8kInkDjhAiFGew7pUDoNIXQIASABGjAAkoJBpAdgOCUMBwBL6EoAcAUgsBuCNIAAwlAAOwlEiMAfGARpDAAACIFmIEWVmjLTgkqoLCaAABiUgug1EJzFuKIu6jzhqAADyJmyFIrevt9CJnKvUBRId-jKLYKor5Gik4WHMEg8WUE2XoKKohZCpVULoXqMrXquETZDQYRbUiusbbdRVrNAwdCGqa0YexZhE1g1UNDbVB2kanakJduNG07sU3DQVRo+IWjPSDSXEqnKEgAAcTqeQuqwQrD1Go8GJsIQxItUaA2DAzXrEN3r+r0KdNGy2HbWFFvYZw35AVeFXlCp3HgojN7dIxClS+fRYTUACqPaRtAJGmxzZa04+b1pAA"><strong>Read on flow.org/try/</strong></a></p>

<p>Here we have a type <code>AorB</code> with two variants;</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"A"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"B"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorB</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>All well and good, but what if we add a new case?
For example, what if we take the snippet above and add this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"C"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorBorC</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span> <span class="o">|</span> <span class="nx">C</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Wait a second, it type checks!</p>

<p>That&rsquo;s because we used a catch-all <code>else</code> branch. What if we make each
branch explicit?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Phew, so it&rsquo;s reminding us that we&rsquo;re not covering all the cases.
Let&rsquo;s add the new <code>C</code> case:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn4</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Hmm: it still thinks that we might return <code>undefined</code>, even though we&rsquo;ve
definitely covered all the cases&hellip; 🤔</p>

<p>What we <strong>can</strong> do is add a default case, but ask Flow to <strong>prove</strong> that
we can&rsquo;t get there, using Flow&rsquo;s <code>empty</code> type:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">fn5</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">);</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This will never run!'</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>The <code>throw new Error</code> line above will never run, because it&rsquo;s not
possible to construct a value of type <code>empty</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (&ldquo;There are no
values in the empty set.&rdquo;)</p>

<p>If we adopt this pattern everywhere, we&rsquo;d see this error message if we
forgot to add the new case for <code>C</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">fn6</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// C. This type is incompatible with empty.</span>
</span><span class='line'>    <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">);</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'absurd'</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Flow tells us &ldquo;Hey, I found a C! So I couldn&rsquo;t prove that this switch
was exhaustive.&rdquo;</p>

<p>But this pattern is slightly annoying to use, because ESLint complains:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>no-unused-expressions: Expected an assignment or function call and instead saw an expression.</span></code></pre></td></tr></table></div></figure>


<p>We can fix this by factoring that <code>empty ... throw</code> pattern into a
helper function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// 'absurd' is the name commonly used elsewhere for this function. For example:</span>
</span><span class='line'><span class="c1">// https://hackage.haskell.org/package/void-0.7.1/docs/Data-Void.html#v:absurd</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">absurd</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'absurd'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn7</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn8</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// C. This type is incompatible with the expected param type of empty.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>So there you have it! You can put that helper function (<code>absurd</code>) in a
file somewhere and import it anywhere. You could even give it a
different name if you want! I&rsquo;ve been using this pattern in all the Flow
code I write these days and it&rsquo;s been nice to rely on it when doing
refactors.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Of course, this presumes that Flow&rsquo;s type system is sound, which it isn&rsquo;t. It&rsquo;s possible to accidentally inhabit <code>empty</code> if you use <code>any</code>! Moral of the story: be <em>very</em> diligent about eradicating <code>any</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
  
  <entry>
    <title type="html"><![CDATA[Lenses & Composition]]></title>
    <link href="https://blog.jez.io/lens-composition/"/>
    <updated>2018-02-05T23:07:37-08:00</updated>
    <id>https://blog.jez.io/lens-composition</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>A lens is really just a function <code>a -&gt; b</code> that we represent
backwards<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and with an extra <code>Functor f</code> parameter lying
around:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>type Lens' a b = Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</span></code></pre></td></tr></table></div></figure>


<p><strong>What does this mean for function composition?</strong></p>

<!-- more -->


<p>Normal function composition looks like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="n">g</span> <span class="o">::</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span> <span class="o">.</span> <span class="n">f</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>We often have to read code that looks like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">g</span> <span class="o">.</span> <span class="n">f</span> <span class="o">$</span> <span class="n">x</span></span></code></pre></td></tr></table></div></figure>


<p>This means &ldquo;start with <code>x</code>, then run <code>f</code> on it, and run <code>g</code> after that.&rdquo;
This sentence reads opposite from how the code reads!</p>

<p>What about for lenses? Here we have <code>f'</code> and <code>g'</code> which behave similarly
in some sense to <code>f</code> and <code>g</code> from before:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">f'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="c1">--  ≈ a -&gt; b</span>
</span><span class='line'><span class="n">g'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="c1">--  ≈ b -&gt; c</span>
</span><span class='line'>
</span><span class='line'><span class="n">f'</span> <span class="o">.</span> <span class="n">g'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="c1">--       ≈ a -&gt; c</span></span></code></pre></td></tr></table></div></figure>


<p>In the lens world, <code>^.</code> behaves kind of like a flipped <code>$</code> that turns
lenses into getters, which lets us write code like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">x</span> <span class="o">^.</span> <span class="n">f'</span> <span class="o">.</span> <span class="n">g'</span></span></code></pre></td></tr></table></div></figure>


<p>This means &ldquo;start with <code>x</code>, then get <code>f'</code> from it, then get <code>g'</code> after
that.&rdquo; The sentence reads just like the code!</p>

<p>This is pretty cool, because it means that lenses (which are
&ldquo;functional&rdquo; getters) read almost exactly like property access (which
are &ldquo;imperative&rdquo; getters). Same concise syntax, but with an elegant
semantics.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m exaggerating a bit here 😅 To see what I <em>really</em> mean, see <a href="https://blog.jez.io/lens-intuition">this post</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  
</feed>
