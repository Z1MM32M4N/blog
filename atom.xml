<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-06-14T01:56:07-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A debugger for Bash in six lines of Bash]]></title>
    <link href="https://blog.jez.io/bash-debugger/"/>
    <updated>2019-06-16T12:25:06-04:00</updated>
    <id>https://blog.jez.io/bash-debugger</id>
    <content type="html"><![CDATA[<p>I implemented a &ldquo;debugger&rdquo; for Bash in six lines of Bash. It kind of
behaves like JavaScript&rsquo;s <code>debugger</code> keyword. Here&rsquo;s how it works:</p>

<!-- more -->




<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>debugger<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="nb">echo</span> <span class="s2">"Stopped in REPL. Press ^D to resume, or ^C to abort."</span>
</span><span class='line'>  <span class="nb">local </span>line
</span><span class='line'>  <span class="k">while </span><span class="nb">read</span> -r -p <span class="s2">"&gt; "</span> line; <span class="k">do
</span><span class='line'>    </span><span class="nb">eval</span> <span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span>
</span><span class='line'>  <span class="k">done
</span><span class='line'>  </span><span class="nb">echo</span>
</span><span class='line'><span class="o">}</span></span></code></pre></td></tr></table></div></figure>


<p>And there it is. Add this to a script, insert a call to <code>debugger</code>
somewhere, and run the script. It&rsquo;ll pause right execution right there.
Once paused, we can do things like:</p>

<ul>
<li>print the contents of variables with <code>echo</code></li>
<li>run commands that are on our <code>PATH</code> (e.g., <code>pwd</code>, <code>ls</code>, &hellip;)</li>
<li>call functions defined in the script</li>
</ul>


<p>&hellip; and pretty much everything that we could have done if we were
editing the script directly. Here&rsquo;s a short session demonstrating how it
can be used:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/usr/bin/env bash</span>
</span><span class='line'>
</span><span class='line'>debugger<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="c"># ... implemented above ...</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">foo</span><span class="o">=</span>1
</span><span class='line'>debugger
</span><span class='line'><span class="nb">echo</span> <span class="s2">"foo: </span><span class="nv">$foo</span><span class="s2">"</span></span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ foo.sh
</span><span class='line'>Stopped in REPL. Press ^D to resume, or ^C to abort.
</span><span class='line'>&gt; pwd
</span><span class='line'>/Users/jez
</span><span class='line'>&gt; echo $foo
</span><span class='line'>1
</span><span class='line'>&gt; foo=42
</span><span class='line'>&gt; ^D
</span><span class='line'>foo: 42</span></code></pre></td></tr></table></div></figure>


<h2>Stopping on failures</h2>

<p>I find that most of the time this is useful when a script is failing for
some reason. Rather than put a <code>debugger</code> call right before the failing
command, I can just add this at the top of the file:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">trap</span> <span class="s1">'debugger'</span> ERR</span></code></pre></td></tr></table></div></figure>


<p>When any command has a non-zero exit code, Bash will run <code>debugger</code> and
pause the program.</p>

<p>I&rsquo;ve been keeping this function and <code>trap</code> call commented out at the top
of my scripts and uncommenting them when needed (It uses <code>eval</code>, which
is not the best from a security perspective, which is why it&rsquo;s commented
by default).</p>

<h2>Future work</h2>

<p>Of course, I said &ldquo;debugger&rdquo; in quotes earlier because it&rsquo;s not
<strong>really</strong> a debugger:</p>

<ul>
<li><p>Using it requires editing the script we want to debug to include these
lines, and then calling <code>debugger</code> anywhere we want to pause
execution.</p></li>
<li><p>There&rsquo;s no <code>break</code> command that let us edit breakpoints while stopped.
All breakpoints must have been written into the program up front.</p></li>
<li><p>There&rsquo;s also no <code>step</code> or <code>next</code> commands for stepping into or over
the next function or command.</p></li>
<li><p>When it stops, it doesn&rsquo;t show the text content of the last line that
executed, or even the line number.</p></li>
</ul>


<p>But I have some thoughts on how to implement these, too&hellip; Bash&rsquo;s <code>trap</code>
builtin has a way to trap <code>DEBUG</code>, which runs after every command. I
think I could make clever use of <code>trap</code>s to implementat least one of
<code>step</code> or <code>next</code>, and definitely something that says &ldquo;stopped on line X&rdquo;
and maybe even use that to print the source text of that line.
Implementing <code>break</code> seems to be the hardest—I don&rsquo;t have any ideas for
that one right now.</p>

<p>I&rsquo;m releasing this code into the public domain. If you want to change it
to implement any of these features, I&rsquo;d be more than interested to hear
about it!</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improving CLIs with isatty]]></title>
    <link href="https://blog.jez.io/cli-tty/"/>
    <updated>2019-06-11T15:17:59-04:00</updated>
    <id>https://blog.jez.io/cli-tty</id>
    <content type="html"><![CDATA[<p>One thing I like to do to improve the command-line programs I maintain
is to make them aware of whether they&rsquo;re being run interactively. In
this post I&rsquo;ll show off an easy trick to make programs running
interactively more usable.</p>

<!-- more -->


<p>This always used to trip me up when I was first learning to use the
terminal:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ grep <span class="s1">'def foo'</span></span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;d drop this into the command-line and what happens? It hangs&hellip; Is it
because it&rsquo;s taking a long time to search? Nope—I&rsquo;ve forgetten to tell
<code>grep</code> what files to search in!</p>

<p>When <code>grep</code> is given only a pattern to search for and no files to search
in, it assumes we want to search for that pattern on stdin. This is
great for shell scripts and one-liners at the command-line, but it&rsquo;s
<strong>super</strong> annoying when we&rsquo;re just grepping interactively.</p>

<p>The thing is, it&rsquo;s super easy to detect when the user might have made
this mistake: if we&rsquo;re defaulting to reading from stdin <strong>and</strong> the file
corresponding to stdin represents a terminal (more specifically, a
<a href="https://unix.stackexchange.com/questions/4126/">tty</a>). And once we&rsquo;ve detected it, we can print a helpful message.</p>

<p>Here&rsquo;s how I did it when writing <a href="https://github.com/jez/diff-locs"><code>diff-locs</code></a>, one of the command-line
programs I&rsquo;ve been working on lately:</p>

<figure class='code'><figcaption><span>Check if stdin is a tty in Haskell</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fileIn</span> <span class="o">&lt;-</span> <span class="kr">case</span> <span class="n">inputStyle</span> <span class="kr">of</span>
</span><span class='line'>  <span class="kt">InputFromFile</span> <span class="n">filename</span> <span class="o">-&gt;</span> <span class="kt">IO</span><span class="o">.</span><span class="n">openFile</span> <span class="n">filename</span> <span class="kt">IO</span><span class="o">.</span><span class="kt">ReadMode</span>
</span><span class='line'>  <span class="kt">InputFromStdin</span>         <span class="o">-&gt;</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">isTTY</span> <span class="o">&lt;-</span> <span class="n">hIsTerminalDevice</span> <span class="kt">IO</span><span class="o">.</span><span class="n">stdin</span>
</span><span class='line'>    <span class="n">when</span> <span class="n">isTTY</span> <span class="o">$</span> <span class="kr">do</span>
</span><span class='line'>      <span class="n">errPutStrLn</span> <span class="s">"Warning: reading from stdin, which is a tty."</span>
</span><span class='line'>    <span class="n">return</span> <span class="kt">IO</span><span class="o">.</span><span class="n">stdin</span></span></code></pre></td></tr></table></div></figure>


<p>If we&rsquo;ve been given a file explicitly, just open it. Otherwise, fall
back to reading from stdin. But first, check if <code>IO.stdin</code> is a terminal
device and when it <strong>is</strong>, print a warning.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> The complete file
containing the snippet above is <a href="https://github.com/jez/diff-locs/blob/743bff5cb1abb6e405b0369b195614aea6ec018d/app/Main.hs#L17-L24">on GitHub</a>.</p>

<p>I&rsquo;ve implemented <code>diff-locs</code> as a standard Unix filter—it takes input on
stdin and emits output on stdout. Normal usage looks something like
this, where we pipe <code>git diff</code> into <code>diff-locs</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'>❯ git diff | diff-locs</span></code></pre></td></tr></table></div></figure>


<p>But if someone is just playing around at the terminal (maybe, trying to
get the help output to show up), they might run <code>diff-locs</code> without
args, and then be greeted with this message:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ diff-locs
</span><span class='line'>Warning: reading from stdin, which is a tty.
</span><span class='line'>█</span></code></pre></td></tr></table></div></figure>


<p>This is much better than just sitting there appearing to hang!</p>

<h2><code>isatty</code> in other languages</h2>

<p>The trick above works in pretty much every language that supports Unix
programming. Under the hood, the Haskell snippet above is powered by the
<code>isatty</code> function in the C standard library (<code>man 3 isatty</code>), which most
other languages wrap in some way. For example, three other languages I&rsquo;ve
done this in recently:</p>

<figure class='code'><figcaption><span>Ruby</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="no">STDIN</span><span class="p">.</span><span class="nf">isatty?</span>
</span><span class='line'>  <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s1">'Warning: reading from stdin, which is a tty.'</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>Bash</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">if</span> <span class="o">[</span> -t 0 <span class="o">]</span>; <span class="k">then
</span><span class='line'>  </span><span class="nb">echo</span> <span class="s1">'Warning: reading from stdin, which is a tty.'</span> &gt;&amp;2
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>OCaml</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">if</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">isatty</span> <span class="nn">Unix</span><span class="p">.</span><span class="n">stdin</span>
</span><span class='line'><span class="k">then</span> <span class="n">prerr_endline</span> <span class="s2">"Warning: reading from stdin, which is a tty."</span>
</span><span class='line'><span class="k">else</span> <span class="bp">()</span></span></code></pre></td></tr></table></div></figure>


<p>And again, a quick search for <code>isatty &lt;language&gt;</code> should suffice for any
language that supports Unix programming. It&rsquo;s little things like this
that add up and make certain command-line utilities delightful to use.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>We don&rsquo;t really need to check whether the file we&rsquo;re opening is a tty. If the user managed to pass in the <em>name</em> of a tty file, they probably know what they&rsquo;re doing.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Standard ML in Travis&nbsp;CI]]></title>
    <link href="https://blog.jez.io/sml-travis-ci/"/>
    <updated>2019-06-04T12:26:45-04:00</updated>
    <id>https://blog.jez.io/sml-travis-ci</id>
    <content type="html"><![CDATA[<p>For one of my recent projects (<a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a>) I went through the work to
get Standard ML building in Travis CI. It turned out to be not too
hard—in fact, the hardest part is already done, and I&rsquo;m happy to share
how it works.</p>

<!-- more -->


<h2>Features</h2>

<p>The way I set up my builds, I can:</p>

<ul>
<li>build and test with both macOS and Linux</li>
<li>build and test with both SML/NJ and MLton</li>
<li>create executables, even with SML/NJ</li>
<li>publish the resulting builds to GitHub as releases</li>
</ul>


<p>Apart from some scripts to install things on each operating system,
under the hood it&rsquo;s powered by <a href="https://github.com/jez/symbol">Symbol</a>, which is a build tool for
Standard ML I wrote which factors out most of the project-agnostic
stuff.</p>

<h2>The core setup</h2>

<p>Rather than paste the code into a snippet here and wait for it to get
out of date, see my <a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a> project on GitHub for all the
up-to-date files. In total, there are three files in that repo which set
the whole thing up:</p>

<ol>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/.travis.yml">.travis.yml</a> (kicks off the build)</li>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/Brewfile">Brewfile</a> (deps for macOS build)</li>
<li><a href="https://github.com/jez/multi-grep/blob/b6a42719b1ffca389556655982e6c4b7fa19c9a1/tests/travis-install.sh">tests/travis-install.sh</a> (deps for Linux build)</li>
</ol>


<p>If you haven&rsquo;t used Travis CI before, you&rsquo;ll probably also want to check
out the <a href="https://docs.travis-ci.com/">Travis CI docs</a> to get a feel for how to actually set things
up, and where these pieces fit in.</p>

<h2>Why write a whole build tool?</h2>

<p>I mentioned above that I&rsquo;d written a build tool for Standard ML, called
<a href="https://github.com/jez/symbol">Symbol</a>. Why? It started as a shell script + <code>Makefile</code> for
<a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a> and then I realized that these scripts could be useful in
any Standard ML project.</p>

<p>SML/NJ and MLton are already great compilers with their own build tools.
It&rsquo;s useful to be able to build a project with both (SML/NJ for faster
builds and a REPL, and MLton for faster compiled executables). All
Symbol really does is put SML/NJ and MLton behind a unified, very
stripped down interface.</p>

<p>There&rsquo;s more information <a href="https://github.com/jez/symbol">in the README</a>, but some key points:</p>

<ul>
<li>Symbol makes it easy to build and install executables, even with
SML/NJ which traditionally uses heap images.</li>
<li>Symbol is built on <code>make</code>, so if <strong>no</strong> source files change, even
recompiling with MLton is instant.</li>
<li>Symbol also supports scaffolding new Standard ML projects, which is
nicer than starting from scratch.</li>
</ul>


<p>Again, there&rsquo;s way more information <a href="https://github.com/jez/symbol">in the README</a>, so
definitely check it out if you&rsquo;re thinking about setting up a new
Standard ML project. The usage looks something like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># initialize a new project:</span>
</span><span class='line'>❯ symbol-new hello
</span><span class='line'>❯ <span class="nb">cd </span>hello
</span><span class='line'>
</span><span class='line'><span class="c"># build with SML/NJ:</span>
</span><span class='line'>❯ ./symbol make
</span><span class='line'>❯ .symbol-work/bin/hello
</span><span class='line'>Hello, world!
</span><span class='line'>
</span><span class='line'><span class="c"># or, build with MLton:</span>
</span><span class='line'>❯ ./symbol make <span class="nv">with</span><span class="o">=</span>mlton
</span><span class='line'>❯ .symbol-work/bin/hello
</span><span class='line'>Hello, world!</span></code></pre></td></tr></table></div></figure>


<h2>Why Standard ML in the first place?</h2>

<p>I&rsquo;ll probably get around to writing about <a href="https://github.com/jez/multi-grep"><code>multi-grep</code></a> (and related
tools like <a href="https://github.com/jez/diff-locs"><code>diff-locs</code></a> and <a href="https://github.com/jez/multi-sub"><code>multi-sub</code></a>) but at the end of the day:
SML is a really pleasant language to use in a lot of ways:</p>

<ul>
<li>Type inference in Standard ML is a breath of fresh air.</li>
<li>Data types let me wonder less about how things work.</li>
<li>Pattern matching makes for concise, clean, and correct code.</li>
</ul>


<p>Standard ML was my most commonly used programming language throughout
all of my university courses, so there&rsquo;s a definite soft spot in my
heart for it. There are features that I wish it had sometimes, but it&rsquo;s
the only language that I&rsquo;ve used that doesn&rsquo;t feel fundamentally broken
in some way.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling in Haskell for a 10x Speedup]]></title>
    <link href="https://blog.jez.io/profiling-in-haskell/"/>
    <updated>2019-05-19T15:13:34-04:00</updated>
    <id>https://blog.jez.io/profiling-in-haskell</id>
    <content type="html"><![CDATA[<p>I wrote up a toy project in Haskell and profiled it to learn about
Haskell&rsquo;s profiling tools and about profiling code in general.
Profiling in Haskell with Stack is super easy; to prove it I&rsquo;ll walk
through the problem I was trying to solve, my slow first solution, and
how I used Haskell&rsquo;s profiling tools to find and fix some egregiously
slow parts of the code.</p>

<!-- more -->


<p>I had three takeaways from this little project:</p>

<ul>
<li>Guessing at how to make code faster works sometimes, but:</li>
<li>profiling in Haskell is actually super painless, and is a way better
use of my time than guessing at what&rsquo;s slow.</li>
<li>With repeated profiling it&rsquo;s definitely possible to make reasonably
fast Haskell.</li>
</ul>


<p>The source code and profiling data for this project is all available
<a href="https://github.com/jez/bingo-sim">on GitHub</a>. Also the Appendix below has a bunch of links to
help you find the interesting parts of the code.</p>

<h2>Problem: simulating probabilities</h2>

<p>The problem I wanted to solve was to simulate the probability of winning
one carnival game I got to play while on vacation recently. The game
itself is super simple and purely luck-based. The rules:</p>

<ol>
<li>There&rsquo;s a 6 × 6 grid, each with a special character identifying it.</li>
<li>There are 36 tiles, each with a character matching one grid space
(and there are no duplicates, so all characters are accounted for).</li>
<li>Initially, all tiles are placed face down.</li>
<li>To play, a contestant chooses 15 of the 36 tiles and flips them
over.</li>
<li>The contestant then places the flipped tiles onto the correct spots.</li>
<li>If placing the 15 tiles forms a bingo in any row, column, or full
diagonal, it&rsquo;s a win. Otherwise, it&rsquo;s a loss.</li>
</ol>


<p>The game setup in real life looked something like this:</p>

<p><a href="https://blog.jez.io/images/taiwan-carnival-bingo.jpg"><img src="https://blog.jez.io/images/taiwan-carnival-bingo.jpg" alt="Taiwan Carnival Bingo" /></a></p>

<p>(<a href="https://www.b-kyu.com/2014/07/hua-yuan-night-market-tainan-taiwan.html">Image credit</a>)</p>

<p>My question was: how lucky should we considider ourselves if we win?
I&rsquo;m sure I could have answered this exactly with some combinatorics, but
that seemed boring. Instead, I wanted to write a program solve it:
generate random boards, and check how many of them have bingos.</p>

<h2>Naive solution</h2>

<p>In the course of playing around with this problem, I implemented a bunch
of different solutions—about 5 in total, each one faster than the last.
At a high level, each solution followed this pattern:</p>

<ul>
<li>generate a board uniformly at random</li>
<li>count how many of the generated boards had bingos</li>
</ul>


<p>All the solutions exploited the fact that we don&rsquo;t care where the
characters on the board are nor what characters are on the tiles. The
only thing that matters is whether a tile ends up on a specific grid
space, which means boards can just be vectors of bits.</p>

<p><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> was <em>really</em> slow, so we won&rsquo;t talk about it 😅</p>

<p><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was a little bit faster (but not by much, which made me
disappointed—more on this later). The solution looked like this:</p>

<ul>
<li><p>Our 6 × 6 grids are represented as bit-matrices in row-major order, so
we can store them in a 64-bit unsigned int (<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Word.html#t:Word64"><code>Word64</code></a>) and only use
the 36 least significant bits. A <code>1</code> on our board means &ldquo;one of the 15
tiles we picked matched this grid spot.&rdquo;</p></li>
<li><p>To generate a random board, we start with a board of 15 consecutive
<code>1</code>&rsquo;s (<code>0x7fff</code>) and then use the <a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> to shuffle
the bits amongst the 36 available bits.</p>

<p>Fisher-Yates shuffle is actually really simple, which is nice.
Here&rsquo;s the <a href="https://github.com/jez/bingo-sim/blob/8886a66/src/BingoSim/Simulation.hs#L111-L126">six lines</a> to implement it in Haskell
on a bit vector:</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">shuffleBits</span> <span class="o">::</span> <span class="kt">RandomGen</span> <span class="n">g</span> <span class="o">=&gt;</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="kt">Board</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Board</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="n">board</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
</span><span class='line'>  <span class="c1">-- (Maybe) swap the current MSB with one of the lesser bits</span>
</span><span class='line'>  <span class="kr">let</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">gen'</span><span class="p">)</span> <span class="o">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">gen</span>
</span><span class='line'>      <span class="n">bs'</span>       <span class="o">=</span> <span class="n">swapBits</span> <span class="n">bs</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">i</span>
</span><span class='line'>  <span class="c1">-- Recurse on the lesser bits</span>
</span><span class='line'>  <span class="kr">in</span>  <span class="n">shuffleBits</span> <span class="n">gen'</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs'</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>With the above method, we generate 100,000 random boards using and
check how many boards have at least one bingo.</li>
</ul>


<h2>Clever, but not in the right ways</h2>

<p>All told, I thought the approach in <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> was pretty clever. It
used a single <code>Word64</code> (instead of a larger structure like a list) to
represent the board, so it shouldn&rsquo;t have had needed many allocations.
And because it was just a <code>Word64</code>, it could use bit operations to
manipulate the board and check for bingos, avoiding the need to walk a
large structure.</p>

<p>But when I ran this on my 2017 MacBook Pro (i7-7920HQ CPU @ 3.10GHz, 16
GB memory), it was still really slow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3529
</span><span class='line'>Hit rate: 0.03529
</span><span class='line'>  0.71s user  0.02s system  98% cpu  0.738 total</span></code></pre></td></tr></table></div></figure>


<p>(Note that we&rsquo;re running <code>time</code> on the compiled binary directly, instead
of running with <code>stack exec --</code>; we don&rsquo;t care for the overhead from
running via Stack).</p>

<p>So even after using a bit vector for the board, it took 738ms. To be
clear, these results for <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> were an improvement over my even
slower <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>, but not by much—maybe by 200ms. 700ms+ seemed
excessive.</p>

<h2>How to profile Haskell code</h2>

<p>Determined to make it faster, at this point I resigned myself from
guessing and looked up how to profile Haskell code. Turns out, with
Stack it&rsquo;s <strong>super</strong> simple:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Rebuild with profiling information</span>
</span><span class='line'>❯ stack build --profile
</span><span class='line'>
</span><span class='line'><span class="c"># Run the code with runtime profiling enabled</span>
</span><span class='line'>❯ stack <span class="nb">exec</span> -- bingo-sim 100000 +RTS -p -RTS</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s all it took, and it generated a <code>bingo-sim.prof</code> file that had a
bunch of lines that <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">looked like this</a>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>COST CENTRE              MODULE  SRC  no.  entries  %time %alloc   %time %alloc
</span><span class='line'>...
</span><span class='line'>  randomR                ...     ...  ...  ...       0.8    0.0    84.9   83.5
</span><span class='line'>  randomIvalIntegral     ...     ...  ...  ...       6.9   13.4    84.1   83.5
</span><span class='line'>   randomIvalInteger     ...     ...  ...  ...      21.3   29.2    77.2   70.1
</span><span class='line'>    randomIvalInteger.f  ...     ...  ...  ...      11.0    2.4    41.5   31.5</span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s a bunch of extra information in the actual <code>.prof</code> file (which
you can <a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof#L112-L115">see on GitHub</a>) but the important parts for
me were the four columns at the end. The first two are the proporion of
execution time and allocated memory attributable to this cost center
specifically. The last two are the same, but summed over all child cost
centers.</p>

<p>(I found the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">GHC User Guide</a> <em>super</em> helpful to learn everything I
wanted to know: what the columns mean, what a cost center is, and some
tips for profiling in general).</p>

<p>So the glaring realization in the data: we&rsquo;re spending 85% of our 738ms
running time <strong>generating random numbers</strong>. All my effort spent
optimizing memory, but it was the PRNG that was slow the whole time. 😣</p>

<h2>Fast PRNG in Haskell</h2>

<p>738ms × 0.849 ≈ 600ms+ spent generating random numbers seemed like an
absurd abount of time. Non-cryptographically secure pseudo random number
generation shouldn&rsquo;t take this long. And indeed, after a bit of
searching I came across <a href="https://www.reddit.com/r/haskell/comments/7ma9rd/in_your_professional_experience_how_suitable_is/">this reddit thread</a> complaining about how slow
<code>System.Random</code> in Haskell is for PRNG, and then moments later I found
<a href="https://nullprogram.com/blog/2017/09/21/">this article</a> from Chris Wellons comparing various PRNGs for
performance&hellip; Exactly what I was looking for 👌</p>

<p>So for <a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a>, I took his <a href="http://xoshiro.di.unimi.it/">suggested PRNG</a> and ported it from
<a href="http://xoshiro.di.unimi.it/xoshiro256starstar.c">C</a> to <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs">Haskell</a>.</p>

<p>And lo and behold, it was faster. A lot faster:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3670
</span><span class='line'>Hit rate: 0.0367
</span><span class='line'>  0.11s user  0.01s system  90% cpu  0.126 total</span></code></pre></td></tr></table></div></figure>


<p>Yep. That just went from 738ms to 126ms, for a 5.8x speedup 🤯</p>

<p>With a result this good, we might ask ourselves what we had to give up
in the process—things this good usually come at a price. The biggest one
that I notice is that the API I provide for random number generation is
far less generic.</p>

<p>My <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> is a direct translation of the C to Haskell. It
only generates 64-bit unsigned ints. <code>System.Random</code> has an arguably
nicer API, using type classes to generate random ints, characters, etc.,
allowing users to implement generators for their custom types, and
having helpers for generating random values within a range and sequences
of random numbers.</p>

<p>It&rsquo;s possible we could prune some of the fat from <code>System.Random</code>&rsquo;s
default implementations (without also changing the underlying random
number generator) and see a considerable speedup. It&rsquo;s also possible we
could make <a href="https://github.com/jez/bingo-sim/blob/0a04839/src/BingoSim/Prng.hs"><code>Prng.hs</code></a> export instances of the appropriate type
classes, and again see a speedup.</p>

<p>But considering that I wasn&rsquo;t using any of that extra stuff, I figured
I&rsquo;d just keep it simple. The code to generate random boards hardly
changed:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">shuffleBits</span> <span class="o">::</span> <span class="kt">Prng</span><span class="o">.</span><span class="kt">State</span> <span class="o">-&gt;</span> <span class="kt">Board</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Board</span><span class="p">,</span> <span class="kt">Prng</span><span class="o">.</span><span class="kt">State</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="n">board</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
</span><span class='line'><span class="n">shuffleBits</span> <span class="n">gen</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">n'</span>           <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
</span><span class='line'>      <span class="p">(</span><span class="n">rand</span><span class="p">,</span> <span class="n">gen'</span><span class="p">)</span> <span class="o">=</span> <span class="n">next</span> <span class="n">gen</span>
</span><span class='line'>      <span class="c1">-- Uses `mod` instead of `randomR` to generate within a range</span>
</span><span class='line'>      <span class="n">i</span>            <span class="o">=</span> <span class="n">rand</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>      <span class="n">bs'</span>          <span class="o">=</span> <span class="n">swapBits</span> <span class="n">bs</span> <span class="n">n'</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>  <span class="n">shuffleBits</span> <span class="n">gen'</span> <span class="p">(</span><span class="kt">Board</span> <span class="n">bs'</span><span class="p">)</span> <span class="n">n'</span></span></code></pre></td></tr></table></div></figure>


<h2>Further speedups</h2>

<p>Spurred on by the thrill of the previous speedup, I kept going. By this
time I&rsquo;d learned the value in following the <code>.prof</code> output. The output
led me to <a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a>, which refactored the PRNG into CPS avoid
allocating a tuple, and then <a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a>, where I added some
<code>BangPatterns</code>.</p>

<p>At the end of it all, my simulation ran in just 70ms!</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>❯ time .stack-work/install/x86_64-osx/lts-13.21/8.6.5/bin/bingo-sim 100000
</span><span class='line'>Trials:   100000
</span><span class='line'>Bingos:   3670
</span><span class='line'>Hit rate: 0.0367
</span><span class='line'>  0.06s user   0.01s system   92% cpu   0.070 total</span></code></pre></td></tr></table></div></figure>


<p>This is a 10x speedup over my dissapointing <a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a>, and a 12.8x
speedup over my super naive <a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a>. Not bad for a first attempt at
profiling in Haskell!</p>

<p>I found this super encouraging. Given how easy the tooling is to get
started with, how well documented things are, and my satisfaction with
the results, I&rsquo;m very likely to reach for profiling tools in the future.</p>

<h2>Appendix: Links</h2>

<p>The entire source is <a href="https://github.com/jez/bingo-sim">on GitHub</a>.</p>

<p>I wrote up all five of my attepts as separate GitHub commits, so if you
want to compare and constrast the approaches feel free:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/commit/994481b">Attempt #1</a> (899ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/8886a66#diff-35f3000e895e431b9c8e3b6454eadca5">Attempt #2</a> (738ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/0a04839">Attempt #3</a> (126ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/4048469">Attempt #4</a> (101ms)</li>
<li><a href="https://github.com/jez/bingo-sim/commit/eafa39f">Attempt #5</a> (70ms)</li>
</ul>


<p>I also had never used Haddock before, so I used this project as an
opportunity to learn how to build and write Haddock. I published the
docs on GitHub pages if you want to browse them:</p>

<ul>
<li><a href="https://jez.io/bingo-sim/">Docs</a></li>
</ul>


<p>And I also put the source for all the <code>.prof</code> files I generated for each
attempt:</p>

<ul>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.1.prof"><code>bingo-sim.1.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.2.prof"><code>bingo-sim.2.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.3.prof"><code>bingo-sim.3.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.4.prof"><code>bingo-sim.4.prof</code></a></li>
<li><a href="https://github.com/jez/bingo-sim/blob/master/prof/bingo-sim.5.prof"><code>bingo-sim.5.prof</code></a></li>
</ul>


<p>If you have any questions about anything, feel free to <a href="https://jez.io/">reach out</a>!</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concurrent Programming in ML: A Race]]></title>
    <link href="https://blog.jez.io/cpml-race/"/>
    <updated>2018-07-18T00:23:23-04:00</updated>
    <id>https://blog.jez.io/cpml-race</id>
    <content type="html"><![CDATA[<p>Lately I&rsquo;ve been super interested in language models for concurrency,
after hearing a fascinating talk from Adam Solove on <a href="https://medium.com/@asolove/synchronizable-abstractions-for-understandable-concurrency-64ae57cd61d1">synchronizable
abstractions for UI</a>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> I&rsquo;ve been working my way through a
handful of books, including <a href="https://simonmar.github.io/pages/pcph.html">PCPH</a>, the Concurrency section of <a href="http://www.cs.cmu.edu/~rwh/pfpl.html">PFPL</a>,
and most recently <a href="http://www.cambridge.org/gb/academic/subjects/computer-science/distributed-networked-and-mobile-computing/concurrent-programming-ml?format=AR">Concurrent Programming in ML</a>, by John Reppy.</p>

<p>In particular, I think I&rsquo;ve found a race condition in one of the code
listings of Concurrent Programming in ML. After introducing the listing
itself, we&rsquo;ll walk through a trace that shows the errant behavior, then
propose a small change that prevents it from happening.</p>

<h2>Setup: Snippets from the Book</h2>

<p>Before we begin, here&rsquo;s the listing in full. It&rsquo;s a sample
implementation of a 1-element concurrent buffer, using condition
variables. It supports creation, insertion, and removal.</p>

<figure class='code'><figcaption><span>Concurrent Programming in ML, Listing 2.3</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">buffer</span> <span class="p">=</span> <span class="nc">BUF</span> <span class="kr">of</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">data</span>      <span class="p">:</span> <span class="nd">'a</span> <span class="n">option</span> <span class="n">ref</span><span class="p">,</span>
</span><span class='line'>  <span class="n">mu</span>        <span class="p">:</span> <span class="n">mutex</span><span class="p">,</span>
</span><span class='line'>  <span class="n">dataAvail</span> <span class="p">:</span> <span class="n">condition</span><span class="p">,</span>
</span><span class='line'>  <span class="n">dataEmpty</span> <span class="p">:</span> <span class="n">condition</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">buffer</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span> <span class="kr">val</span> <span class="n">mu</span> <span class="p">=</span> <span class="n">mutex</span><span class="p">()</span> <span class="kr">in</span>
</span><span class='line'>    <span class="n">BUF</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">data</span>      <span class="p">=</span> <span class="n">ref</span> <span class="n">NONE</span><span class="p">,</span>
</span><span class='line'>      <span class="n">mu</span>        <span class="p">=</span> <span class="n">mu</span><span class="p">,</span>
</span><span class='line'>      <span class="n">dataAvail</span> <span class="p">=</span> <span class="n">condition</span> <span class="n">mu</span><span class="p">,</span>
</span><span class='line'>      <span class="n">dataEmpty</span> <span class="p">=</span> <span class="n">condition</span> <span class="n">mu</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">insert</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">},</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="n">NONE</span> <span class="p">=</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>      <span class="p">|</span> <span class="nc">waitLp</span> <span class="p">(</span><span class="n">SOME</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataEmpty</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">))</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">remove</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">})</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="n">NONE</span> <span class="p">=</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataAvail</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">))</span>
</span><span class='line'>      <span class="p">|</span> <span class="nc">waitLp</span> <span class="p">(</span><span class="n">SOME</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">NONE</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataEmpty</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">end</span></span></code></pre></td></tr></table></div></figure>


<p>You might also want to reference this exerpt which explains the
semantics of the concurrency primitives at play in the snippet above:
locks and condition variables. Study the listing above and exerpt below
for a moment. See if you can spot a race, or are convinced the code is
correct.</p>

<blockquote><p>The semantics of the expression</p>

<p><code>withLock mu f x</code></p>

<p>are that first the lock mu is acquired, then the function f is applied
to x, and then the function&rsquo;s result is returned after releasing the
lock.</p>

<p>The basic operations on condition variables are</p>

<p><code>val wait : condition -&gt; unit</code></p>

<p>which causes a process to block on the condition variable, and</p>

<p><code>val signal : condition -&gt; unit</code></p>

<p>which wakes up one waiting process. A condition variable is associated
with a specific mutex lock, which must be held when performing a wait
operation on the variable. The semantics of the wait operation are
that the mutex lock is released, and then the process is blocked; when
the condition is signaled, the next process in the condition&rsquo;s waiting
queue is unblocked and it reacquires the mutex lock and proceeds. A
signal operation on a condition variable that has an empty waiting
queue has no effect; in this sense condition variables are memoryless.</p>

<p>&mdash; <em>Concurrent Programming in ML</em>, section 2.4.2</p></blockquote>

<h2>A trace to expose the problem</h2>

<p>The problem I see has to do with SML&rsquo;s eager evaluation: before calling
a function <code>f e</code>, we evaluate <code>e</code> to a value <code>v</code>. Then substitution
kicks in and we substitute <code>v</code> into the body of <code>f</code>. For us,
that means that in the definition of <code>insert</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">fun</span> <span class="nf">insert</span> <span class="c">(*</span><span class="cm"> ··· *)</span> <span class="p">=</span>
</span><span class='line'>  <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'>  <span class="c">(*</span><span class="cm"> ··· *)</span></span></code></pre></td></tr></table></div></figure>


<p>we evaluate <code>!data</code> to a value before we run the body of <code>withLock</code> to
acquire the lock. When inserting into an empty queue, <code>!data</code> evaluates
to <code>NONE</code>. And since this happens outside the <code>withLock</code> if two calls to
insert attempt to acquire the lock at the same time, they&rsquo;ll both think
the queue is empty when they wake up! When this happens, the one to wake
up second will unknowingly overwrite what the first one inserted.</p>

<p>Here&rsquo;s a sample trace of a program allocating a buffer and then
doing two concurrent insertions:</p>

<figure class='code'><figcaption><span>Sample trace, showing that first insert gets dropped</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="c">(*</span><span class="cm"> '=&gt;' marks steps where two threads evolve concurrently  *)</span>
</span><span class='line'><span class="c">(*</span><span class="cm"> '-&gt;' marks steps where just one thread evalautes        *)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-&gt;</span> <span class="kr">val</span> <span class="nv">buf</span> <span class="p">=</span> <span class="n">buffer</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> Fork two threads; both have access to 'buf'.            *)</span>
</span><span class='line'>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 *)</span>                       <span class="c">(*</span><span class="cm"> thread 2 *)</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">insert</span> <span class="n">buf</span> <span class="mi">1</span>                         <span class="n">insert</span> <span class="n">buf</span> <span class="mi">2</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>           <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">(</span><span class="n">!data</span><span class="p">)</span>
</span><span class='line'><span class="p">=&gt;</span> <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="n">NONE</span>              <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 acquires lock *)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="mi">1</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> {data = ref (SOME 1), ...} *)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">(();</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="n">signal</span> <span class="n">dataAvail</span>
</span><span class='line'><span class="p">-&gt;</span> <span class="p">()</span>
</span><span class='line'>   <span class="c">(*</span><span class="cm"> thread 1 releases lock *)</span>
</span><span class='line'>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> thread 2 acquires lock *)</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> NONE is now stale! *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="n">waitLp</span> <span class="n">NONE</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> selects wrong case in function *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="mi">2</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>                                        <span class="c">(*</span><span class="cm"> ==&gt; data = ref (SOME 2) *)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">(();</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="n">signal</span> <span class="n">dataAvail</span>
</span><span class='line'><span class="p">-&gt;</span>                                      <span class="p">()</span></span></code></pre></td></tr></table></div></figure>


<p>Notice how the stale read allowed two consecutive inserts. What we
wanted was for the second insert to wake up, see that the buffer is
full, then wait for the <code>dataEmpty</code> condition variable to wake it up.
So having the <code>!data</code> outside the lock is not good.</p>

<h2>Fixing the stale read</h2>

<p>The solution to this is to delay evaluating <code>!data</code> until the body of the
<code>waitLp</code> function, which only executes when we have the lock. This
ensures that we don&rsquo;t read a stale value for the content of the buffer.</p>

<figure class='code'><figcaption><span>Listing 2.3, updated to avoid race</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">buffer</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'><span class="nc">fun</span> <span class="n">buffer</span> <span class="p">()</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">insert</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">},</span> <span class="n">v</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="c">(*</span><span class="cm"> !data is now within waitLp, so it's never stale. *)</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>      <span class="kr">case</span> <span class="n">!data</span>
</span><span class='line'>        <span class="kr">of</span> <span class="n">NONE</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">SOME</span> <span class="n">v</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataAvail</span><span class="p">)</span>
</span><span class='line'>         <span class="p">|</span> <span class="nc">SOME</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataEmpty</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">())</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">()</span>
</span><span class='line'>  <span class="kr">end</span>
</span><span class='line'>
</span><span class='line'><span class="kr">fun</span> <span class="n">remove</span> <span class="p">(</span><span class="n">BUF</span> <span class="p">{</span><span class="n">data</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">dataAvail</span><span class="p">,</span> <span class="n">dataEmpty</span><span class="p">})</span> <span class="p">=</span>
</span><span class='line'>  <span class="kr">let</span>
</span><span class='line'>    <span class="kr">fun</span> <span class="n">waitLp</span> <span class="p">()</span> <span class="p">=</span>
</span><span class='line'>      <span class="kr">case</span> <span class="n">!data</span>
</span><span class='line'>        <span class="kr">of</span> <span class="n">NONE</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">wait</span> <span class="n">dataAvail</span><span class="p">;</span> <span class="n">waitLp</span> <span class="p">())</span>
</span><span class='line'>         <span class="p">|</span> <span class="nc">SOME</span> <span class="n">v</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">data</span> <span class="n">:=</span> <span class="n">NONE</span><span class="p">;</span> <span class="n">signal</span> <span class="n">dataEmpty</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">in</span>
</span><span class='line'>    <span class="n">withLock</span> <span class="n">mu</span> <span class="n">waitLp</span> <span class="p">()</span>
</span><span class='line'>  <span class="kr">end</span></span></code></pre></td></tr></table></div></figure>


<p>Pretty small bug, and it doesn&rsquo;t detract from the main point of the
listing, which is to show how to use condition variables in a sort of
&ldquo;mutually recursive&rdquo; style where <code>dataEmpty</code> wakes up <code>insert</code> which
signals on <code>dataAvail</code> which wakes up <code>remove</code>.</p>

<p>This also underscores how difficult it really is to ensure correctness
in the presence of concurrency! That&rsquo;s exactly why I&rsquo;ve been reading
about all these language models for concurrency, to better understand
how we can leverage our programming language to ensure our programs are
correct by construction.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Unfortunately, the talk isn&rsquo;t online (Adam presented it at work), so the blog post linked above is the next best thing!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prefer .then() over .catch()]]></title>
    <link href="https://blog.jez.io/prefer-then-over-catch/"/>
    <updated>2018-05-31T18:58:52-04:00</updated>
    <id>https://blog.jez.io/prefer-then-over-catch</id>
    <content type="html"><![CDATA[<p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<figure class='code'><figcaption><span>Bad code; don&#8217;t do this</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// "Success" and "failure" types (definitions omitted)</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">OkResult</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve(...) when it worked, but</span>
</span><span class='line'>    <span class="c1">// cal reject(...) when it failed.</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span></span></code></pre></td></tr></table></div></figure>


<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">ErrResult</span> <span class="o">=</span> <span class="nx">string</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// number, not a string!</span>
</span><span class='line'><span class="nx">reject</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></span></code></pre></td></tr></table></div></figure>


<p>nor from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// boolean, not a string!</span>
</span><span class='line'><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...);</span></span></code></pre></td></tr></table></div></figure>


<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<figure class='code'><figcaption><span>Better code than before</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Helper function for exhaustiveness.</span>
</span><span class='line'><span class="c1">// See here: https://blog.jez.io/flow-exhaustiveness/</span>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">absurd</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/absurd'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Use a union type to mean "success OR failure"</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">Result</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'ok'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">OkResult</span><span class="o">|</span><span class="p">}</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'err'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">ErrResult</span><span class="o">|</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//     Use our new union type ──┐</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">Result</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'ok',  val: ...}) when it worked, and</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'err', val: ...}) when it failed</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="c1">// Use a switch statement in the result:</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'ok'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'err'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// Guarantees we covered all cases.</span>
</span><span class='line'>        <span class="nx">absurd</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">})</span></span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// If I know that throwNumber will always call `reject` with a</span>
</span><span class='line'><span class="c1">// number, I can stop the loose types from propagating further</span>
</span><span class='line'><span class="c1">// with an explicit annotation:</span>
</span><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── explicit annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span></span></code></pre></td></tr></table></div></figure>


<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── defensive annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="s1">'number'</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Reports misbehavior to an imaginary observability service</span>
</span><span class='line'>      <span class="nx">tracker</span><span class="p">.</span><span class="nx">increment</span><span class="p">(</span><span class="s1">'throwNumber.unexpected_input'</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span></span></code></pre></td></tr></table></div></figure>




<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Union Types in Flow & Reason]]></title>
    <link href="https://blog.jez.io/union-types-flow-reason/"/>
    <updated>2018-04-19T01:43:26-04:00</updated>
    <id>https://blog.jez.io/union-types-flow-reason</id>
    <content type="html"><![CDATA[<p>Union types are powerful yet often overlooked. At work, I&rsquo;ve been using
Flow which <a href="https://flow.org/en/docs/types/unions/">thankfully supports union types</a>. But as I&rsquo;ve
refactored more of our code to use union types, I&rsquo;ve noticed that our
bundle size has been steadily increasing!</p>

<!-- more -->


<p>In this post, we&rsquo;re going to explore why that&rsquo;s the case. We&rsquo;ll start
with a problem which union types can solve, flesh out the problem to
motivate why union types are definitely the solution, then examine the
resulting cost of introducing them. In the end, we&rsquo;ll compare Flow to
other compile-to-JS languages on the basis of how they represent union
types in the compiled output. I&rsquo;m especially excited about <a href="https://reasonml.github.io/">Reason</a>, so
we&rsquo;ll talk about it the most.</p>

<h2>Setup: Union Types in a React Component</h2>

<p>Let&rsquo;s consider we&rsquo;re writing a simple React 2FA<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> modal.
We&rsquo;ll be using Flow, but you can pretend it&rsquo;s TypeScript if you want.
The mockup we were given looks like this:</p>

<p><a href="https://blog.jez.io/images/2fa-mockup.jpeg"><img src="https://blog.jez.io/images/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>

<p>In this mockup:</p>

<ul>
<li>There&rsquo;s a loading state while we send the text message.</li>
<li>We&rsquo;ll show an input for the code after the message is sent.</li>
<li>There&rsquo;s no failure screen (it hasn&rsquo;t been drawn up yet).</li>
</ul>


<p>We&rsquo;ll need some way for our component to know which of the three screens
is visible. Let&rsquo;s use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Union types are a perfect fit! 🎉  Union types document intent and can
help guard against mistakes. Fellow developers and our compiler can
know &ldquo;these are all the cases.&rdquo; In particular, Flow can warn us when
we&rsquo;ve <a href="https://blog.jez.io/flow-exhaustiveness/">forgotten a case</a>.</p>

<p>Our initial implementation is working great. After sharing it with the
team, someone suggests adding a &ldquo;cancel&rdquo; button in the top corner. It
doesn&rsquo;t make sense to cancel when the flow has already succeeded, so
we&rsquo;ll exclude it from the last screen:</p>

<p><a href="https://blog.jez.io/images/2fa-close-btn.jpeg"><img src="https://blog.jez.io/images/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>

<p>No problem: let&rsquo;s write a function called <code>needsCancelButton</code> to
determine if we need to put a cancel button in the header of a
particular screen:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Recall: 'SuccessScreen' is the last screen,</span>
</span><span class='line'>  <span class="c1">// so it shouldn't have a cancel button.</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Short and sweet. 👌 Everything seems to be working great, until&hellip;</p>

<h2><code>switch</code>: Optimizing for Exhaustiveness</h2>

<p>The next day, we get some updated mocks from the design team. This time,
they&rsquo;ve also drawn up a &ldquo;failure&rdquo; screen for when the customer has
entered the wrong code too many times:</p>

<p><a href="https://blog.jez.io/images/2fa-failure-screen.jpeg"><img src="https://blog.jez.io/images/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>

<p>We can handle this&mdash;we&rsquo;ll just add a case to our <code>Screen</code> type:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">Screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'LoadingScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'CodeEntryScreen'</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'SuccessScreen'</span>
</span><span class='line'>  <span class="c1">// New case to handle too many wrong attempts:</span>
</span><span class='line'>  <span class="o">|</span> <span class="s1">'FailureScreen'</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>But now <strong>there&rsquo;s a bug</strong> in our <code>needsCancelButton</code> function. 😧 We
should only show a close button on screens where it makes sense, and
<code>'FailureScreen'</code> is not one of those screens. Our first reaction after
discovering the bug would be to just blacklist <code>'FailureScreen'</code> too:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span> <span class="o">||</span>
</span><span class='line'>    <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'FailureScreen'</span>
</span><span class='line'>  <span class="p">);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>But we can do better than just fixing the <strong>current</strong> bug. We should
write code so that when we add a new case to a union type, our type
checker alerts us before a <strong>future</strong> bug even happens. What if instead
of a silent bug, we got this cheery message from our type checker?</p>

<blockquote><p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new
screen you added. <em>🙂</em></p>

<p>&mdash; your friendly, neighborhood type checker</p></blockquote>

<p>Let&rsquo;s go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell
us this when adding new cases. We&rsquo;ll use a <code>switch</code> statement with
<a href="https://blog.jez.io/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="na">screen</span><span class="p">:</span> <span class="nx">Screen</span><span class="p">):</span> <span class="kr">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="c1">// (I named this function 'absurd' in my earlier post:</span>
</span><span class='line'>      <span class="c1">// https://blog.jez.io/flow-exhaustiveness/)</span>
</span><span class='line'>      <span class="c1">// This function asks Flow to check for exhaustiveness.</span>
</span><span class='line'>      <span class="c1">//</span>
</span><span class='line'>      <span class="c1">// [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow →)</strong></a></p>

<p>Now Flow is smart enough to give us an error! Making our code safer, one
<code>switch</code> statement at a time. 😅 Union types in Flow are a powerful way
to use types to guarantee correctness. But to get the most out of union
types, <strong>always<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> access them</strong> through a <code>switch</code> statement.
Every time we use a union type without an exhaustive switch statement,
we make it harder for Flow to tell us where we&rsquo;ve missed something.</p>

<h2>Correctness, but at what cost?</h2>

<p>You might not have noticed, but we paid a subtle cost in rewriting
our <code>needsCancelButton</code> function. Let&rsquo;s compare our two functions:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ----- before: 62 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">screen</span> <span class="o">!==</span> <span class="s1">'SuccessScreen'</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ----- after: 240 bytes (minified) -----</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'SuccessScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>With just an equality check, our function was small: 62 bytes minified.
But when we refactored to use a <code>switch</code> statement, its size shot up to
240 bytes! That&rsquo;s a 4x increase, just to get exhaustiveness. Admittedly,
<code>needsCancelButton</code> is a bit of a pathological case. But in general: as
we make our code bases <strong>more safe</strong> using Flow&rsquo;s union types of string
literals, our <strong>bundle size bloats</strong>!</p>

<h2>Types and Optimizing Compilers</h2>

<p>One of the many overlooked promises of types is the claim that by
writing our code with <strong>higher-level abstractions</strong>, we give more
information to the compiler. The compiler can then generate code that
captures our original intent, but as efficiently as possible.</p>

<p>Flow is decidedly <strong>not</strong> a compiler: it&rsquo;s only a type checker. To run
JavaScript annotated with Flow types, we first strip the types (with
something like Babel). All information about the types vanishes when we
run the code.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> What can we achieve if we were to <strong>keep the
types around</strong> all the way through compilation?</p>

<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the
benefits of the OCaml tool chain to the web. In particular, Reason
works using OCaml&rsquo;s mature optimizing compiler alongside BuckleScript
(which turns OCaml to JavaScript) to emit great code.</p>

<p>To see what I mean, let&rsquo;s re-implement our <code>Screen</code> type and
<code>needsCancelButton</code> function, this time in Reason:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">screen</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">let</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="p">(</span><span class="nx">screen</span><span class="p">:</span> <span class="nx">screen</span><span class="p">):</span> <span class="nx">bool</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">LoadingScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">CodeEntryScreen</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nx">SuccessScreen</span> <span class="o">=&gt;</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p>Looks pretty close to JavaScript with Flow types, doesn&rsquo;t it? The
biggest difference is that the <code>case</code> keyword was replaced with the <code>|</code>
character. Making the way we define and use union types look the same is
a subtle reminder to always pair union types with <code>switch</code> statements!
<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> Another difference: Reason handles exhaustiveness checking
out of the box. 🙂</p>

<p>What does the Reason output look like?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE</span>
</span><span class='line'><span class="s1">'use strict'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nx">screen</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason →)</strong></a></p>

<p>Not bad! Telling Reason that our function was exhaustive let it optimize
the entire <code>switch</code> statement back down to a single <code>if</code> statement. In
fact, it gets even better: when we run this through <code>uglifyjs</code>, it
removes the redundant <code>true</code> / <code>false</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">function</span> <span class="nx">needsCancelButton</span><span class="p">(</span><span class="nx">n</span><span class="p">){</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">n</span><span class="o">&gt;=</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code>
statement. Reason compiled what used to be a string literal
<code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely
because custom-defined types in Reason <strong>aren&rsquo;t</strong> strings, so it doesn&rsquo;t
matter if the names get mangled.</p>

<p>Taking a step back, Reason&rsquo;s type system delivered on the promise of
types in a way Flow couldn&rsquo;t:</p>

<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about our code&rsquo;s
correctness via exhaustiveness.</li>
<li>The compiler translated that all to tiny, performant output.</li>
</ul>


<p>I&rsquo;m really excited about Reason. 😄 It has a delightful type system and
is backed by a decades-old optimizing compiler tool chain. I&rsquo;d love to
see more people take advantage of improvements in type systems to write
better code!</p>

<hr />

<h2>Appendix: Other Compile-to-JS Runtimes</h2>

<p>The above analysis only considered Flow + Babel and Reason. But then I
got curious about how other typed languages that compile to JavaScript
compare on the optimizations front:</p>

<h3>TypeScript</h3>

<p>Despite being a language <strong>and</strong> compiler, TypeScript maintains a
goal of compiling to JavaScript that closely resembles the source
TypesScript code. TypeScript has three language constructs for working
with exhaustiveness:</p>

<ol>
<li>union types (identical to the Flow unions that we&rsquo;ve been talking
about),</li>
<li><code>enum</code>s, which are sort of like definition a group of variable
constants all at once, and</li>
<li><code>const enum</code>s which are like <code>enum</code>s except that they&rsquo;re represented
more succinctly in the compiled output.</li>
</ol>


<p>TypeScript&rsquo;s union type over string literals are represented the same
way as Flow, so I&rsquo;m going to skip (1) and focus instead on (2) and (3).</p>

<p>TypeScript&rsquo;s <code>enum</code> and <code>const enum</code> are subtly different. Not having
used the language much, I&rsquo;ll refer you to <a href="https://www.typescriptlang.org/docs/handbook/enums.html">the TypeScript
documentation</a> to learn more about the differences. But for
sure, <code>const enum</code>s compile much better than normal <code>enum</code>s.</p>

<p>Here&rsquo;s what normal <code>enum</code>s look like in TypeScript&mdash;they&rsquo;re <strong>even
worse</strong> than unions of string literals:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">Screen_</span><span class="p">;</span>
</span><span class='line'><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">Screen_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"LoadingScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"LoadingScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"CodeEntryScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"CodeEntryScreen"</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">Screen_</span><span class="p">[</span><span class="nx">Screen_</span><span class="p">[</span><span class="s2">"SuccessScreen"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"SuccessScreen"</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="nx">Screen_</span> <span class="o">||</span> <span class="p">(</span><span class="nx">Screen_</span> <span class="o">=</span> <span class="p">{}));</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">LoadingScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">CodeEntryScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="nx">Screen_</span><span class="p">.</span><span class="nx">SuccessScreen</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground →</strong></a></p>

<p>So for normal <code>enum</code>s:</p>

<ul>
<li>It&rsquo;s not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of
enum values at run time, in a format that doesn&rsquo;t minify well.</li>
</ul>


<p>And then here&rsquo;s what <code>const enum</code>s look like&mdash;you can see that
TypeScript represents them under the hood without any sort of <code>Screen_</code>
object:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">impossible</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This case is impossible.'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">screen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">0</span> <span class="cm">/* LoadingScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">1</span> <span class="cm">/* CodeEntryScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">2</span> <span class="cm">/* SuccessScreen */</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">impossible</span><span class="p">(</span><span class="nx">screen</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<p><a href="https://www.typescriptlang.org/play/#src=const%20enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground →</strong></a></p>

<ul>
<li>It uses numbers instead of strings.</li>
<li>It still uses a switch statement, instead of reducing to just an <code>if</code>
statement.</li>
</ul>


<h2>PureScript</h2>

<p>PureScript is another high-level language like Reason. Both Reason and
PureScript have data types where we can define unions with custom
constructor names. Despite that, PureScript&rsquo;s generated code is
significantly worse than Reason&rsquo;s.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="s2">"use strict"</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">LoadingScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">LoadingScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">LoadingScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LoadingScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">LoadingScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">CodeEntryScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">CodeEntryScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">CodeEntryScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CodeEntryScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">CodeEntryScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">SuccessScreen</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">function</span> <span class="nx">SuccessScreen</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>    <span class="nx">SuccessScreen</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuccessScreen</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">SuccessScreen</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">LoadingScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">CodeEntryScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">SuccessScreen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">"Failed pattern match at Main line 10, column 1 - line 10, column 39: "</span> <span class="o">+</span> <span class="p">[</span> <span class="nx">v</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">name</span> <span class="p">]);</span>
</span><span class='line'><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the match is exhaustive, it still emits a
<code>throw</code> statement in case the pattern match fails!</li>
</ul>


<p>Admittedly, I didn&rsquo;t try that hard to turn on optimizations in the
compiler. Maybe there&rsquo;s a flag I can pass to get this <code>Error</code> to go
away. But that&rsquo;s pretty disappointing, compared to how small Reason&rsquo;s
generated code was!</p>

<h2>Elm</h2>

<p>I list Elm in the same class as Reason and PureScript. Like the other
two, it lets us define custom data types, and will automatically warn
when us pattern matches aren&rsquo;t exhaustive. Here&rsquo;s the code Elm
generates:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$needsCancelButton</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">_p0</span> <span class="o">=</span> <span class="nx">page</span><span class="p">;</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="nx">_p0</span><span class="p">.</span><span class="nx">ctor</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'LoadingScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">case</span> <span class="s1">'CodeEntryScreen'</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>    <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$SuccessScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'SuccessScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$CodeEntryScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'CodeEntryScreen'</span><span class="p">};</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">_user$project$Main$LoadingScreen</span> <span class="o">=</span> <span class="p">{</span><span class="na">ctor</span><span class="p">:</span> <span class="s1">'LoadingScreen'</span><span class="p">};</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>It&rsquo;s using string literals, much like Flow and TypeScript.</li>
<li>It&rsquo;s smart enough to collapse the last case to just use <code>default</code>
(at least it doesn&rsquo;t <code>throw</code> in the <code>default</code> case!)</li>
<li>The variable names are long, but these would still minify well.</li>
</ul>


<p>It&rsquo;s interesting to see that even though Reason, PureScript, and Elm all
have ML-style datatypes, Reason is the only one that uses an integer
representation for the constructor tags.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>2FA: two-factor authentication<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>&ldquo;Always&rdquo; is a very strong statement. Please use your best judgement. But know that if you&rsquo;re not using a <code>switch</code>, you&rsquo;re trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it&rsquo;s not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn&rsquo;t do compile-time optimizations based on the types.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Case Exhaustiveness in Flow]]></title>
    <link href="https://blog.jez.io/flow-exhaustiveness/"/>
    <updated>2018-04-15T23:02:26-04:00</updated>
    <id>https://blog.jez.io/flow-exhaustiveness</id>
    <content type="html"><![CDATA[<p>Compared to some other languages, <a href="https://flow.org/">Flow</a>&rsquo;s story around exhaustiveness
checking within <code>if / else</code> and <code>switch</code> statements leaves something to
be desired. By default, Flow doesn&rsquo;t do any exhaustiveness checks! But
we <strong>can</strong> opt-in to exhaustiveness checking one statement at a time.</p>

<!-- more -->


<p>In this post, we&rsquo;ll discover from the ground up how Flow&rsquo;s
exhaustiveness checking behaves. But if you&rsquo;re just looking for the
result, here&rsquo;s a snippet:</p>

<h2>TL;DR</h2>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"A"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"B"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorB</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">absurd</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This function will never run!'</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">allGood</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">forgotTagB</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// B. This type is incompatible with the expected param type of empty.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<h2>How Exhaustiveness Behaves in Flow</h2>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiQrACQKYCdOnngBYCGAbnsaAC4CeADngOQCCs2AQo-gJZWHXxYoUsWzdiAOyoBnNIloNQzUAF5QAbyrEA5gC5QAImYGAvgG559PO1Uatew+1MWFeVh1vKAPqHYXEAMawEtJUoJASAIy2ABQAHvru7ACU+qFiEtqqAHwaiKCg3JDxAHT2qipqRgbJ6vkFoLhUAK7YEoYAku0ARtiSAfzGFgUmoJjQ0nh1DY2YLW2dPX0SA74Gw6AmiFtyIErQ0Pjjh5IAJqDasLCnADSg3c1h8CRhRUegxKfnlBKY8KABYiTAD8aFAADE2GM4sQALZ0aCYO4EWaQYgBKhQvgUbqwcjhbiI0AAPWoQmx93GCF0cksigAwrZNDp9AZ6c46W42Ow2Iy1N5fKAfPT-EEQmEIgAmWIJJTc3mpUDpbiZHJ5ApFUrlSpVYzJdUNJqtdoGLr3ZarIb1UbjSYGgpGhampb9fhODZbHaoPYAdWIvA+SswYtuhTCrgBhGDAGtpABCMEAFRejGklMBzTtKMzmG+AOIVAGAFpiAdQIxbZguL1XSVdmAfS9CpB3rDiNG8Jh0fwayt+Jg4gjuAFeKDUGCAKIAJSnAHkp-oZkvl6BADCkgABSQBtpIA4P6VVAy2hKoGT3DTEdPhRWsHhBe43SJ8F4-EkhXh0GHvGgNCLjt+52aEinJgkAqrmdZiqE4QSAAzDKiTytg9KKsqqoqLk0zNlqOgVLqNT2rM8wmmavaWus1pjBMeBvFhWQ6o4eEYQ6czGos5qumsHrbMg3pgAAClG8B3NIQi8KmsywiqpwqlkmbUE2BCMLgoASLAYRBOQB4fGWFKApM0h1nsAAycxiZ85wUr8-yMPSXC6ZgNLjns05zguK5uQUG47nuB5HieZ5WIUaYqkEN5UHeD5Ph87TcG+H5UF+P7MW0uagABQEgX+4HBJBEQACxwXKHAKmk+7SWqGGanEZTYXR1T6oxBEsc6bF9koZEjBRdrUVV2qVPR9X1ExhGsSRbrtZsnVUS2NE4YY7IDTMv4jRa-DspxXrAGCfoBpQkwhiUB1hnuhKHHwKqxnJBattw2iEGES1pcBoGnAmezsI8RyMPi6Uqrw4w0ACeI4ClpanVG+Z6UeuhnRI0bSQA+miAT2fWoCNldKL0swAByoCnCJaZmYG6XEM00BqUCSL3B9QLRhCcD-JioC8XOABqE6XU8eCAhIjBhNocxycDDmbYE2UShIACsBVJMV3llWhBqVdVtF9XV+FLc1o1tR6k3NqAM21U4C2GklREuq17rkZW+uG2r80a2by3sWt1uUfh8T6Jg8K0MkGwFHw2AIMpfygBO2BB9gMSMMQ3TSK0pyMH71pcajyZMIHweWWHEdsFw76-B8uL4o+Za-BpjQAXc3TBqTkxgqJaYqWEdCwNI0jhXgTMQfuzQYoGIjQM0eCwC2EYVj7NCMGCMQGOnSmiHgKnCKWw9Be0FLe3QtBBlQNSox0LYop8sDb3JF50AWVA4O0mAaTQzzA8iVbnJMXeEBeOCR6AsKYO3OiYAbkfPAkA2CXHDEIImFlQ52XCFCekItkA9yggANhlghJCJVNKKwqsUHqNU1Z6kdsNLWK0dZuy6tNfBqsqjG2IU1YiZCrYdRtg1PY9JfIf38ooC8wVryXzCvePAj4+BjEnnWGYnsxHbxoMnGYmd-jZ3DpHaOsd47YETnIzYqceL02DtfA4aZZIGCwDQO4HQ4FpUDPSOMoAADKQgLFBDJqcXmLcg74j4FdM6aZpAiNWPAIE0ISCZjCuQEoBhUbvXDFw0AAjr4LAvNId8t14oA0kCpGgZUmY5mrrXHMYc7GGRVGpfh0B-QhBFqAXIKkiwARzKcIsA46C4HbtwbK+gJyDmDNfb47QgQd20BIX+UhQBQkgABDE7T2iAjLGcS8oQuyv2IP8F8zTWkd2CAZTavpuYvhAnEc+aZugAyRpiTSFJ4k30vEzSgUZoAMGwOESZYVgiILBDHOOCcuAXgsnCbm15YTBC-KlSY5xKyPyUqAp5PjnkrFeRII8kInkDjhAiFGew7pUDoNIXQIASABGjAAkoJBpAdgOCUMBwBL6EoAcAUgsBuCNIAAwlAAOwlEiMAfGARpDAAACIFmIEWVmjLTgkqoLCaAABiUgug1EJzFuKIu6jzhqAADyJmyFIrevt9CJnKvUBRId-jKLYKor5Gik4WHMEg8WUE2XoKKohZCpVULoXqMrXquETZDQYRbUiusbbdRVrNAwdCGqa0YexZhE1g1UNDbVB2kanakJduNG07sU3DQVRo+IWjPSDSXEqnKEgAAcTqeQuqwQrD1Go8GJsIQxItUaA2DAzXrEN3r+r0KdNGy2HbWFFvYZw35AVeFXlCp3HgojN7dIxClS+fRYTUACqPaRtAJGmxzZa04+b1pAA"><strong>Read on flow.org/try/</strong></a></p>

<p>Here we have a type <code>AorB</code> with two variants;</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">A</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"A"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">B</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"B"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorB</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorB</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>All well and good, but what if we add a new case?
For example, what if we take the snippet above and add this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">C</span> <span class="o">=</span> <span class="p">{</span><span class="na">tag</span><span class="p">:</span> <span class="s2">"C"</span><span class="p">};</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">AorBorC</span> <span class="o">=</span> <span class="nx">A</span> <span class="o">|</span> <span class="nx">B</span> <span class="o">|</span> <span class="nx">C</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Wait a second, it type checks!</p>

<p>That&rsquo;s because we used a catch-all <code>else</code> branch. What if we make each
branch explicit?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Phew, so it&rsquo;s reminding us that we&rsquo;re not covering all the cases.
Let&rsquo;s add the new <code>C</code> case:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// ERROR:                 ┌─▶︎ string. This type is incompatible with an implicitly-returned undefined.</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn4</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Hmm: it still thinks that we might return <code>undefined</code>, even though we&rsquo;ve
definitely covered all the cases&hellip; 🤔</p>

<p>What we <strong>can</strong> do is add a default case, but ask Flow to <strong>prove</strong> that
we can&rsquo;t get there, using Flow&rsquo;s <code>empty</code> type:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">fn5</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">);</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'This will never run!'</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>The <code>throw new Error</code> line above will never run, because it&rsquo;s not
possible to construct a value of type <code>empty</code>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> (&ldquo;There are no
values in the empty set.&rdquo;)</p>

<p>If we adopt this pattern everywhere, we&rsquo;d see this error message if we
forgot to add the new case for <code>C</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">const</span> <span class="nx">fn6</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// C. This type is incompatible with empty.</span>
</span><span class='line'>    <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">);</span>
</span><span class='line'>    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'absurd'</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>Flow tells us &ldquo;Hey, I found a C! So I couldn&rsquo;t prove that this switch
was exhaustive.&rdquo;</p>

<p>But this pattern is slightly annoying to use, because ESLint complains:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>no-unused-expressions: Expected an assignment or function call and instead saw an expression.</span></code></pre></td></tr></table></div></figure>


<p>We can fix this by factoring that <code>empty ... throw</code> pattern into a
helper function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// 'absurd' is the name commonly used elsewhere for this function. For example:</span>
</span><span class='line'><span class="c1">// https://hackage.haskell.org/package/void-0.7.1/docs/Data-Void.html#v:absurd</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">absurd</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">empty</span><span class="p">):</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'absurd'</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn7</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"C"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch C"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">fn8</span> <span class="o">=</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="nx">AorBorC</span><span class="p">):</span> <span class="nx">string</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"A"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch A"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">tag</span> <span class="o">===</span> <span class="s2">"B"</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">"In branch B"</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// C. This type is incompatible with the expected param type of empty.</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">absurd</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span></span></code></pre></td></tr></table></div></figure>


<p>So there you have it! You can put that helper function (<code>absurd</code>) in a
file somewhere and import it anywhere. You could even give it a
different name if you want! I&rsquo;ve been using this pattern in all the Flow
code I write these days and it&rsquo;s been nice to rely on it when doing
refactors.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Of course, this presumes that Flow&rsquo;s type system is sound, which it isn&rsquo;t. It&rsquo;s possible to accidentally inhabit <code>empty</code> if you use <code>any</code>! Moral of the story: be <em>very</em> diligent about eradicating <code>any</code>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lenses & Composition]]></title>
    <link href="https://blog.jez.io/lens-composition/"/>
    <updated>2018-02-06T02:07:37-05:00</updated>
    <id>https://blog.jez.io/lens-composition</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>A lens is really just a function <code>a -&gt; b</code> that we represent
backwards<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and with an extra <code>Functor f</code> parameter lying
around:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>type Lens' a b = Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</span></code></pre></td></tr></table></div></figure>


<p><strong>What does this mean for function composition?</strong></p>

<!-- more -->


<p>Normal function composition looks like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="n">g</span> <span class="o">::</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span> <span class="o">.</span> <span class="n">f</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>We often have to read code that looks like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">g</span> <span class="o">.</span> <span class="n">f</span> <span class="o">$</span> <span class="n">x</span></span></code></pre></td></tr></table></div></figure>


<p>This means &ldquo;start with <code>x</code>, then run <code>f</code> on it, and run <code>g</code> after that.&rdquo;
This sentence reads opposite from how the code reads!</p>

<p>What about for lenses? Here we have <code>f'</code> and <code>g'</code> which behave similarly
in some sense to <code>f</code> and <code>g</code> from before:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">f'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="c1">--  ≈ a -&gt; b</span>
</span><span class='line'><span class="n">g'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
</span><span class='line'><span class="c1">--  ≈ b -&gt; c</span>
</span><span class='line'>
</span><span class='line'><span class="n">f'</span> <span class="o">.</span> <span class="n">g'</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="c1">--       ≈ a -&gt; c</span></span></code></pre></td></tr></table></div></figure>


<p>In the lens world, <code>^.</code> behaves kind of like a flipped <code>$</code> that turns
lenses into getters, which lets us write code like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">x</span> <span class="o">^.</span> <span class="n">f'</span> <span class="o">.</span> <span class="n">g'</span></span></code></pre></td></tr></table></div></figure>


<p>This means &ldquo;start with <code>x</code>, then get <code>f'</code> from it, then get <code>g'</code> after
that.&rdquo; The sentence reads just like the code!</p>

<p>This is pretty cool, because it means that lenses (which are
&ldquo;functional&rdquo; getters) read almost exactly like property access (which
are &ldquo;imperative&rdquo; getters). Same concise syntax, but with an elegant
semantics.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I&rsquo;m exaggerating a bit here 😅 To see what I <em>really</em> mean, see <a href="https://blog.jez.io/lens-intuition">this post</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Intuition on Lenses]]></title>
    <link href="https://blog.jez.io/lens-intuition/"/>
    <updated>2018-02-06T00:09:43-05:00</updated>
    <id>https://blog.jez.io/lens-intuition</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been working on a small project in Haskell recently that uses the
<a href="https://hackage.haskell.org/package/wreq">wreq</a> library. It&rsquo;s an HTTP client library that exposes most of its
functionality through lenses. Using this library is my first time really
using lenses pervasively, so I&rsquo;ve spent some time trying to understand
how lenses really work.</p>

<!-- more -->


<p>Lenses try to bring the concept of getters and setters into a functional
setting. Here, &ldquo;functional&rdquo; means that lenses prioritize composition
(chaining one lens after another) and immutability (returning a new
data structure<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> instead of mutating the old one in place).</p>

<p>In a functional setting, if we have a type <code>s</code> and we want to get some
field of type <code>a</code> from it, a getter is just a function <code>s -&gt; a</code>.</p>

<p>Similarly, a setter that updates that field has the type <code>s -&gt; a -&gt; s</code>
which takes the old <code>s</code> and slots the <code>a</code> into it, giving us back a new
<code>s</code>.</p>

<p>Let&rsquo;s see if we can build up some intuition, starting with these types
and ending with the type of <code>Lens'</code> from the lens library:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Lens'</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>In particular, let&rsquo;s start with our getter:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">a</span></span></code></pre></td></tr></table></div></figure>


<p>The first thing we can do is convert it to continuation-passing style
(CPS). In CPS form, a function throws it&rsquo;s return value to a
user-specified callback function (or continuation) instead of returning
its value directly. So our <code>s -&gt; a</code> becomes:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">r</span></span></code></pre></td></tr></table></div></figure>


<p>After we&rsquo;re done computing an <code>a</code> from the <code>s</code> we were given, we throw
it to the continuation of type <code>a -&gt; r</code>. We then take <strong>that</strong> result and
return it. I like to put parens around the second function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>But it&rsquo;s kind of hard to do anything with this, because <code>r</code> is
completely arbitrary. It&rsquo;s chosen by whoever calls us, so we have no
information about what can be done on an <code>r</code>. What if we instead require
that the continuation result be a Functor?</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">r</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>And while we&rsquo;re at it, it was kind an arbitrary stipulation that the <code>f
r</code> of the continuation&rsquo;s callback be the same as the <code>f r</code> of our
function&rsquo;s result type, so let&rsquo;s relax that:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">t</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>This relaxation makes sense as long as we know of some function with
type <code>b -&gt; t</code>, because then we could</p>

<ul>
<li>take the <code>s</code>,</li>
<li>apply our <code>s -&gt; a</code> getter to get an <code>a</code>,</li>
<li>throw this to the <code>a -&gt; f b</code> continuation to get an <code>f b</code>, and</li>
<li><code>fmap</code> our <code>b -&gt; t</code> function over this to get an <code>f t</code>.</li>
</ul>


<p>In general, we might not know of some <code>b -&gt; t</code> function. But remember
that we do have our <code>s -&gt; a -&gt; s</code> function! So if we choose <code>b = a</code> and
<code>s = t</code>, then we get:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">fn</span> <span class="o">::</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p>With a function like this, we can</p>

<ul>
<li>take the <code>s</code>,</li>
<li>apply our <code>s -&gt; a</code> getter to get an <code>a</code>,</li>
<li>throw our <code>a</code> to the <code>a -&gt; f a</code> continuation to get an <code>f a</code>,</li>
<li>partially apply our <code>s -&gt; a -&gt; s</code> setter with the <code>s</code> we were given,

<ul>
<li>(so we have an <code>a -&gt; s</code> now)</li>
</ul>
</li>
<li><code>fmap</code> this <code>a -&gt; s</code> function over the <code>f a</code> to get an <code>f s</code></li>
</ul>


<p>And we&rsquo;ve arrived at the type of <code>Lens'</code>! What really happened here was
we marked the interesting<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> part of our data structure with
a Functor. So if we choose an interesting Functor instance, it&rsquo;ll act on
that point.</p>

<p>What if the Functor we choose is <code>Const a</code>? Well, then it&rsquo;s on us to
provide an <code>a -&gt; f a</code> continuation. Since we&rsquo;ve chosen <code>f = Const a</code> we
have to come up with a function with type <code>a -&gt; Const a a</code>. This is a
special case of the <code>Const</code> constructor:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kt">Const</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Const</span> <span class="n">a</span> <span class="n">b</span></span></code></pre></td></tr></table></div></figure>


<p>So our continuation remembers the <code>a</code> it was given. After the last step,
we&rsquo;ll have a <code>Const a s</code>, which we can call <code>getConst</code> on to give us
the <code>a</code> we stashed. So by choosing <code>Const</code>, our lens acts like a getter!</p>

<p>What if the Functor we choose is <code>Identity</code>? Now we have to provide a
function <code>a -&gt; Identity a</code>. At this point, you probably guessed this
makes our lens a setter. If we&rsquo;re trying to use a setter, then we&rsquo;ll
also have access to some new <code>y :: a</code> that we want to use to slot into
our <code>s</code>. Let&rsquo;s see what happens if we make this our continuation:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="n">inj</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Identity</span> <span class="n">a</span>
</span><span class='line'><span class="n">inj</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Identity</span> <span class="n">y</span></span></code></pre></td></tr></table></div></figure>


<p>The <code>x :: a</code> is the old value of <code>x</code>. By dropping <code>x</code> on the floor and
returning <code>y</code> instead, we&rsquo;ve slotted <code>y</code> into our <code>s</code>. Remember
that above we took the <code>f a</code> and our setter <code>s -&gt; a -&gt; s</code>, partially
applied it to get <code>a -&gt; s</code>, and <code>fmap</code>&rsquo;d this over the <code>f a</code>. Since our
continuation now holds a wrapped up <code>y :: a</code>, we&rsquo;ll reconstruct a new
<code>s</code> using <code>y</code>. Great!</p>

<h2>More Resources</h2>

<p>These are some resources that helped make lenses less intimidating for
me:</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=cefnmjtAolY">Lenses, Folds, and
Traversals</a> (video)

<ul>
<li>by Edward Kmett, the author of the lens library</li>
<li>highly technical, long, exhaustive</li>
</ul>
</li>
<li><a href="https://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-Getter.html">Control.Lens.Getter</a> (hackage)

<ul>
<li>in particular, the first few lines of the intro paragraph</li>
<li>also: <code>(^.)</code> to see where the <code>f</code> becomes <code>Const a</code></li>
</ul>
</li>
<li><code>#haskell</code> on Freenode

<ul>
<li>Special thanks to <code>johnw_</code> and <code>dminuoso</code>!</li>
</ul>
</li>
</ul>


<p>Lenses seem intimidating at first, but in the end they&rsquo;re just a really
cool uses of functions. We use nothing more exotic here than the Functor
type class and a couple of Functor instances, and in return we get such
concise code!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>It&rsquo;s common to think that &ldquo;immutable&rdquo; means &ldquo;copy the entire thing&rdquo; and then change the parts you care about. But if you start with <strong>all data</strong> being immutable, then you only need to allocate new memory for the subcomponents of your data structure that <strong>actually</strong> changed. Everything else can be shared by the old and the new.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>In the same way that glass lenses focus light on a point, functional lenses focus a data structure on a point! Isn&rsquo;t it neat how that name works out? It&rsquo;s certainly a cooler name than &ldquo;generalized getter/setter <a href="https://www.youtube.com/watch?v=pD_imYhNoQ4">wombo combo</a>&rdquo; (video, language warning).<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Review from the Command Line]]></title>
    <link href="https://blog.jez.io/cli-code-review/"/>
    <updated>2018-01-13T16:14:24-05:00</updated>
    <id>https://blog.jez.io/cli-code-review</id>
    <content type="html"><![CDATA[<p>I do the bulk of my code reviews from the command line, especially when
reviewing larger changes. I&rsquo;ve built up a number of tools and config
settings that help me dig into the nuances of the code I&rsquo;m reviewing, so
that I can understand it better than if I were just browsing online.</p>

<!-- more -->


<p>In particular, I&rsquo;ll walk through how I&hellip;</p>

<ul>
<li>check out the code in the first place,</li>
<li>get a feel for what changed,</li>
<li>visualize the relationships between the files that changed,</li>
<li>bring up the code diffs in Vim,</li>
<li>leverage the unique power of the editor and the terminal.</li>
</ul>


<p>But first, let&rsquo;s talk briefly about the point of code review in the
first place.</p>

<h2>Code review philosophy</h2>

<p>When I ask that other people review my code, it&rsquo;s an opportunity for me
to teach them about the change I&rsquo;ve just made. When I review someone
else&rsquo;s code, it&rsquo;s to learn something from them. Some other benefits of
code review include:</p>

<ul>
<li>Team awareness (to keep a pulse on what else is going on within your
team).</li>
<li>Finding alternative solutions (maybe there&rsquo;s a small change that lets
us kill two birds with one stone).</li>
</ul>


<p>If this is different from how you think about code review, <a href="https://www.youtube.com/watch?v=PJjmw9TRB7s">check out
this talk</a>. Code review is a powerful tool for
learning and growing a team.</p>

<p>With that out of the way, let&rsquo;s dive into the tools I use to maximize
benefit I get from code review.</p>

<h2>Checking out the code</h2>

<p>The first step to reviewing code in the terminal is to check out the
code in the first place. One option is to simply to <code>git pull</code> and then
<code>git checkout &lt;branch&gt;</code>. But if you happen to be using GitHub, we can
get this down to just one command:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>hub pr checkout &lt;pr-number&gt;</span></code></pre></td></tr></table></div></figure>


<p>It works using <a href="https://github.com/github/hub">hub</a>, which is a tool that exposes various features of
GitHub from the command line. If the pull request is from someone else&rsquo;s
fork, <code>hub</code> is even smart enough to add their fork as a remote and fetch
it.</p>

<h2>At first glance</h2>

<p>With the branch checked out locally, usually my next step is to get a
feel for what changed. For this, I&rsquo;ve written a git alias that shows:</p>

<ul>
<li>which files changed</li>
<li>how many lines changed in each file (additions and deletions)</li>
<li>how many lines changed overall</li>
</ul>


<p><a class="image-link" href="https://blog.jez.io/images/git-stat.png"><img class="fullwidth" src="https://blog.jez.io/images/git-stat.png" title="git stat" ></a></p>

<p>Here&rsquo;s the definition of <code>git stat</code> from my <code>~/.gitconfig</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span><span class="nb">alias</span><span class="o">]</span>
</span><span class='line'>  <span class="c"># list files which have changed since REVIEW_BASE</span>
</span><span class='line'>  <span class="c"># (REVIEW_BASE defaults to 'master' in my zshrc)</span>
</span><span class='line'>  files <span class="o">=</span> !git diff --name-only <span class="k">$(</span>git merge-base HEAD <span class="se">\"</span><span class="nv">$REVIEW_BASE</span><span class="se">\"</span><span class="k">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># Same as above, but with a diff stat instead of just names</span>
</span><span class='line'>  <span class="c"># (better for interactive use)</span>
</span><span class='line'>  stat <span class="o">=</span> !git diff --stat <span class="k">$(</span>git merge-base HEAD <span class="se">\"</span><span class="nv">$REVIEW_BASE</span><span class="se">\"</span><span class="k">)</span></span></code></pre></td></tr></table></div></figure>


<p>Under the hood, it just works using <code>git diff</code>, <code>git merge-base</code>, and a
personal environment variable <code>REVIEW_BASE</code>.</p>

<p><code>REVIEW_BASE</code> lets us choose which branch to review relative to. Most of
the time, <code>REVIEW_BASE</code> is <code>master</code>, but this isn&rsquo;t always the case! Some
repos branch off of <code>gh-pages</code>. Sometimes I like to review the most
recent commit as if it were its own branch.</p>

<p>To review the code relative so some other base, set <code>REVIEW_BASE</code> before
running <code>git stat</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c"># Review between 'gh-pages' and the current branch</span>
</span><span class='line'><span class="nv">REVIEW_BASE</span><span class="o">=</span>gh-pages git stat
</span><span class='line'>
</span><span class='line'><span class="c"># Review changes made by the last commit of this branch:</span>
</span><span class='line'><span class="nv">REVIEW_BASE</span><span class="o">=</span>HEAD^ git stat</span></code></pre></td></tr></table></div></figure>


<p>I have <code>export REVIEW_BASE=master</code> in my <code>~/.bashrc</code>, because most
projects branch off of <code>master</code>.</p>

<p>Nothing too crazy yet&mdash;GitHub can already do everything we&rsquo;ve seen so
far. Let&rsquo;s start to up the ante.</p>

<h2>Visualizing file change frequency</h2>

<p>I&rsquo;ve written a short script that shows me a visualization of how
frequently the files involved in this branch change over time:</p>

<p><a class="image-link" href="https://blog.jez.io/images/git-heatmap.png"><img class="fullwidth" src="https://blog.jez.io/images/git-heatmap.png" title="git heatmap" ></a></p>

<p>This command identifies two main things:</p>

<ul>
<li><p><strong>Files with lots of changes</strong>.</p>

<p>Files that have changed a lot in the past are likely to change in the
future. I review these files with an eye towards what the <em>next</em>
change will bring.</p>

<p><em>&ldquo;Is this change robust enough to still be useful in the future?
Will we throw this out soon after merging it?&rdquo;</em></p></li>
<li><p><strong>Files with few changes</strong>.</p>

<p>Files that aren&rsquo;t changed frequently are more likely to be brittle.
Alternatively, it&rsquo;s often the case that infrequently changed files
stay unchanged because the change is better made elsewhere.</p>

<p><em>&ldquo;Does this change challenge an implicit assumption so that some other
part of the code was relying on? Is there a better place for this
change?&rdquo;</em></p></li>
</ul>


<p>Those two commands (<code>git stat</code> and <code>git heatmap</code>) are how I kick off my
code review: getting a birds-eye view of the change and some historical
context for what I&rsquo;m dealing with. Next, I drill down into the
relationships between the files that changed.</p>

<h2>Visualizing relationships between files</h2>

<p>At work I review JavaScript files, so I&rsquo;ve built out this next bit of
tooling specifically for JavaScript.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It helps to understand
which files import others, so I have a command that computes the
dependency graph of the files changed on this branch:</p>

<p><a class="image-link" href="https://blog.jez.io/images/git-depgraph.png"><img class="fullwidth" src="https://blog.jez.io/images/git-depgraph.png" title="git depgraph" ></a></p>

<p>This is where we start to see some distinct advantages over what GitHub
provides. As you see above, the <code>git depgraph</code> alias calculates the
dependency graph for files changed by this branch. Why is this useful?</p>

<ul>
<li><p>Maybe we want to start reviewing from <code>Provider.js</code>, since it doesn&rsquo;t
depend on any other files that have changed.</p></li>
<li><p>Maybe we want to work the other way: start with <code>Elements.js</code> so we
know the motivation for why <code>Provider.js</code> had to changed in the first
place.</p></li>
</ul>


<p>In either case, we can see the structure of the change. Three files
depend on <code>Elements.js</code>, so it&rsquo;s serving the needs of many modules.
<code>Element.js</code> only has one dependency, etc. Each branch&rsquo;s dependency
graph shows different information; it can be surprising what turns up.</p>

<p>I have the <code>git depgraph</code> alias defined like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span><span class="nb">alias</span><span class="o">]</span>
</span><span class='line'>  depgraph <span class="o">=</span> !git madge image --webpack-config webpack.config.js --basedir . --style solarized-dark src</span></code></pre></td></tr></table></div></figure>


<p>Some notes about this definition:</p>

<ul>
<li><p>It depends on the <code>git-madge</code> command, which you can <a href="https://github.com/jez/git-madge">download
and install here</a>.</p></li>
<li><p>It&rsquo;s using <em>this project&rsquo;s</em> <code>webpack.config.js</code> file, so I&rsquo;ve made
this alias local to the repo, rather than available globally.</p></li>
<li><p>It dumps the image to stdout. Above, we used iTerm2&rsquo;s <a href="https://iterm2.com/documentation-images.html">imgcat</a>
program to pipe stdin and dump a raster image to the terminal.</p>

<p>If you don&rsquo;t use iTerm2 or don&rsquo;t want to install <code>imgcat</code>, you can
pipe it to Preview using open<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> (<code>open -f -a Preview</code>) or just
redirect the PNG to a file.</p></li>
</ul>


<p>The <code>git depgraph</code> alias is a game changer. It makes it easier to get spun
up in new code bases, helps make sense of large changes, and just looks
plain cool. But at the end of the day, we came here to review some code,
so let&rsquo;s take a look at how we can actually view the diffs of the files
that changed.</p>

<h2>Reviewing the diffs</h2>

<p>To review the diffs, the simplest option is to just run <code>git diff
master..HEAD</code>. This has a bunch of downsides:</p>

<ul>
<li><p>No syntax highlighting (everything is either green or red).</p></li>
<li><p>No surrounding context (for example, GitHub lets you click to expand
lines above or below a diff hunk).</p></li>
<li><p>The diff is &ldquo;unified,&rdquo; instead of split into two columns.</p></li>
<li><p>No way to exclude a specific file (the 300 line diff to your
<code>yarn.lock</code> file is sometimes nice to hide).</p></li>
</ul>


<p>My solution to all of these problems is to view the diffs in Vim, with
the help of two Vim plugins and two git aliases. Before we get to
that, here&rsquo;s a screenshot:</p>

<p><a class="image-link" href="https://blog.jez.io/images/git-review.png"><img class="fullwidth" src="https://blog.jez.io/images/git-review.png" title="git review" ></a></p>

<p>Looks pretty similar to GitHub&rsquo;s interface, with the added bonus that
it&rsquo;s using my favorite colorscheme! The Vim plugins featured are:</p>

<ul>
<li><a href="https://github.com/tpope/vim-fugitive">tpope/vim-fugitive</a> for showing the side-by-side diff (<code>:Gdiff</code>).</li>
<li><a href="https://github.com/airblade/vim-gitgutter">airblade/vim-gitgutter</a> for showing the <code>+/-</code> signs.</li>
<li><a href="https://github.com/jez/vim-colors-solarized">jez/vim-colors-solarized</a> for tweaking the diff highlight
colors.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>


<p>And to orchestrate the whole thing, I&rsquo;ve set up these two aliases:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span><span class="nb">alias</span><span class="o">]</span>
</span><span class='line'>  <span class="c"># NOTE: These aliases depend on the `git files` alias from</span>
</span><span class='line'>  <span class="c"># a few sections ago!</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># Open all files changed since REVIEW_BASE in Vim tabs</span>
</span><span class='line'>  <span class="c"># Then, run fugitive's :Gdiff in each tab, and finally</span>
</span><span class='line'>  <span class="c"># tell vim-gitgutter to show +/- for changes since REVIEW_BASE</span>
</span><span class='line'>  review <span class="o">=</span> !vim -p <span class="k">$(</span>git files<span class="k">)</span> +<span class="se">\"</span>tabdo Gdiff <span class="nv">$REVIEW_BASE</span><span class="se">\"</span> +<span class="se">\"</span><span class="nb">let </span>g:gitgutter_diff_base <span class="o">=</span> <span class="s1">'$REVIEW_BASE'</span><span class="se">\"</span>
</span><span class='line'>
</span><span class='line'>  <span class="c"># Same as the above, except specify names of files as arguments,</span>
</span><span class='line'>  <span class="c"># instead of opening all files:</span>
</span><span class='line'>  <span class="c"># git reviewone foo.js bar.js</span>
</span><span class='line'>  reviewone <span class="o">=</span> !vim -p +<span class="se">\"</span>tabdo Gdiff <span class="nv">$REVIEW_BASE</span><span class="se">\"</span> +<span class="se">\"</span><span class="nb">let </span>g:gitgutter_diff_base <span class="o">=</span> <span class="s1">'$REVIEW_BASE'</span><span class="se">\"</span></span></code></pre></td></tr></table></div></figure>


<p>Here&rsquo;s how they work:</p>

<ul>
<li><p><code>git review</code> opens each file changed by this branch as a tab in Vim.
Then <code>:Gdiff</code> from vim-fugitive shows the diff in each tab.</p></li>
<li><p><code>git reviewone</code> is like <code>git review</code>, but you specify which
files to open (in case you only want to diff a few).</p></li>
</ul>


<p>Like with the <code>git stat</code> alias, these aliases respect the <code>REVIEW_BASE</code>
environment variable I&rsquo;ve set up in my <code>~/.bashrc</code>. (Scroll back up for
a refresher.) For example, to review all files relative to <code>master</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">REVIEW_BASE</span><span class="o">=</span>master git review</span></code></pre></td></tr></table></div></figure>


<p>At this point, you might think that all we&rsquo;ve done is re-create the
GitHub code review experience in Vim. But actually what we&rsquo;ve done is so
much more powerful.</p>

<h2>Interactive Code Review</h2>

<p>When reviewing on GitHub, the code is completely static&mdash;you can&rsquo;t
change it. Also, because the code is coming from GitHub&rsquo;s servers,
it&rsquo;s laggy when you click around to view related files. By switching our
code review to the terminal, we can now edit files, jump to other files,
and run arbitrary commands at no cost.</p>

<p>It might not be obvious how huge of a win this is, so let&rsquo;s see some
examples. Take this screenshot of the <code>requireElement</code> function. It
moved from <em>above</em> the <code>findElement</code> function to <em>below</em> it (probably
because the former calls the latter):</p>

<p><a class="image-link" href="https://blog.jez.io/images/requireElement01.png"><img class="fullwidth" src="https://blog.jez.io/images/requireElement01.png" title="diff" ></a></p>

<p>But is the location of the <code>requireElement</code> function the only thing
that&rsquo;s changed? By editing the file to move the function back to its
original location, vim-fugitive will automatically recompute the diff.
And in fact, we can see that the <em>type of the argument</em> has changed too,
from <code>string</code> to <code>ElementType</code>:</p>

<p><a class="image-link" href="https://blog.jez.io/images/requireElement02.png"><img class="fullwidth" src="https://blog.jez.io/images/requireElement02.png" title="diff" ></a></p>

<p>If we had been viewing this on GitHub, we might have taken for granted
that the function didn&rsquo;t change. But since we&rsquo;re in our editor, we can
interactively play around with our code and discover things we might
have missed otherwise. The advantages of interactive code review go well
beyond this example:</p>

<ul>
<li><p>In a Flow project, we can ask for the type of a variable.</p></li>
<li><p>In a test file, we can change the test and see if it still passes or
if it now fails.</p></li>
<li><p>We can <code>grep</code> the project for all uses of a function (including files
<em>not</em> changed by this branch).</p></li>
<li><p>We can open up related files for cross-referencing.</p></li>
<li><p>We can run the code in a debugger and see how it behaves.</p></li>
</ul>


<p>By having the full power of our editor, we can literally retrace the
steps that the author went through to create the pull request. If our
goal is to understand and learn from code review, there&rsquo;s no better way
than walking in the author&rsquo;s shoes.</p>

<h2>Recap</h2>

<p>To recap, here&rsquo;s a list of the tools I use to review code at the command
line:</p>

<ul>
<li><code>hub pr checkout</code></li>
<li><code>git stat</code> to list files that have changed</li>
<li><code>git heatmap</code> to show how frequently these files change</li>
<li><code>git depgraph</code> to show a graph of which files depend on which</li>
<li><code>git review</code> to open diffs of all the files in Vim</li>
<li><code>git reviewone</code> to open diffs for a specific handful of files</li>
</ul>


<p>If you&rsquo;re having trouble incorporating any of these into your workflow,
feel free to reach out and let me know! I&rsquo;m happy to help.</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>The techniques here apply to any language that you can statically analyze. In particular, I have a rough prototype of everything JavaScript-specific you see here that works with Standard ML instead. If you can find me the dependency information for your favorite language, I&rsquo;d be happy to help you turn it into a visualization.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>The <code>open</code> command is macOS-specific. On Linux, you might want to look at the <code>display</code> command from ImageMagick.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>I&rsquo;ve patched the default Solarized colors for Vim so that lines retain their syntax highlighting in the diff mode, while the backgrounds are highlighted. You can see how this works in this commit: <a href="https://github.com/jez/vim-colors-solarized/commit/bca72cc">https://github.com/jez/vim-colors-solarized/commit/bca72cc</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Presenting Data & Information: Notes]]></title>
    <link href="https://blog.jez.io/tufte-course/"/>
    <updated>2017-12-06T02:37:08-05:00</updated>
    <id>https://blog.jez.io/tufte-course</id>
    <content type="html"><![CDATA[<p>On Monday, December 4th, I went to Edward Tufte&rsquo;s one-day course on
&ldquo;Presenting Data &amp; Information.&rdquo; I&rsquo;m glad I went, and there were a
number of things I took away from the day.</p>

<!-- more -->


<h3>Key takeaways</h3>

<ol>
<li>Text, numbers, and visuals should be <strong>woven tightly together</strong>.</li>
<li>From a small set of principles, we can have a <strong>rigorous, analytical
framework</strong> for evaluating information designs.</li>
<li>Information benefits from being shown in <strong>space and time</strong>.</li>
<li>Effective presentations lead to the <strong>outsized impact</strong> of your work.</li>
<li><strong>High-density</strong> visualizations trump those of low-density.</li>
<li>Tufte-the-personality is over-hyped.</li>
<li>Learning is a lifelong process.</li>
</ol>


<h3>Selected readings</h3>

<p>A lot of the books are broken up into modular components, almost like
individual essays. This means they&rsquo;re easy to pick up and read a little
bit of. I&rsquo;m happy to lend you my copies!</p>

<ul>
<li>&ldquo;Words, Numbers, Images&mdash;Together&rdquo;

<ul>
<li><em>Beautiful Evidence</em></li>
</ul>
</li>
<li>&ldquo;The Fundamental Principles of Analytical Design&rdquo;

<ul>
<li><em>Beautiful Evidence</em></li>
</ul>
</li>
<li>&ldquo;Narratives of Space &amp; Time&rdquo;

<ul>
<li><em>Envisioning Information</em></li>
</ul>
</li>
<li>&ldquo;High Resolution Data Graphics&rdquo;

<ul>
<li><em>The Visual Display of Quantitative Information</em></li>
</ul>
</li>
<li><em>Tips for Giving Clear Talks</em> (by Kayvon Fatahalian)

<ul>
<li><a href="https://www.cs.cmu.edu/~kayvonf/misc/cleartalktips.pdf">Slides</a></li>
</ul>
</li>
</ul>


<h2>Integrating Visuals with Text</h2>

<blockquote><p>&ldquo;Words, Numbers, Images&mdash;Together&rdquo;</p>

<p>&mdash; <em>Beautiful Evidence</em></p></blockquote>

<p>Fun fact: the word &ldquo;text&rdquo; comes from the Latin word for &ldquo;woven.&rdquo;
Originally this reflected the visual appearance of the written words:
letters and words overlapped and flowed like threads in a cloth.</p>

<p>Tufte made the case that we need to weave more than just text; text,
but also numbers, data graphics, visuals, etc. It&rsquo;s especially bad when
there&rsquo;s a &ldquo;special place&rdquo; for graphics or numbers, because you lose out
on the opportunities to connect ideas and expose relationships.</p>

<p>This segregation of data is a recent change. When the pen was the same
tool to produce text as to produce drawings, text and images abounded!
This is especially apparent in some of da Vinci&rsquo;s notes, for example,
about human anatomy. Even consider the difference between content
produced on a whiteboard (marker) vs in Dropbox Paper (keyboard).
Graphics will flow when you&rsquo;re white-boarding with someone, not when
you&rsquo;re collaborating on Paper.</p>

<p>Finally, I think sparklines are really cool. A full-fledged
visualization can be thought to represent the granularity of an essay.
A single chart or element of the visualization parallel paragraphs of
text. Sparklines continue the progression down to the word level. He
showed some really cool examples of what happens when you can
weave visualizations with your text at the level of single words.</p>

<h2>Analytical Design Thinking</h2>

<blockquote><p>&ldquo;The Fundamental Principles of Analytical Design&rdquo;</p>

<p>&mdash; <em>Beautiful Evidence</em></p></blockquote>

<p>The key point here was that with a few principles, we can be more
rigorous in evaluating our designs. The beauty is it parallels similar
principles from the scientific method, which is a time-tested tool for
discovering knowledge.</p>

<h3>The principles themselves</h3>

<p>Show comparisons, contrasts, differences.</p>

<p>Show causality, mechanism, explanation.</p>

<p>Show multivariate data, that is, show more than 1 or 2 variables.
<em>Corollary</em>: All interesting data is multivariate (requires a JOIN of
sorts on disparate data sources).</p>

<p>Completely integrate words, numbers, images, diagrams, etc.</p>

<p>Thoroughly provide your evidence (title, sources, shortcomings, etc.)
<em>Corollary</em>: if you&rsquo;re afraid to show your data, you&rsquo;re might be lying</p>

<p>Quality, relevance, and integrity of content counts most of all.</p>

<h3>Some interesting implications</h3>

<ul>
<li>The credibility of an &ldquo;executive summary&rdquo; depends intimately on the
quality, relevance, and integrity of the evidence.</li>
<li>Analytical processes for design rely heavily on mutual respect,
because criticism is inherent to the process.</li>
<li>It&rsquo;s easy to default to uni- or bi-variate data (these are what our
tools are good at). By overcoming the comfort of what our tools do
well, we can draw stronger conclusions.</li>
</ul>


<h2>Information in Space &amp; Time</h2>

<blockquote><p>&ldquo;Narratives of Space &amp; Time&rdquo;</p>

<p>&mdash; <em>Envisioning Information</em></p></blockquote>

<p>We often neglect to visualize information in space, instead choosing to
only visualize it in time.</p>

<p>Consider a slide deck: the information is segmented in to discrete
frames which are then played back over the time of the talk. On the
other hand, a poster or handout might have the same content laid out on
one page, so it&rsquo;s all in the field of view at once.</p>

<p>This echoed a similar idea to one Adam brought up in the Frontend
Learning Group: Sketch effectively converted designing UIs from
something being seen over time (by showing/hiding various Photoshop
layers) to being seen over space (artboards or screens).</p>

<p>Often a stronger case can be made by presenting information in both time
and in space. A general problem with information presented over time is
that it happens too fast. This isn&rsquo;t to say presenting information in
time is terrible: it&rsquo;s just shouldn&rsquo;t be the only way.</p>

<h2>Talking &amp; Presenting</h2>

<blockquote><p><em>Tips for Giving Clear Talks</em></p>

<p>&mdash; Kayvon Fatahalian</p></blockquote>

<p>Tufte spent a surprising amount of time talking about effectively
presenting. I thought many of his ideas about effective presentations
were out of touch with reality.</p>

<p>Instead, I prefer these resources on giving clear presentations by
Kayvon Fatahalian:</p>

<ul>
<li>📈 <a href="https://www.cs.cmu.edu/~kayvonf/misc/cleartalktips.pdf">Slides</a></li>
<li>📺 <a href="https://www.dropbox.com/s/96t357h8uhf52l6/clear-talk-tips.mp4?dl=0">Video</a></li>
</ul>


<p>The key points are:</p>

<ul>
<li>An effective talk leads to a <em>non-linear</em> increase in the value of
your work.</li>
<li>The audience prefers not to think (much).

<ul>
<li>They don&rsquo;t want to think about what you left out or what you&rsquo;re
hinting at.</li>
<li>They&rsquo;d much rather think about how they can put your work to use.</li>
</ul>
</li>
<li>Every sentence matters.

<ul>
<li>If it doesn&rsquo;t provide value, strike it out.</li>
</ul>
</li>
<li>Surprises are bad.

<ul>
<li>Say where you&rsquo;re going and why before you go there.</li>
</ul>
</li>
<li>Titles matter.

<ul>
<li>Reading nothing but the titles of a slide deck should be a great
summary of the talk.</li>
<li>Sometimes this means titles are short sentences!</li>
</ul>
</li>
<li>End on a positive note!

<ul>
<li>People remember the beginnings and ends.</li>
<li>You want them to walk out with a rising rather than sinking
feeling.</li>
</ul>
</li>
</ul>


<p>That being said, Tufte did have a few good tips for presentations.
For example: give handouts with your talks. Handouts overcome the
low information density of slides. This tip is just a restatement of
&ldquo;present information in space <em>and</em> time.&rdquo; The handouts might be:</p>

<ul>
<li>full-on lecture notes</li>
<li>a simple overview/summary</li>
<li>a list of key takeaways</li>
<li>links to further reading</li>
<li>a graphic you want to refer back to often</li>
</ul>


<h2>High-density vs Low-density Visualizations</h2>

<blockquote><p>&ldquo;High Resolution Data Graphics&rdquo;</p>

<p>&mdash; <em>The Visual Display of Quantitative Information</em></p></blockquote>

<p>Tufte discussed a very clear preference for high-density visualizations
over low-density. High-density visualizations should present
multivariate data cohesively, weaving text, numbers, and visuals.</p>

<p>In a high-density visualization, the arrangement and composition is key.
If you get it wrong, you end up with information overload. But the goal
is to get it right, and in doing so, you draw richer comparisons and
conclusions that are otherwise possible.</p>

<p>This was why Tufte had a clear preference for physical paper over
digital media: the resolution of a piece of paper (or better: two
side-by-side) is <em>significantly</em> higher than most displays are these
days. In his books, every two-page spread shows a high-density
visualization, which is what makes them so powerful.</p>

<p>The flip side: he detested interfaces that presented shallow views into
the data or sacrificed analytical design for aesthetic design. It&rsquo;s
common on the web to be scared of information overload, and instead show
less. We should present more, but <em>thoughtfully</em> and with clear
relationships between all the elements.</p>

<p>As a closing rebut, he made the claim that we should &ldquo;design forward,
anticipating higher-resolution devices.&rdquo; I found this hard to reconcile
with the long tail of users that have <em>terrible</em> resolution devices
currently, with no hope of improving rapidly.</p>

<h2>Meta</h2>

<p>I was a little disappointed to meet with Tufte-the-personality as
opposed to Tufte-the-writer.</p>

<p>As a presenter, there seemed to be a stronger focus on bravado and
showmanship than on learning and growth. Until this event, I hadn&rsquo;t been
aware of the somewhat cult-ish following Tufte has, and it seemed like
he was profiting off of that image. Some back-of-the-envelope math
suggests that he can easily bring in a six-figure salary from the dozen
one-day courses he runs in a year alone.</p>

<p>His multiple books which revisit the same core set of ideas with slight
variations suggest that he&rsquo;s producing content to make a living as
opposed to trying to distill ideas into a small, cohesive set of truths.
In particular, I think of my favorite programming languages textbook,
where every chapter is both complementary yet orthogonal to the others.
The book distills and reduces ideas down to their core essence. Tufte&rsquo;s
books dance around, giving the effect of after-images of some underlying
truth which is withheld.</p>

<p>Tufte&rsquo;s speaking style favored shaming and derision to inclusion and
passion. In the audience, there was a certain amount of, &ldquo;it&rsquo;s okay, as
long as I laugh along with everyone else I&rsquo;ll belong.&rdquo; This line of
thinking leads to toxic behavior where people think they need to put
down others to grow.</p>

<p>Tufte repeatedly made arguments of the form:</p>

<ul>
<li>Google and the NYTimes do it.</li>
<li>These two are wildly successful.</li>
<li>Therefore, it&rsquo;s the correct thing to do.</li>
</ul>


<p>This reasoning ignores confounding variables like survivorship
bias. It&rsquo;s also possible to succeed <em>in spite of</em> flawed design. While
we can draw inspiration from what others do, it&rsquo;s important to verify
them from first principles, rather than blindly follow.</p>

<p>That being said, he mentioned something to the effect of &ldquo;even
lobbyists can be right.&rdquo; Even in spite of the commercialism of it all,
we can still learn from what he has to say. I presented the four earlier
sections before this section because I did take away many valuable
ideas from the day.</p>

<h2>Open Questions</h2>

<p>How can we scale paper handouts to the digital age?</p>

<ul>
<li>What we want:

<ul>
<li>share with others</li>
<li>collaborate/discuss after</li>
<li>high-density information</li>
<li>evergreen vs moment in time</li>
</ul>
</li>
<li>Is something like Dropbox Paper good enough to replace physical
paper for meeting handouts?</li>
</ul>


<p>What is it about screens that&rsquo;s better than physical paper?</p>

<ul>
<li>paper has higher resolution + information density</li>
<li>two, three, four pages of paper at once are the same as 2 x 27&#8221; monitors</li>
<li>yet, why do we use screens if the information density is so low?</li>
</ul>


<h2>Personal</h2>

<p>I had a couple personal realizations while I was there.</p>

<p>At the first hackathon I ever went to during my freshman year of
college, the thing we built was a tool to try and visualize geographic
data on a 3D, interactive globe. I was so proud of this thing we built.
It was the first time I ever wrote JavaScript (I had literally never
touched it before). After 36 hours, we had a live, running thing that
people could <em>actually interact with!</em></p>

<p>During the final expo and initial judging phase, one of the judges (not
the one assigned to judge us) came by and asked a simple question: &ldquo;oh,
have you read anything by Edward Tufte about visualizations?&rdquo; I answered
no, and he quickly rattled off a few obvious in hindsight changes we
could make to improve our project.</p>

<p>I was so ashamed at the time. &ldquo;Who am I to try and make a data
visualization, knowing nothing about data visualization?&rdquo; I truly felt
like an imposter.</p>

<p>This happened 4 years ago: October 2013, my freshman year of college.
Fast-forward 4 years, and not only have I browsed through his books,
I&rsquo;ve just heard what Tufte has to say face-to-face. The learning process
is spread out over the course of a <em>lifetime</em>. Not in an afternoon of
hackathon judging. Not for the duration of a one-day course.</p>

<p>Reflecting on the &ldquo;childlike&rdquo; pride and enthusiasm I had having built
something, from knowing nothing, there&rsquo;s little quite as thrilling. By
that same token, we should have the same attitude when people give us
tips and suggestions for what to learn next&mdash;these tips are decidedly
<em>not</em> evidence that we should feel ashamed for knowing too little.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABTs in Haskell]]></title>
    <link href="https://blog.jez.io/abts-in-haskell/"/>
    <updated>2017-11-12T01:31:41-05:00</updated>
    <id>https://blog.jez.io/abts-in-haskell</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been learning and using Haskell on-and-off for the past couple
of years. One of my early complaints was that I couldn&rsquo;t find a good
library for working with variables and binding that used locally
nameless terms. Recently though, I found <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which
checks all my previously unfilled boxes.</p>

<p>Abstract binding trees (or ABTs) are abstract syntax trees (ASTs)
augmented with the ability to capture the binding structure of a
program. ABTs are one of the first topics we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles
of Programming Languages</a> because variables show up in every
interesting feature of a programming language.</p>

<p>I recently wrote at length about the various strategies for dealing with
<a href="https://blog.jez.io/variables-and-binding/">variables and binding</a> and their implementations. While it&rsquo;s a good
exercise<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to implement ABTs from scratch, in most cases I&rsquo;d
rather just use a library. In school we used <a href="https://github.com/robsimmons/abbot"><code>abbot</code></a>, which is an ABT
library for Standard ML. For tinkering with Haskell, I recently found
<a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a>, which provides a similar API.</p>

<p>I gave it a test drive while learning how to implement type inference
for the simply-typed lambda calculus (STLC) and was rather pleased. The
source code for my STLC inference program is <a href="https://github.com/jez/stlc-infer">on GitHub</a> if
you&rsquo;re looking for an example of <a href="https://github.com/lambdageek/unbound-generics"><code>unbound-generics</code></a> in action.</p>

<p>To pluck a few snippets out, here&rsquo;s the definition of STLC terms:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Term</span>
</span><span class='line'>  <span class="o">=</span> <span class="kt">Tvar</span> <span class="kt">Tvar</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tlam</span> <span class="p">(</span><span class="kt">Bind</span> <span class="kt">Tvar</span> <span class="kt">Term</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tapp</span> <span class="kt">Term</span> <span class="kt">Term</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tlet</span> <span class="kt">Term</span> <span class="p">(</span><span class="kt">Bind</span> <span class="kt">Tvar</span> <span class="kt">Term</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tz</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Ts</span> <span class="kt">Term</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tifz</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="p">(</span><span class="kt">Bind</span> <span class="kt">Tvar</span> <span class="kt">Term</span><span class="p">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tbool</span> <span class="kt">Bool</span>
</span><span class='line'>  <span class="o">|</span> <span class="kt">Tif</span> <span class="kt">Term</span> <span class="kt">Term</span> <span class="kt">Term</span>
</span><span class='line'>  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p><code>Bind</code> is the abstract type for locally nameless terms that bind a
variable. It&rsquo;s cool in Haskell (compared to SML) because the compiler
can automatically derive the locally nameless representation from this
data type definition (with help from the <code>unbound-generics</code> library).</p>

<p>Here&rsquo;s what it looks like in use:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="c1">-- (This is a snippet from the type inference code)</span>
</span><span class='line'><span class="n">constraintsWithCon</span> <span class="n">ctx</span> <span class="p">(</span><span class="kt">Tlam</span> <span class="n">bnd</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
</span><span class='line'>  <span class="c1">-- 'out' the ABT to get a fresh variable</span>
</span><span class='line'>  <span class="c1">-- (x used to be "locally nameless", but now has a globally unique name)</span>
</span><span class='line'>  <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">unbind</span> <span class="n">bnd</span>
</span><span class='line'>  <span class="c1">-- Generate fresh type variable to put into the context</span>
</span><span class='line'>  <span class="n">t1</span> <span class="o">&lt;-</span> <span class="kt">Cvar</span> <span class="o">&lt;$&gt;</span> <span class="n">fresh</span> <span class="p">(</span><span class="n">string2name</span> <span class="s">"t1_"</span><span class="p">)</span>
</span><span class='line'>  <span class="kr">let</span> <span class="n">ctx'</span> <span class="o">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t1</span> <span class="n">ctx</span>
</span><span class='line'>  <span class="n">t2</span> <span class="o">&lt;-</span> <span class="n">constraintsWithCon</span> <span class="n">ctx'</span> <span class="n">e</span>
</span><span class='line'>  <span class="n">return</span> <span class="o">$</span> <span class="kt">Carrow</span> <span class="n">t1</span> <span class="n">t2</span></span></code></pre></td></tr></table></div></figure>


<p>Apart from <code>out</code> being called <code>unbind</code> and <code>into</code> being called <code>bind</code>,
the API is pretty similar. Also, unlike <code>abbot</code>, which required a
standalone build step to generate SML code, <code>unbound-generics</code> uses the
Haskell&rsquo;s <code>derive Generic</code> to bake the code generation for capture
avoiding substitution and alpha equivalence right into the compiler. All
in all, <code>unbound-generics</code> is really pleasant to use!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>In fact, it&rsquo;s hw1 for 15-312! If you&rsquo;re curious, check out the <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/hws/assn1.pdf">handout</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables and Binding]]></title>
    <link href="https://blog.jez.io/variables-and-binding/"/>
    <updated>2017-10-28T22:04:01-04:00</updated>
    <id>https://blog.jez.io/variables-and-binding</id>
    <content type="html"><![CDATA[<p>Variables are central<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> to programming languages, yet they&rsquo;re
often overlooked. Academic PL theory papers usually take for granted
having proper implementations of variables. Most popular languages
butcher variables, <a href="https://existentialtype.wordpress.com/2012/02/01/words-matter/">confusing them with assignables</a>.
Despite being taken for granted, implementing substitution on variables
is easy to get wrong.</p>

<!-- more -->


<p>There are a number of different solutions for handling variables and
binding within a programming language implementation. We&rsquo;ll take a look
at these three:</p>

<ul>
<li>explicit variables,</li>
<li>de Bruijn indices, and</li>
<li>locally nameless terms</li>
</ul>


<p>Before we get to solutions, we need to outline the problem. Implementing
variables and binding reduces to implementing substitution (because
variables are giving meaning by substitution!), and the trickiest part of
substitution is variable capture.</p>

<h2>Variable Capture</h2>

<p>The most common way to get variables and binding wrong is to
accidentally let variables be <em>captured</em> during substitution. Consider
this example:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>                  <span class="err">◀────────────────┐</span>
</span><span class='line'>                         <span class="err">┌──────┐</span>  <span class="err">│</span>
</span><span class='line'>                   <span class="p">(</span><span class="err">λ</span><span class="n">x</span><span class="o">.</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span>
</span><span class='line'>                     <span class="err">└──────┘</span></span></code></pre></td></tr></table></div></figure>


<p>There are two distinct <code>y</code> variables here:</p>

<ul>
<li>one which refers to the variable bound by the nested lambda</li>
<li>one which refers to some <code>y</code> in the surrounding scope</li>
</ul>


<p>For this example, let&rsquo;s say we choose to represent variables as string
identifiers. If we step the function application, it steps to a
substitution of <code>y</code> for <code>x</code>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>  <span class="p">(</span><span class="err">λ</span><span class="n">x</span><span class="o">.</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span>
</span><span class='line'>  <span class="c"># Apply the function, giving us:</span>
</span><span class='line'><span class="err">→</span> <span class="p">[</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>  <span class="c"># Traverse under the lambda:</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="p">[</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>  <span class="c"># Distribute:</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="p">([</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">([</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>  <span class="c"># Substitute y where we found an x:</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span></span></code></pre></td></tr></table></div></figure>


<p><strong>Note</strong>: <code>[e₁ / x] e₂</code> is read as &ldquo;substitute <code>e₁</code> for <code>x</code> in <code>e₂</code>.&rdquo;</p>

<p>We started with a function which would take two numbers and sum them.
After partially applying that function, we&rsquo;ve ended up with a function
that doubles it&rsquo;s argument. Whoops! We can look at the issue visually in
this diagram:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>       <span class="err">◀─────┐</span>             <span class="err">┃</span>         <span class="err">┌──┐</span>
</span><span class='line'>         <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span>         <span class="err">┃</span>        <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>          <span class="err">└──────┘</span>         <span class="err">┃</span>         <span class="err">└──────┘</span></span></code></pre></td></tr></table></div></figure>


<p>We were expecting to get out the binding structure on the left, but
instead we got the binding structure on the right. This is called
&ldquo;variable capture&rdquo; or just <strong>capture</strong> for short. The <code>y</code> that we
applied to the summing function was captured by the binding site of the
nested lambda.</p>

<h2>Explicit Variables</h2>

<p>When we&rsquo;re implementing substitution (whether for terms, for types, or
for any other sort of syntax), our primary goal is to implement
<strong>capture-avoiding substitution</strong>. There are many internal
representations we can pick from to achieve this. The strategy above
where variables were simple strings is called <strong>explicit variables</strong>.</p>

<p>Explicit variables are nice because we can represent them directly with
an algebraic data type. For example, for the lambda calculus we might
have this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="kt">term</span>
</span><span class='line'>  <span class="p">=</span> <span class="nc">Var</span> <span class="kr">of</span> <span class="n">string</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">Lam</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">term</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">App</span> <span class="kr">of</span> <span class="n">term</span> <span class="n">*</span> <span class="n">term</span></span></code></pre></td></tr></table></div></figure>


<p>Implementing capture-avoiding substitution using this representation
isn&rsquo;t pleasant, but it is possible. It uses the observation that there&rsquo;s
no difference between, say <code>λx. x</code> and <code>λy. y</code>. Our choice of variable
names doesn&rsquo;t matter&mdash;they&rsquo;re both the identity function.</p>

<p>Being able to rename bound variables at will is called <strong>α-varying</strong>,
and when two terms can be made identical by just α-varying them,
we say they&rsquo;re <strong>α-equivalent</strong>.</p>

<p>It only makes sense to α-vary bound variables, not free variables. If we
have two functions like <code>λx. x + y</code> and <code>λx. x + z</code>, we can&rsquo;t safely
α-vary <code>y</code> to <code>z</code>, because we have no way of knowing whether <code>y</code> and <code>z</code>
are the same! Their same-ness depends on the context.</p>

<p>We can implement capture-avoiding substitution for the explicit variable
representation by α-varying whenever we detect that a variable might be
captured. To revisit our example from earlier:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>  <span class="p">(</span><span class="err">λ</span><span class="n">x</span><span class="o">.</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span>
</span><span class='line'><span class="err">→</span> <span class="p">[</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>  <span class="c"># our free 'y' will get captured by going under</span>
</span><span class='line'>  <span class="c"># this λ, so let's α-vary the bound 'y' to 'z':</span>
</span><span class='line'><span class="err">→</span> <span class="p">[</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="err">λ</span><span class="n">z</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="n">z</span><span class="o">.</span> <span class="p">[</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">]</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="n">z</span><span class="o">.</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span></span></code></pre></td></tr></table></div></figure>


<p>The trick here is that by picking <code>z</code> we picked a name that doesn&rsquo;t
collide with any of the free variables with in <code>λy. x + y</code>. Namely,
we&rsquo;re glad we didn&rsquo;t α-vary <code>y</code> to <code>x</code>! To ensure this, our
implementation can either</p>

<ul>
<li>calculate the set of free variables used in a subexpression and make
sure not to use one of those, or</li>
<li>generate a globally unique name by incrementing a global
counter, giving us names like <code>x1</code>, <code>x2</code>, <code>x3</code>, etc.</li>
</ul>


<p>On the surface, explicit variables look rather naïve, and maybe they
are. However, they work perfectly if you don&rsquo;t need substitution in the
first place! For example, a compiler never needs to substitute a term
for a variable in another term because compilers don&rsquo;t evaluate code:
they translate one intermediate language into another.</p>

<p>On the other hand, interpreters use term substitution heavily, and even
compilers need to substitute types for variables in other types and in
terms. We&rsquo;ll now look at some better solutions for implementing
capture-avoiding substitution.</p>

<h2>De Bruijn Indices</h2>

<p>With explicit variables, we had to keep track of names in use and check
whether to α-vary before a collision happened. The next representation
we&rsquo;ll look at sidesteps this problem by not giving names to variables at
all! Let&rsquo;s take a look at our picture from before:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>                         <span class="err">┌──────┐</span>
</span><span class='line'>                    <span class="err">λ</span><span class="n">x</span><span class="o">.</span> <span class="err">λ</span><span class="n">y</span><span class="o">.</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>                     <span class="err">└──────┘</span></span></code></pre></td></tr></table></div></figure>


<p>In this picture, the only thing that&rsquo;s really important to us is the
binding structure; we don&rsquo;t actually care that <code>x</code> is called <code>x</code>, we
just care that applying this function sticks the argument everywhere the
line on the bottom points to. We could omit the names entirely, as long
as we can still remember where the lines should connect to:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>                        <span class="err">┌─────┐</span>
</span><span class='line'>                   <span class="p">(</span><span class="err">λ</span><span class="o">.</span> <span class="err">λ</span><span class="o">.</span> <span class="err">◆</span> <span class="o">+</span> <span class="err">◆</span><span class="p">)</span>
</span><span class='line'>                     <span class="err">└────┘</span></span></code></pre></td></tr></table></div></figure>


<p>One way of doing this is to count how many bindings sites up you have to
go before you arrive at the location the variable is bound. Under this
representation, variables are indices into a list of the binding sites;
we call these indices <strong>de Bruijn indices</strong>:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>                   <span class="p">(</span><span class="err">λ</span><span class="o">.</span> <span class="err">λ</span><span class="o">.</span> <span class="err">①</span> <span class="o">+</span> <span class="err">⓪</span><span class="p">)</span></span></code></pre></td></tr></table></div></figure>


<p><strong>Note</strong>: I&rsquo;m using circled numbers like <code>⓪</code> for the variable with de
Bruijn index <code>0</code>.</p>

<p>Under this representation, a de Bruijn index of 1 means &ldquo;skip over one
lambda&rdquo; and an index of 0 means &ldquo;skip over zero lambdas&rdquo; or simply &ldquo;go
to the closest lambda.&rdquo; In code, de Bruijn terms can be represented
with this datatype:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="kt">term</span>
</span><span class='line'>  <span class="p">=</span> <span class="nc">Var</span> <span class="kr">of</span> <span class="n">int</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">Lam</span> <span class="kr">of</span> <span class="n">term</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">App</span> <span class="kr">of</span> <span class="n">term</span> <span class="n">*</span> <span class="n">term</span></span></code></pre></td></tr></table></div></figure>


<p><code>Var</code> now takes an <code>int</code> instead of a <code>string</code>. <code>Lam</code> only takes the
body of the lambda (it used to also take a name for it&rsquo;s argument). To
refer to argument of a lambda function, we count back the appropriate
number of <code>Lam</code>s to skip over.</p>

<p>Now that all variables are represented by indices, it&rsquo;s much easier to
know which variables are free and which are bound: a variable is free if
its index is larger than the number of lambdas it&rsquo;s under.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>                  <span class="err">◀───────────────┐</span>
</span><span class='line'>                        <span class="err">┌──────┐</span>  <span class="err">│</span>
</span><span class='line'>                   <span class="p">(</span><span class="err">λ</span><span class="o">.</span> <span class="err">λ</span><span class="o">.</span> <span class="err">①</span> <span class="o">+</span> <span class="err">⓪</span><span class="p">)</span> <span class="err">③</span>
</span><span class='line'>                     <span class="err">└────┘</span></span></code></pre></td></tr></table></div></figure>


<p>The <code>③</code> is free because it&rsquo;s under zero lambdas. Put another way, if we
were keeping a list of the binding sites we&rsquo;d traverse under to reach
<code>③</code> our list would be empty, so accessing index 3 would be out of
bounds.</p>

<p>With this representation, capture avoiding substitution becomes much
more manageable.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='python'><span class='line'>  <span class="p">(</span><span class="err">λ</span><span class="o">.</span> <span class="err">λ</span><span class="o">.</span> <span class="err">①</span> <span class="o">+</span> <span class="err">⓪</span><span class="p">)</span> <span class="err">③</span>
</span><span class='line'><span class="err">→</span> <span class="p">[</span><span class="err">③</span> <span class="o">/</span> <span class="err">⓪</span><span class="p">]</span> <span class="p">(</span><span class="err">λ</span><span class="o">.</span> <span class="err">①</span> <span class="o">+</span> <span class="err">⓪</span><span class="p">)</span>
</span><span class='line'><span class="c"># We increment free variables as we descend under binders</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="o">.</span> <span class="p">[</span><span class="err">④</span> <span class="o">/</span> <span class="err">①</span><span class="p">]</span> <span class="p">(</span><span class="err">①</span> <span class="o">+</span> <span class="err">⓪</span><span class="p">)</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="o">.</span> <span class="p">([</span><span class="err">④</span> <span class="o">/</span> <span class="err">①</span><span class="p">]</span> <span class="err">①</span><span class="p">)</span> <span class="o">+</span> <span class="p">([</span><span class="err">④</span> <span class="o">/</span> <span class="err">①</span><span class="p">]</span> <span class="err">⓪</span><span class="p">)</span>
</span><span class='line'><span class="err">→</span> <span class="err">λ</span><span class="o">.</span> <span class="err">④</span> <span class="o">+</span> <span class="err">⓪</span></span></code></pre></td></tr></table></div></figure>


<p>Note how the <code>③</code> changed to a <code>④</code>: its new location in the program lies
under one extra lambda than before. Thus to refer to the same position
as at the start of the substitution, we increment to record that we&rsquo;ll
have to skip over that extra lambda. This process of adding one when
going under a binder is called <strong>lifting</strong> (or sometimes, <strong>shifting</strong>).</p>

<p>Lifting takes the guesswork out of implementing substitution. As a
bonus, we&rsquo;ve actually forced α-equivalent terms to have identical
structure! Checking for α-equivalence is now a straightforward tree
traversal: we check that both nodes are pairwise equal, then that their
children are α-equivalent.</p>

<h2>De Bruijn Indices and Lifting</h2>

<p>On the other hand, working with de Bruijn indices can still be tricky.
It&rsquo;s easy enough to remember to lift variables when substituting, but
more generally, you have to remember to lift <em>whenever</em> you put a free
variable into a context different from where it was defined. This can
get really hairy; spotting when a usage context diverges from a
definition context is a skill that&rsquo;s often learned the hard way! Namely,
by forgetting to lift somewhere, pouring over the code and the types for
hours, then finally spotting the mistake.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>To make this a little more concrete, I&rsquo;ll use a specific example. It
comes from the judgement for deciding whether two type constructors are
equivalent in System F<sub>ω</sub>. Focus on the variables and contexts
in use (don&rsquo;t pay too much attention to what the judgement actually is):</p>

<p>$$
\frac{
\Gamma, \alpha :: \kappa_1 \; \vdash \; c \, \alpha \iff c&#8217; \, \alpha :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#8217; :: \kappa_1 \to \kappa_2
}
$$</p>

<p>In words, &ldquo;to check whether type constructors <code>c</code> and <code>c'</code> are
equivalent, assume that <code>α</code> is a type constructor of kind <code>κ₁</code>, then
apply <code>α</code> to <code>c</code> and <code>c'</code> and see if you get the same result in both
cases.&rdquo; Though again, understanding this judgement is beside the point.</p>

<p>The real tricky part here is obscured by the fact that we&rsquo;re
representing variables with names instead of de Bruijn indices. If we
were to take a naive pass at translating  this rule to use de Bruijn
indices, we might end up with:</p>

<p>$$
\frac{
\Gamma, \kappa_1 \; \vdash \; c \, ⓪ \iff c&#8217; \, ⓪ :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#8217; :: \kappa_1 \to \kappa_2
}
$$</p>

<p>Note how <code>Γ</code> became a stack instead of a map because we&rsquo;re mapping
<em>indices</em> to kinds (instead of string keys to kinds). The element we
just pushed on (<code>κ₁</code>) is on the top of the stack at index <code>0</code>, and
everything else in the context can now be found at <code>index + 1</code>. That
means that above the line, <code>⓪</code> refers to the <code>κ₁</code> in the context.</p>

<p>But <code>⓪</code> might <em>also</em> be in use at the top level of <code>c</code> or <code>c'</code>! In
either of these terms, <code>⓪</code> at the top level is a free variable referring
to the first thing in <code>Γ</code>. The problem is that we&rsquo;re checking <code>c ⓪ &lt;=&gt;
c' ⓪</code> with context <code>Γ, κ₁</code> rather than <code>Γ</code>, so all our indices are off.</p>

<p>To make all the indices in <code>c</code> and <code>c'</code> route to the correct variable in
the new context, we have to go through <code>c</code> and <code>c'</code> and lift all free
variables by one to reflect the fact that we just injected something
into the surrounding context:</p>

<p>$$
\frac{
\Gamma, \kappa_1 \; \vdash \; (c \uparrow) \, ⓪ \iff (c&#8217; \uparrow) \, ⓪ :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#8217; :: \kappa_1 \to \kappa_2
}
$$</p>

<p>In this rule, <code>↑</code> is the lifting operator, which traverses through a
term&rsquo;s free variables and increments them. After it&rsquo;s run, there will be
no free variables in <code>c</code> or <code>c'</code> with index 0, which gives us room to
use <code>⓪</code> for our own purposes.</p>

<p>In some sense, this is the opposite problem that we had when we used
explicit variables. For that, we had to go through and rename <em>bound
variables</em> so that nothing clashed. Now, we have to lift <em>free
variables</em> so that nothing clashes. Put another way, explicit variables
excel at dealing with free variables, while de Bruijn indices excel at
representing bound variables.</p>

<p>The next representation we&rsquo;ll look at, locally nameless terms,
effectively steals the best of each, combining them into one
representation.</p>

<h2>Locally Nameless Terms</h2>

<p>We identified that de Bruijn indices represent bound variables well at
the expense of free variables. <strong>Locally nameless terms</strong> solve this by
giving free variables explicit names, but using indices instead of names
for bound (or &ldquo;local&rdquo;) variables, thus the name.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>Locally nameless terms might be represented by a data type like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="kt">term</span>
</span><span class='line'>  <span class="p">=</span> <span class="nc">FV</span> <span class="kr">of</span> <span class="n">string</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">BV</span> <span class="kr">of</span> <span class="n">int</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">Lam</span> <span class="kr">of</span> <span class="n">term</span>
</span><span class='line'>  <span class="p">|</span> <span class="nc">App</span> <span class="kr">of</span> <span class="n">term</span> <span class="n">*</span> <span class="n">term</span></span></code></pre></td></tr></table></div></figure>


<p><code>FV</code> constructs a free variable, and similarly <code>BV</code> constructs a bound
variable. <code>FV</code> takes a <code>string</code>, because free variables get names, and
<code>BV</code> takes an <code>int</code>, because bound variables are nameless de Bruijn
indices. As before, <code>Lam</code> only takes the body of the lambda function;
we&rsquo;ll use de Bruijn indices to count back to the appropriate binding
site of a variable.</p>

<p>In practice, locally nameless terms are best provided through a library,
where this internal implementation is hidden and the user interacts with
an abstract interface:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="c">(*</span><span class="cm"> The actual type of a locally nameless term with *)</span>
</span><span class='line'><span class="c">(*</span><span class="cm"> a distinction between FV and BV is hidden       *)</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">term</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> termView is only one level deep: after that, *)</span>
</span><span class='line'><span class="c">(*</span><span class="cm"> you end up with a term, which is abstract    *)</span>
</span><span class='line'><span class="kt">datatype</span> <span class="kt">termView</span>
</span><span class='line'>  <span class="p">=</span> <span class="n">Var</span> <span class="kr">of</span> <span class="n">string</span>
</span><span class='line'>  <span class="p">|</span> <span class="n">Lam</span> <span class="kr">of</span> <span class="n">string</span> <span class="n">*</span> <span class="n">term</span>
</span><span class='line'>  <span class="p">|</span> <span class="n">App</span> <span class="kr">of</span> <span class="n">term</span> <span class="n">*</span> <span class="n">term</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> Convert between the abstract and view types *)</span>
</span><span class='line'><span class="kr">val</span> <span class="n">out</span> <span class="p">:</span> <span class="n">term</span> <span class="p">-&gt;</span> <span class="n">termView</span>
</span><span class='line'><span class="kr">val</span> <span class="n">into</span> <span class="p">:</span> <span class="n">termView</span> <span class="p">-&gt;</span> <span class="n">term</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> Substitution and alpha equivalence work on abstract terms *)</span>
</span><span class='line'><span class="kr">val</span> <span class="n">subst</span> <span class="p">:</span> <span class="n">term</span> <span class="p">-&gt;</span> <span class="n">string</span> <span class="p">-&gt;</span> <span class="n">term</span>
</span><span class='line'><span class="kr">val</span> <span class="n">aeq</span> <span class="p">:</span> <span class="n">term</span> <span class="p">-&gt;</span> <span class="n">term</span> <span class="p">-&gt;</span> <span class="n">bool</span></span></code></pre></td></tr></table></div></figure>


<p>The fresh name generation from explicit variables is handled under the
hood by <code>out</code>. Lifting is handled automatically every time we call
<code>into</code> on a <code>Lam</code>. By only implementing operations like <code>subst</code> and
<code>aeq</code> on the abstract representations, we&rsquo;ve effectively forced the type
system to check that we lift and generate fresh names in all the right
places!</p>

<h2>Closing Considerations</h2>

<p>Locally nameless terms are generally pretty great. They blend the
strengths of explicit variables and de Bruijn indices into a new
structure that makes working with variables and binding hard to get
wrong. That being said, I&rsquo;d be remiss if I didn&rsquo;t point out two
drawbacks:</p>

<ul>
<li>Locally nameless terms can be slow.

<ul>
<li>In most code, we&rsquo;ll find ourselves converting between <code>term</code>s
and <code>termView</code>s. This brings with it the overhead of the function
call, allocating new memory for the new structures, and can even
sometimes make a linear algorithm accidentally quadratic.</li>
</ul>
</li>
<li>It&rsquo;s more annoying to use pattern matching.

<ul>
<li>Most of the time we&rsquo;ll have things of type <code>term</code>. Since <code>term</code> is
abstract, we can&rsquo;t pattern match on it directly; we have to instead
call <code>out</code> and pattern match the result.</li>
</ul>
</li>
</ul>


<p>Despite these drawbacks, I still prefer locally nameless terms.</p>

<ul>
<li><p>I&rsquo;ll gladly trade correctness for performance, and it&rsquo;s definitely
easier to be correct when working with locally nameless terms. We can
always optimize for performance later by profiling the code to find
the slowness!</p></li>
<li><p>Calling <code>out</code> in a few places is a small ergonomic price to pay for
correctness. When you forget to call <code>out</code> or <code>into</code>, the type checker
will remind you. There are also some cool language extensions which
can make calling <code>out</code> and <code>in</code> syntactically more pleasant, like
<a href="https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html">View Patterns</a> in Haskell.</p></li>
</ul>


<p>Variables show up in the most interesting places, and I always smile
when I find them being used in new and surprising ways. On the flip
side, languages that don&rsquo;t implement variables and binding suffer no end
of trouble and programmers are forced to cope with their
absence.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup></p>

<p>I think variables are just so cool!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Nearly every interesting programming language feature derives its power from variables. Functions wouldn&rsquo;t be functions if not for variables. Modularity and linking reduce to variables and substitution. I&rsquo;ve written in the past about all sorts of cool <a href="https://blog.jez.io/variables-in-types">variables in types</a>, as well as how <a href="https://blog.jez.io/system-f-param">parametric polymorphism in System F</a> is the result of using type variables in two ways within the same system.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>If it wasn&rsquo;t clear, this has happened to me many times, and yes I&rsquo;m still getting over it 😓<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>We could, by analogy, refer to the de Bruijn index representation as the globally nameless representation, which is more descriptive but isn&rsquo;t something you&rsquo;ll hear used anywhere.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>It&rsquo;s for this very reason that variables are the first topic we cover in <a href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles of Programming Languages</a>.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[System Fω and Parameterization]]></title>
    <link href="https://blog.jez.io/system-f-param/"/>
    <updated>2017-09-27T22:14:45-04:00</updated>
    <id>https://blog.jez.io/system-f-param</id>
    <content type="html"><![CDATA[<p>When I first learned about System F<sub>ω</sub>, I was confused about
the difference between <code>∀(t.τ)</code> (forall types) and <code>λ(u.c)</code> (type
abstractions) for a long time, but recently I finally grasped the
difference! Both of these constructs have to do with parameterization
(factoring out a variable so that it&rsquo;s bound), but the two types have
drastically different meanings.</p>

<!-- more -->


<h2>Questions</h2>

<p>We&rsquo;ll start off with some questions to keep in mind throughout these
notes. Our goals by the end are to understand what the questions are
asking, and have at least a partial&mdash;if not complete&mdash;answer to each.</p>

<p>First, consider this code.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">list</span> <span class="p">=</span> <span class="nc">Nil</span> <span class="p">|</span> <span class="nc">Cons</span> <span class="kr">of</span> <span class="nd">'a</span> <span class="n">*</span> <span class="nd">'a</span> <span class="n">list</span></span></code></pre></td></tr></table></div></figure>


<ul>
<li>What really is &ldquo;<code>list</code>&rdquo; in this code?</li>
<li>Or put another way, how would we define <code>list</code> in System
F<sub>ω</sub>?</li>
</ul>


<p>Thinking more broadly,</p>

<ul>
<li>What separates <code>∀(t.τ)</code> and <code>λ(u.c)</code>?</li>
<li>What is parameterization, and how does it relate to these things?</li>
</ul>


<h2>System F<sub>ω</sub></h2>

<p>The answers to most of these questions rely on a solid definition of
System F<sub>ω</sub>. We&rsquo;ll be using this setup.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>Kind κ ::= * | κ → κ | ···
</span><span class='line'>
</span><span class='line'>           abstract       concrete      arity/valence
</span><span class='line'>Con c  ::= ···
</span><span class='line'>         | arr(c₁; c₂)    c₁ → c₂       (Con, Con)Con
</span><span class='line'>         | all{κ}(u.c)    ∀(u ∷ κ). c   (Kind, Con.Con)Con
</span><span class='line'>         | lam{κ}(u.c)    λ(u ∷ κ). c   (Kind, Con.Con)Con
</span><span class='line'>         | app(c₁; c₂)    c₁(c₂)        (Con, Con)Con</span></code></pre></td></tr></table></div></figure>


<p>Some points to note:</p>

<ul>
<li><code>∀(u ∷ κ). c</code> and <code>λ(u ∷ κ). c</code> have the same arity.</li>
<li><code>∀(u ∷ κ). c</code> and <code>λ(u ∷ κ). c</code> both <em>bind</em> a constructor variable.
This makes these two operators <em>parametric</em>.</li>
<li>Only <code>λ(u ∷ κ). c</code> has a matching elim form: <code>c₁(c₂)</code>.
(There are no elim forms for <code>c₁ → c₂</code> and <code>∀(u ∷ κ). c</code>, because they
construct types of kind <code>*</code>. This will be important later.)</li>
</ul>


<p>It&rsquo;ll also be important to have these two inference rules for kinding:</p>

<p>$$
\frac{
  \Delta, u :: \kappa \vdash c :: *
}{
  \Delta \vdash \forall(u :: \kappa). \, c :: *
}\;(\texttt{forall-kind})
$$
$$
\frac{
  \Delta, u :: \kappa \vdash c :: \kappa&#8217;
}{
  \Delta \vdash \lambda(u :: \kappa). \, c :: \kappa \to \kappa&#8217;
}\;(\texttt{lambda-kind})
$$</p>

<h2>Defining the <code>list</code> Constructor</h2>

<p>Let&rsquo;s take another look at this datatype definition from above:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">datatype</span> <span class="nd">'a</span> <span class="kt">list</span> <span class="p">=</span> <span class="nc">Nil</span> <span class="p">|</span> <span class="nc">Cons</span> <span class="kr">of</span> <span class="nd">'a</span> <span class="n">*</span> <span class="nd">'a</span> <span class="n">list</span></span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;ve <a href="https://blog.jez.io/variables-in-types/">already seen</a> how to encode the type of lists
of integers using inductive types:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>intlist = μ(t. 1 + (int × t))</span></code></pre></td></tr></table></div></figure>


<p>Knowing what we know about System F (the &ldquo;<strong>polymorphic</strong> lambda
calculus&rdquo;), our next question should be &ldquo;how do we encode
<strong>polymorphic</strong> lists?&rdquo; Or more specifically, which of these two
operators (<code>λ</code> or <code>∀</code>) should we pick, and why?</p>

<p>First, we should be more specific, because there&rsquo;s a difference between
<code>list</code> and <code>'a list</code>. Let&rsquo;s start off with defining <code>list</code> in
particular. From what we know of programming in Standard ML, we can do
things like:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="c">(*</span><span class="cm"> Apply 'int' to 'list' function! *)</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">grades</span> <span class="p">=</span> <span class="n">int</span> <span class="n">list</span>
</span><span class='line'>
</span><span class='line'><span class="kr">type</span> <span class="kt">key</span> <span class="p">=</span> <span class="n">string</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">val</span> <span class="p">=</span> <span class="n">real</span>
</span><span class='line'>
</span><span class='line'><span class="c">(*</span><span class="cm"> Apply '(key, val)' to 'list' function! *)</span>
</span><span class='line'><span class="kr">type</span> <span class="kt">updates</span> <span class="p">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kr">val</span><span class="p">)</span> <span class="n">list</span></span></code></pre></td></tr></table></div></figure>


<p>If we look really closely, what&rsquo;s actually happening here is that <code>list</code>
is a type-level <em>function</em> that returns a type (and we use the <code>type foo
= ...</code> syntax to store that returned type in a variable).<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Since <code>list</code> is actually a function from types to types, it must have
an arrow kind: <code>* → *</code>. Looking back at our two inference rules for
kinding, we see only one rule that lets us introduce an arrow kind: <code>λ(u
∷ κ). c</code>. On the other hand, <code>∀(u ∷ κ). c</code> must have kind <code>*</code>; it
<em>can&rsquo;t</em> be used to define type constructors.</p>

<p>Step 1: define list constructor? Check:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>list = λ(α ∷ *). μ(t. 1 + (α × t)))</span></code></pre></td></tr></table></div></figure>


<h2>Defining Polymorphic Lists</h2>

<p>It doesn&rsquo;t stop with the above definition, because it&rsquo;s still not
<em>polymorphic</em>. In particular, we can&rsquo;t just go write functions on
polymorphic lists with code like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">fun</span> <span class="nf">foo</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span></span></code></pre></td></tr></table></div></figure>


<p>We can&rsquo;t say <code>x : list</code> because all intermediate terms in a given
program have to type check as a type of kind <code>*</code>, whereas <code>list ∷ * →
*</code>. Another way of saying this: there isn&rsquo;t any way to introduce a value
of type <code>list</code> because there&rsquo;s no way to introduce values with arrow
kinds.</p>

<p>Meanwhile, we <em>can</em> write this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">fun</span> <span class="nf">foo</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nd">'a</span> <span class="n">list</span><span class="p">)</span> <span class="p">=</span> <span class="c">(*</span><span class="cm"> ··· *)</span></span></code></pre></td></tr></table></div></figure>


<p>When you get down to it, this is actually kind of weird. Why is it okay
to use <code>'a list</code>? I never defined <code>'a</code> anywhere, so wouldn&rsquo;t that make
it an unbound variable?</p>

<p>It turns out that when we use type variables like this, SML
automatically binds them for us by inserting <code>∀</code>s into our code. In
particular, it implicitly infers a type like this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='sml'><span class='line'><span class="kr">val</span> <span class="nv">foo</span> <span class="p">:</span> <span class="n">forall</span> <span class="nd">'a</span><span class="err">.</span> <span class="nd">'a</span> <span class="n">list</span> <span class="p">-&gt;</span> <span class="p">()</span></span></code></pre></td></tr></table></div></figure>


<p>SML inserts this <code>forall</code> automatically because its type system is a bit
less polymorphic than System F<sub>ω</sub>&rsquo;s. Some might call this a
drawback, though it does save us from typing <code>forall</code> annotations
ourselves. And really, for most anything else we&rsquo;d call a &ldquo;drawback&rdquo; of
this design, SML makes up the difference with modules.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Step 2: make polymorphic list for use in annotation? Check:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>α list = ∀(α ∷ *). list(α)</span></code></pre></td></tr></table></div></figure>


<h2>Variables &amp; Parameterization</h2>

<p>Tada! We&rsquo;ve figured out how to take a list datatype from SML and encode
it in System F<sub>ω</sub>, using these two definitions:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>  list = λ(α ∷ *). μ(t. 1 + (α × t)))
</span><span class='line'>α list = ∀(α ∷ *). list(α)</span></code></pre></td></tr></table></div></figure>


<p>We could end here, but there&rsquo;s one more interesting point. If we look
back, we started out with the <code>∀</code> and <code>λ</code> operators having the same
arity, but somewhere along the way their behaviors differed. <code>λ</code> was
used to create type constructors, while <code>∀</code> was used to introduce
polymorphism.</p>

<p>Where did this split come from? What distinguishes <code>∀</code> as being the
go-to type for polymorphism, while <code>λ</code> makes type constructors
(type-to-type functions)? Recall one of the earliest ideas we teach in
<a href="http://www.cs.cmu.edu/~rwh/courses/ppl/">15-312</a>:</p>

<blockquote><p>&hellip; the core idea carries over from school mathematics, namely
that <strong>a variable is an unknown, or a place-holder, whose meaning is
given by substitution.</strong></p>

<p>&ndash; Harper, <em>Practical Foundations for Programming Languages</em></p></blockquote>

<p>Variables are given meaning by substitution, so we can look to the
appropriate substitutions to uncover the meaning and the differences
between <code>λ</code> and <code>∀</code>. Let&rsquo;s first look at the substitution for <code>λ</code>:</p>

<p>$$
\frac{
  \Delta, u :: \kappa_1 \vdash c_2 :: \kappa_2 \qquad \Delta \vdash c_1
  :: \kappa_1
}{
  \Delta \vdash (\lambda(u :: \kappa_1). \, c_2)(c_1) \equiv  [c_1/u]c_2 :: \kappa_2
}
$$</p>

<p>We can think of this as saying &ldquo;when you apply one type to another, the
second type gets full access to the first type to construct a new type.&rdquo;
We notice that the substitution here is completely <strong>internal to the
type system</strong>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>On the other hand, the substitution for <code>∀</code> <strong>bridges the gap</strong> from
types to terms:</p>

<p>$$
\frac{
  \Delta \, \Gamma, e : \forall (u :: \kappa). \tau \qquad \Delta \vdash c :: \kappa
}{
  \Delta \, \Gamma \vdash e[c] : [c/u]\tau
}
$$
$$
\frac{
  \mbox{}
}{
  (\Lambda u. \, e)[\tau] \mapsto [\tau / u]e
}
$$</p>

<p>When we&rsquo;re type checking a polymorphic type application, we don&rsquo;t get to
know anything about the type parameter <code>u</code> other than its kind. But when
we&rsquo;re running a program and get to the evaluation of a polymorphic type
application, we substitute the concrete <code>τ</code> directly in for <code>u</code> in <code>e</code>,
which bridges the gap from the type-level to the term-level.</p>

<p>At the end of the day, all the interesting stuff came from using
functions (aka, something parameterized by a value) in cool ways. Isn&rsquo;t
that baffling? Functions are so powerful that they seem to always pop up
at the heart of the most interesting constructs. I think it&rsquo;s
straight-up amazing that something so simple can at the same time be
that powerful. Functions!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>It&rsquo;s easy to not notice at first that type definitions are really function calls because in Standard ML, the type function applications are backwards. Instead of <code>f(x)</code>, it&rsquo;s <code>x f</code>. This is more similar to how we actually think when we see a function. Consider <code>h(g(f(x)))</code> (or another way: <code>h . g . f $ x</code>). We read this as &ldquo;take x, do f, pass that to g, and pass that to h&rdquo;. Why not write <code>x f g h</code> in the first place?<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Other languages (like Haskell or PureScript) have a language feature called &ldquo;Rank-N Types&rdquo; which is really just a fancy way of saying &ldquo;you can put the <code>forall a.</code> anywhere you want.&rdquo; Oftentimes, this makes it harder for the compiler to infer where the variable bindings are, so you sometimes have to use more annotations than you might if you weren&rsquo;t using Rank-N types.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>It&rsquo;s not super relevant to this discussion, but this inference rule is for the judgement defining equality of type constructors. This comes up all over the place when you&rsquo;re writing a compiler for SML. If this sounds interesting, definitely take 15-417 HOT Compilation!<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Variables in Types]]></title>
    <link href="https://blog.jez.io/variables-in-types/"/>
    <updated>2017-09-25T05:17:31-04:00</updated>
    <id>https://blog.jez.io/variables-in-types</id>
    <content type="html"><![CDATA[<p>These are some recitation notes for an ad-hoc recitation I gave for the
class <a href="http://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles of Programming Languages</a>. It was probably
my favorite 312 recitation content-wise, because it&rsquo;s the first
recitation where we&rsquo;ve covered enough stuff to where we can really start
connecting the dots.</p>

<p><strong>Abstract</strong>:</p>

<blockquote><p>We&rsquo;ve seen a number of examples in class of types which use variables.
Having variables in our type systems lends a great deal of power to
languages using these type systems. We&rsquo;re going to look at how
variables are used in generic programming, inductive &amp; coinductive
types, and polymorphic types.</p></blockquote>

<h3>→ <a href="https://blog.jez.io/notes/variables-in-types.pdf">Variables in Types</a></h3>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recitation Notes]]></title>
    <link href="https://blog.jez.io/recitation-notes-tag/"/>
    <updated>2017-09-24T17:40:10-04:00</updated>
    <id>https://blog.jez.io/recitation-notes-tag</id>
    <content type="html"><![CDATA[<!-- Empty header to prevent first paragraph from being big -->


<p></p>


<p>One thing I miss from being a teaching assistant is getting to write up
recitation and lecture notes for technical topics. Like with teaching
any other subject, writing up explanations for interesting things I&rsquo;ve
found helps me round out what concepts are still confusing. I also miss
getting to make nice LaTeX-typeset PDFs.</p>

<!-- more -->


<p>Recitation notes are distinguished from normal blog posts in that
they&rsquo;ll cover more CS theory-oriented topics and will be more
<em>instructive</em> than <em>experience-based</em>. All recitation notes are tagged
with the tag <code>recitation</code>.</p>

<h3>→ <a href="https://blog.jez.io/categories/#recitation">All posts tagged with <code>recitation</code></a></h3>

<p>I might &ldquo;cross post&rdquo; a few of the more interesting existing recitation
handouts I&rsquo;ve made over the years (though some of them make a
heavy-handed assumption that you&rsquo;re in the class currently).</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing, Types, & Correctness]]></title>
    <link href="https://blog.jez.io/testing-types/"/>
    <updated>2017-09-10T19:50:36-04:00</updated>
    <id>https://blog.jez.io/testing-types</id>
    <content type="html"><![CDATA[<p>Understanding correctness of code really comes down to <em>proving</em> that
the code does the right thing. What tools do we have as programmers for
proving the correctness of our code?</p>

<!-- more -->


<ol>
<li><strong>Unit tests</strong> prove that the code is correct for specific inputs.</li>
<li><strong>Type systems</strong> prove the absence of (certain kinds of)
incorrectness.</li>
<li><strong>Theorem provers</strong> prove sophisticated claims about our code for
us.</li>
<li><strong>Program authors</strong> can prove the correctness of their code (i.e.,
with a traditional pen-and-paper proof).</li>
</ol>


<p>The first three are exciting because they involve a computer doing most
of the work for us! That said, none of the first three are as
universally applicable as the last: doing the proof ourself.
Unfortunately, it&rsquo;s also usually the most toilsome.</p>

<p>Note the double negation in (2). Type systems themselves don&rsquo;t prove
correctness, they prove that there aren&rsquo;t certain kinds of
incorrectness, namely: type errors. Meanwhile, unit tests are rarely (if
ever) exhaustive. This is why testing and type systems are
complementary&mdash;one is not a substitute for the other.</p>

<p>It&rsquo;s important to both have strong testing practices and languages with
disciplined type systems. The hardest part of writing quality software
is ensuring that it runs without bugs. The more tools we have in our
arsenal to combat incorrectness, the easier it is to write code for the
long term.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[If, Else, & Purity]]></title>
    <link href="https://blog.jez.io/if-else-purity/"/>
    <updated>2017-09-01T01:38:43-04:00</updated>
    <id>https://blog.jez.io/if-else-purity</id>
    <content type="html"><![CDATA[<p>I prefer to let the language I&rsquo;m using think on my behalf as much as
possible. Ideally, the language is rich enough that the proof of
correctness is inherent in the code I&rsquo;ve written. Even when I use
looser languages, these principled languages inform the structure of my
code. To make this a bit more let&rsquo;s turn our focus to <code>if</code>, <code>else</code>, and
purity.</p>

<!-- more -->


<p>A cool way to understand purity is using what&rsquo;s known as a &ldquo;modal
separation.&rdquo; This is a really fancy way to say that we have
<strong>expressions</strong> which are pure and always evaluate to a value, alongside
<strong>commands</strong> which are impure and are executed for their side effects.
If you&rsquo;ve ever used Haskell, you&rsquo;re already familiar with this
notion&mdash;we only need <code>do</code> notation when we need to write impure (or
&ldquo;monadic&rdquo;) code.</p>

<p>In an expression language, every <code>if</code> <em>must</em> have an <code>else</code>; for the
entire <code>if</code> expression to be used as a value, both branches must in turn
evaluate to values. It&rsquo;s only when we move to a language with commands
where it makes sense to allow omitting the <code>else</code> branch. <code>if</code>
expressions are not some abstract concept; chances are you&rsquo;ve
encountered them under the name &ldquo;the ternary operator.&rdquo;</p>

<p>An <code>if</code> <em>statement</em> (as opposed to an <code>if</code> expression) is a command;
it&rsquo;s useful for running side-effectful code. Sometimes, we don&rsquo;t want
one of the branches to have any side effects (for example, because the
state of the world doesn&rsquo;t need to be changed). Languages with commands
allow omitting the <code>else</code>.</p>

<p>What does this mean for us? Since expression languages form the basis
for purity, every pure function can be written where the <code>if</code> is matched
with an <code>else</code>. Put another way, an unmatched <code>if</code> is a likely indicator
that the code I&rsquo;ve written is impure.</p>

<p>This makes me more aware of when I&rsquo;m dealing with impure code. For
example, I might want to factor out as much of the pure code into a
separate helper function. There&rsquo;s a time and a place for impure code.
But since pure code is more composable and easier to test, it&rsquo;s best to
factor the impure code out whenever possible.</p>

<p>In a principled language, there&rsquo;s a distinction between <code>if</code> expressions
and <code>if</code> statements. On the other hand, some language only have one, or
they blur the line between the two. We can draw upon our experiences
with languages that are rigorous about minutia like this to better
inform how we write clean code.</p>

<!-- vim:tw=72
-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Development with Neovim]]></title>
    <link href="https://blog.jez.io/haskell-development-with-neovim/"/>
    <updated>2017-07-16T14:45:31-04:00</updated>
    <id>https://blog.jez.io/haskell-development-with-neovim</id>
    <content type="html"><![CDATA[<p>Configuring an editor for a new language is a double-edged sword: it&rsquo;s intensely
satisfying when done, but takes time away from diving into the language itself!
After using Haskell for a little over a year, I&rsquo;ve settled on a high-quality set
of editor plugins. They&rsquo;re simple, powerful, and all play nicely together.</p>

<!-- more -->


<h2>Requirements</h2>

<p>I use <a href="https://www.haskellstack.org/">Haskell Stack</a> exclusively. Stack&rsquo;s goal is reproducible builds,
which means that in general, things Just Work.</p>

<p>I also use <a href="https://github.com/neovim/neovim">Neovim</a>, rather than normal Vim. Usually, my justification
is ideological rather than technical. However, for Haskell my setup <strong>requires</strong>
Neovim. Fear not! Neovim is feature-packed and also very stable. I love Neovim,
and I&rsquo;ll be writing more about why in a future post.</p>

<p>By the way, new to Vim plugins? I happen to have <a href="https://github.com/jez/vim-as-an-ide">just the post for
you</a>!</p>

<!-- TODO(jez): Update with link to Neovim post -->


<h2>Overview</h2>

<p>We&rsquo;re going to move in order of increasing complexity. That said, even the most
&ldquo;complex&rdquo; plugin here is actually quite painless to set up. By the end, we&rsquo;ll
have a complete development experience! Coming up:</p>

<ul>
<li>syntax highlighting &amp; indentation (<strong><a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a></strong>)</li>
<li>auto-formatting &amp; style (<strong><a href="https://github.com/commercialhaskell/hindent">hindent</a>, <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a></strong>)</li>
<li>quickfix and sign column support (<strong>using <a href="https://github.com/w0rp/ale">ale</a></strong>) for:

<ul>
<li>linter style suggestions (<strong>hlint</strong>)</li>
<li>compiler errors and warnings (<strong>ghc-mod</strong>)</li>
</ul>
</li>
<li>Type inspection, REPL integration, and more! (<strong><a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></strong>)</li>
</ul>


<p>To keep things concise, I&rsquo;ve moved all the relevant configuration to the end of
the post. For now, let&rsquo;s start at the top.</p>

<!-- TODO(jez) Demonstrate everything with an asciicast -->


<h2>Syntax Highlighting &amp; Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
</ul>


<p>Vim&rsquo;s default Haskell filetype plugin is pretty lack luster. Everything is blue,
except for strings which are colored like comments, and keywords which are
colored like constants. Indentation is wonky in some cases, and isn&rsquo;t
configurable.</p>

<p>This plugin corrects all that. It&rsquo;s the filetype plugin for Haskell that
<strong>should</strong> ship with Vim.</p>

<p>Not only does it come with saner defaults, it also comes with more config
options, especially for indentation. This is important because it lets me
tweak the automatic indentation to my own personal style.</p>

<p>(Remember: all the config is at the end of the post.)</p>

<h2>Auto-formatting and Indentation</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/alx741/vim-hindent">vim-hindent</a></li>
<li><strong>Tool</strong>: <code>stack install hindent</code></li>
<li><strong>Tool</strong>: <code>stack install stylish-haskell</code></li>
</ul>


<p>For small projects, I have an idea of what style I like best. However, for
larger projects it&rsquo;s unfair to ask contributors that they learn the ins and outs
of my style. Situations like these call for automated solutions.</p>

<p><code>go fmt</code> famously solved this problem for Golang by building the formatting tool
into the compiler. For Haskell, there&rsquo;s <a href="https://github.com/commercialhaskell/hindent">hindent</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. <code>hindent</code> can be
installed through Stack, and <code>vim-hindent</code> is a Vim plugin that shims it.</p>

<p>But I said I&rsquo;m partial to my own style in personal projects. There&rsquo;s another
Haskell formatter that&rsquo;s much less invasive: <a href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>. It basically
only reformats <code>import</code>s, <code>case</code> branches, and record fields, aligning them
vertically. And in fact, it&rsquo;s possible to use this alongside <code>hindent</code>.</p>

<p>With these three tools, I can pick the right tool for the job:</p>

<ul>
<li><strong>Hand saw</strong>: let <code>haskell-vim</code> config control the indentation</li>
<li><strong>Table saw</strong>: run <code>stylish-haskell</code> only</li>
<li><strong>Chainsaw</strong>: run <code>hindent</code> only</li>
<li><strong>Chainsaw, then sand paper</strong>: run <code>hindent</code>, then <code>stylish-haskell</code></li>
</ul>


<p>Getting them to play together requires a bit of config, so I&rsquo;ve included mine at
the end of the post.</p>

<h2>Quickfix &amp; Sign Columns</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/w0rp/ale">ale</a></li>
<li><strong>Tool</strong>: <code>stack install hlint</code></li>
<li><strong>Tool</strong>: <code>stack build ghc-mod</code>

<ul>
<li>N.B.: This is <em>build</em> not <em>install</em> here<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</li>
</ul>
</li>
</ul>


<p>This step requires <em>either</em> Neovim or Vim 8; ALE stands for &ldquo;Asynchronous Lint
Engine,&rdquo; so it&rsquo;s using the new asynchronous job control features of these two
editors. It&rsquo;s like an asynchronous Syntastic<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>ALE ships with a number of Haskell integrations by default. For example, it can
show errors if only Stack is installed. I prefer enabling two of ALE&rsquo;s Haskell
integrations: <code>hlint</code> and <code>ghc-mod</code>.</p>

<ul>
<li><code>hlint</code> is a linter for Haskell. It warns me when I try to do silly things
like <code>if x then True else False</code>.</li>
<li><code>ghc-mod</code> is a tool that can check files for compiler errors.</li>
</ul>


<p>The beauty of ALE is that it works almost entirely out of the box. The only real
setup is to tell ALE to use only these two integrations explicitly. I&rsquo;ve
included the one-liner to do this in the config at the bottom.</p>

<h2>Intero: The Pièce de Résistance</h2>

<ul>
<li><strong>Plugin</strong>: <a href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></li>
</ul>


<p>Intero is a complete development program for Haskell. It started as an Emacs
package, but has been ported almost entirely to Neovim. Probably the best way to
introduce it is with this asciicast:</p>

<p align="center">
  <a href="https://asciinema.org/a/128416">
    <img
      width="700px"
      alt="Intero for Neovim asciicast"
      src="https://asciinema.org/a/128416.png">
  </a>
</p>


<p>Intero is designed for stack, sets itself up automatically, has point-and-click
type information, and lets me jump to identifier definitions. On top of it all,
it uses Neovim to communicate back and forth with a terminal buffer so that I
get a GHCi buffer <strong>right inside Neovim</strong>. For Emacs users, this is nothing new
I&rsquo;m sure. But having the REPL in my editor continues to blow my mind 😮.</p>

<p>Developing with the REPL in mind helps me write better code. Only top-level
bindings are exposed in the REPL, so I write more small, testable functions.
See here for more reasons <a href="http://chrisdone.com/posts/haskell-repl">why the REPL is awesome</a>.</p>

<p>On top of providing access to the REPL, Intero provides about a dozen
convenience commands that shell out to the REPL backend asynchronously. Being
able to reload my code in the REPL&mdash;from Vim, with a single keystroke!&mdash;is a
huge boon when developing.</p>

<p>Intero takes a little getting used to, so be sure to read the docs for some
sample workflows. Intero also sets up no mappings by default, so I&rsquo;ve included
my settings below.</p>

<h2>The Eagerly-Awaited Config</h2>

<p>And without further ado&hellip;</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='vim'><span class='line'><span class="c">" ----- neovimhaskell/haskell-vim -----</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Align 'then' two spaces after 'if'</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_if</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="c">" Indent 'where' block two spaces under previous body</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_before_where</span> <span class="p">=</span> <span class="m">2</span>
</span><span class='line'><span class="c">" Allow a second case indent style (see haskell-vim README)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_case_alternative</span> <span class="p">=</span> <span class="m">1</span>
</span><span class='line'><span class="c">" Only next under 'let' if there's an equals sign</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:haskell_indent_let_no_in</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'><span class="c">" ----- hindent &amp; stylish-haskell -----</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Indenting on save is too aggressive for me</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:hindent_on_save</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Helper function, called below with mappings</span>
</span><span class='line'><span class="k">function</span><span class="p">!</span> HaskellFormat<span class="p">(</span>which<span class="p">)</span> abort
</span><span class='line'>  <span class="k">if</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'hindent'</span> <span class="p">||</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'both'</span>
</span><span class='line'>    <span class="p">:</span>Hindent
</span><span class='line'>  <span class="k">endif</span>
</span><span class='line'>  <span class="k">if</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'stylish'</span> <span class="p">||</span> <span class="nv">a:which</span> <span class="p">==</span># <span class="s1">'both'</span>
</span><span class='line'>    <span class="k">silent</span><span class="p">!</span> exe <span class="s1">'undojoin'</span>
</span><span class='line'>    <span class="k">silent</span><span class="p">!</span> exe <span class="s1">'keepjumps %!stylish-haskell'</span>
</span><span class='line'>  <span class="k">endif</span>
</span><span class='line'><span class="k">endfunction</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Key bindings</span>
</span><span class='line'>augroup haskellStylish
</span><span class='line'>  <span class="k">au</span><span class="p">!</span>
</span><span class='line'>  <span class="c">" Just hindent</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">hi</span> <span class="p">:</span>Hindent<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="c">" Just stylish-haskell</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>hs <span class="p">:</span><span class="k">call</span> HaskellFormat<span class="p">(</span><span class="s1">'stylish'</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="c">" First hindent, then stylish-haskell</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>hf <span class="p">:</span><span class="k">call</span> HaskellFormat<span class="p">(</span><span class="s1">'both'</span><span class="p">)&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>augroup END
</span><span class='line'>
</span><span class='line'><span class="c">" ----- w0rp/ale -----</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nv">g:ale_linters</span><span class="p">.</span>haskell <span class="p">=</span> <span class="p">[</span><span class="s1">'stack-ghc-mod'</span><span class="p">,</span> <span class="s1">'hlint'</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="c">" ----- parsonsmatt/intero-neovim -----</span>
</span><span class='line'>
</span><span class='line'><span class="c">" Prefer starting Intero manually (faster startup times)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:intero_start_immediately</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="c">" Use ALE (works even when not using Intero)</span>
</span><span class='line'><span class="k">let</span> <span class="nv">g:intero_use_neomake</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>augroup interoMaps
</span><span class='line'>  <span class="k">au</span><span class="p">!</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>io <span class="p">:</span>InteroOpen<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>iov <span class="p">:</span>InteroOpen<span class="p">&lt;</span>CR<span class="p">&gt;&lt;</span>C<span class="p">-</span>W<span class="p">&gt;</span>H
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>ih <span class="p">:</span>InteroHide<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">is</span> <span class="p">:</span>InteroStart<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>ik <span class="p">:</span>InteroKill<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>wr <span class="p">:</span><span class="k">w</span> \<span class="p">|</span> <span class="p">:</span>InteroReload<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">il</span> <span class="p">:</span>InteroLoadCurrentModule<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">if</span> <span class="p">:</span>InteroLoadCurrentFile<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell map <span class="p">&lt;</span>leader<span class="p">&gt;</span><span class="k">t</span> <span class="p">&lt;</span>Plug<span class="p">&gt;</span>InteroGenericType
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell map <span class="p">&lt;</span>leader<span class="p">&gt;</span>T <span class="p">&lt;</span>Plug<span class="p">&gt;</span>InteroType
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>it <span class="p">:</span>InteroTypeInsert<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>jd <span class="p">:</span>InteroGoToDef<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span><span class="k">silent</span><span class="p">&gt;</span> <span class="p">&lt;</span>leader<span class="p">&gt;</span>iu <span class="p">:</span>InteroUses<span class="p">&lt;</span>CR<span class="p">&gt;</span>
</span><span class='line'>  <span class="k">au</span> <span class="nb">FileType</span> haskell nnoremap <span class="p">&lt;</span>leader<span class="p">&gt;</span>ist <span class="p">:</span>InteroSetTargets<span class="p">&lt;</span>SPACE<span class="p">&gt;</span>
</span><span class='line'>augroup END</span></code></pre></td></tr></table></div></figure>


<h2>Wrap Up</h2>

<p>With these tools, I feel empowered (rather than hindered) when I sit down to
work with Haskell.</p>

<ul>
<li>The entire setup uses Stack, so things Just Work.

<ul>
<li>As a consequence, everything works with the implicit global Stack project!</li>
</ul>
</li>
<li>It scales up in power:

<ul>
<li>From simple syntax highlighting and manual indentation&hellip;</li>
<li>to an indentation chainsaw and a <strong>REPL embeded in the editor</strong>!</li>
</ul>
</li>
<li>I can take full advantage of all my tools working together, leading to cleaner
code and fewer frustrations.</li>
</ul>


<p>Now that I&rsquo;m finally at a point where I can stop fretting about my Haskell
setup, I&rsquo;ll have more time to explore the language and write about my
experience.</p>

<p>Haskell-the-language isn&rsquo;t quite on the same level as SML-the-language, but it&rsquo;s
far and above when comparing by tooling support. I&rsquo;m looking forward to taking
advantage of that!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>While listed under &ldquo;neovimhaskell&rdquo; on GitHub, this plugin works with normal Vim, too.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Chris Done explains the appeal of solving style issues with tooling for Haskell well. The moral of the story is that hindent version 5 ships with only the most popular style formatter in an effort to arrive at a singular Haskell style: <a href="http://chrisdone.com/posts/hindent-5">http://chrisdone.com/posts/hindent-5</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>We want to install <code>ghc-mod</code> once in every project. It can be done globally, but it might get out of sync with the current project.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>Some people are familiar with Neomake for this task. However, Neomake is much more minimal than ALE. Neomake basically only builds, whereas ALE is more configurable and hackable.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
