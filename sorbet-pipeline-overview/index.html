
<!DOCTYPE html>

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>How Sorbet Works: An Overview - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="TODO">

<meta name="keywords" content="sorbet compilers ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->

  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="https://blog.jez.io/touch-icon.png">
  <meta name="twitter:title" content="How Sorbet Works: An Overview">
  <meta name="twitter:description" content="TODO">
  <meta name="twitter:creator" content="@jez_io">


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/sorbet-pipeline-overview">
<meta property="og:title" content="How Sorbet Works: An Overview">
<meta property="og:description" content="TODO">
<meta property="og:image" content="https://blog.jez.io/touch-icon.png">
<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/sorbet-pipeline-overview">
<link href="/touch-icon.png" rel="apple-touch-icon-precomposed">
<link href="/favicon@2x.png" rel="icon" sizes="32x32">
<link href="/favicon.png" rel="icon" sizes="16x16">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">




</head>

<body id="post" class="strong-keywords">

<nav class="Navigation">
  <ul class="Tags">
    
      <li class="Tag">
        
          <a href="/">Home</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="/categories/">Categories</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="https://jez.io">About</a>
        
      </li>
    
  </ul>
</nav>





<div class="EntryHeader">
  <h1 class="EntryHeader-title">How Sorbet Works: An Overview</h1>
  <h2 class="EntryHeader-subtitle">January 1, 2020</h2>

  <ul class="Tags">
    
  </ul>
</div>



<div id="main" role="main">
  <article class="Post-content">
    <p></p>




<!-- more -->


<p><a href="https://sorbet.org">Sorbet</a> is the coolest project I&rsquo;ve ever worked on. There&rsquo;s so much that I want to write about, but every time I start I wind up re-explaining the same basic things about how Sorbet works. I could skip explaining it, but then the posts would only be decipherable to people who already know how Sorbet works&hellip; an audience of maybe a dozen.</p>

<p>Instead, I&rsquo;ve factored out a helper post, so to speak. I&rsquo;d like to walk through the struture of Sorbet from a pretty high level with a goal of appealing to a wider audience. It&rsquo;s going to be matter-of-fact, which means kind of boring. I could point out a lot of cool, fun things along the way, but I&rsquo;m afraid that I&rsquo;d digress without end.</p>

<p>If this post gets boring, sorry! In that case, you might want to read one of these posts instead which pack more of a punchline. Just refer back to this one when it assumes you know about how Sorbet works:</p>

<ul>
<li><a href="/ruby-mutation/">What makes type checking Ruby hard?</a></li>
<li>&hellip; more coming soon!</li>
</ul>


<!-- TODO(jez) Potential forward reference -->


<p>On the other hand, if you&rsquo;re reading this with a hope to eventually make a contribution to Sorbet, we have much more detailed <a href="https://github.com/sorbet/sorbet/tree/master/docs/internals.md">docs on the internals</a> that we use for spinning up new team members. If this post isn&rsquo;t detailed enough for you, try those docs instead!</p>

<p><a href="https://github.com/sorbet/sorbet/tree/master/docs/internals.md">→ internals.md (for Sorbet contributors)</a></p>

<p>With all that out of the way, let&rsquo;s dive in. We&rsquo;ll start with quick crash course in some terms that I use from time to time, and then step through Sorbet&rsquo;s implementation.</p>

<h2>Crash course in compilers</h2>

<p>If you took a programming languages or compilers course in school, the hope is that&rsquo;s more than enough qualification to understand this post. If you didn&rsquo;t, here&rsquo;s a 30 second summary:</p>

<ul>
<li><p>Sorbet is not a compiler, but the techniques it implements are the same. So most of the terminology that applies to compiler implementations applies to Sorbet&rsquo;s implementation too.</p></li>
<li><p>IR stands for <strong><a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a></strong>. IRs are basically data structures representing a program the user wrote that a compiler manipulates. A compiler frequently has one or more IRs, depending on the kind of analysis that needs to be done.</p></li>
<li><p>AST stands for <strong><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a></strong>. ASTs are a kind of IR. As IRs go, ASTs usually resemble what the user typed in pretty closely, but as an explicit tree data structure instead of plain text.</p></li>
<li><p>Compilers typically operate as a pipeline. Data flows from one pass to the next, getting processed and converted through one or more IRs along the way.</p></li>
<li><p>Compilers emit machine executable code at the end of the pipeline, but Sorbet is not a compiler because it doesn&rsquo;t do that: it just type checks the code. The Ruby VM executes the original program on its own.</p></li>
</ul>


<p>If there&rsquo;s a term or concept in this post that you don&rsquo;t understand, please let me know! Chances are you&rsquo;re not the only one, and I&rsquo;m happy to update my post to make sense to more people.</p>

<h2>How Sorbet works</h2>

<p><a href="/images/sorbet-pipeline-overview/01-pipeline-simple.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/01-pipeline-simple.png">
</a></p>

<p>Like I said in the compiler crash course above, Sorbet is structured like a compiler. It reads Ruby files in at the start, and then sends them through a series of passes. But because it&rsquo;s just a type checker not a compiler, it doesn&rsquo;t produce an artifact at the end of the pipeline. The only thing left over is the stream of errors reported on standard error.</p>

<p>Sorbet has a lot of passes in its pipeline, but it&rsquo;s convenient to group them into three big phases: <strong>Index</strong>, <strong>Resolve</strong>, and <strong>Typecheck</strong>. Importantly though, it&rsquo;s a pipeline. At this granularity, the arrows in our diagram only point forwards—there are no back edges from a later phase to an earlier phase. (This is true even if we zoomed into these phases to see the individual passes they&rsquo;re made of, which might be the subject of another post.)</p>

<!-- TODO(jez) Potential forward reference -->


<p>&hellip; And that&rsquo;s it! That&rsquo;s Sorbet&rsquo;s architecture at a high level.</p>

<p>Of course, you were hoping to learn more, so we&rsquo;ll spend the rest of the article talking about what specifically Index, Resolve, and Typecheck do. Our diagram will get a little more cluttered, but at its core it&rsquo;s these three steps.</p>

<h2>Index</h2>

<p><a href="/images/sorbet-pipeline-overview/02-index.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/02-index.png">
</a></p>

<p>First up, let&rsquo;s take a look at Index, which is also the first step of the pipeline. One way to think of index is &ldquo;all the bookkeeping needed to turn strings into ASTs.&rdquo; It reads files, parses them into ASTs, and does a little extra processing. In this phase, all the processing is <em>syntax driven</em> and <em>local</em>.</p>

<p>For example:</p>

<ul>
<li><p>Ruby has <code>if</code>, <code>unless</code>, and <code>case</code>, but Sorbet rewrites all of these in terms of <code>if</code>. It&rsquo;s similar for <code>while</code> and <code>until</code>.</p></li>
<li><p>Many Ruby syntax constructs (like <code>alias</code>) have equivalent method-based counterparts (like <code>alias_method</code>). Sorbet rewrites these keywords in terms of the methods.</p></li>
<li><p>Ruby has both <code>class</code> and <code>module</code> definitions. There are hundreds of places in Sorbet that work with classes and modules, but only 9 places where the distinction between class or module is relevant. Sorbet represents them both with a single C++ class that has an enum field to tell the two apart.</p></li>
</ul>


<p>All told, the Ruby parser emits around 100 distinct AST node types, but the IR that comes out of Index has <em>fewer than 30</em>. That means far fewer cases to handle in future phases of the pipeline:</p>

<p><a href="/images/sorbet-pipeline-overview/03-desugar.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/03-desugar.png">
</a></p>

<p>Again: these transformations are entirely syntactic. Rewriting an <code>unless</code> to an <code>if</code> is as simple as swapping the true and false branches. By comparison, some examples of things that not entirely syntactic:</p>

<ul>
<li><p>Knowing which class <code>A.new</code> would instantiate. Without doing a lot more work, we can&rsquo;t say for sure that <code>A</code> refers to <code>::A</code> at the top level, or to <code>::SomeClass::SomeModule::A</code>, or any class at all.</p></li>
<li><p>Knowing whether a method is defined. If we can&rsquo;t even figure out which classes exist yet, certainly we have no hope for methods.</p></li>
<li><p>Knowing what a type means. Types in Sorbet are almost entirely names of other classes (for example, <code>T.any(A, B)</code> is a <a href="https://sorbet.org/docs/union-types">union type</a> of two <a href="https://sorbet.org/docs/class-types">class types</a>, representing either an instance of the class <code>A</code> or the class <code>B</code>.)</p></li>
</ul>


<p>All of these questions involve some form of global information. Since Index
only has access to local information, it can&rsquo;t answer any of them. In spite of that, Index is also tasked with understanding <em>DSLs</em> and <em>metaprogramming</em>.</p>

<p>DSLs and metaprogramming in Ruby are super common in Ruby yet near impossible to represent statically (which I talk more about in <a href="/ruby-mutation/">What makes type checking Ruby hard?</a>). In fact, I&rsquo;d argue, that no amount of global static analysis could make it feasible; there&rsquo;d always be something missing.</p>

<p>Rather than make a herculean attempt to solve a hard problem, Sorbet spends nearly zero effort implementing <em>imperfect heuristics</em> to handle various Ruby DSLs at a reasonable degree of fidelity.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">attr_reader</span> <span class="ss">:foo</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># becomes:</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">foo</span>
</span><span class='line'>  <span class="vi">@foo</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>For example, <code>attr_reader :foo</code> is unconditionally rewritten to <code>def foo; @foo; end</code>, even though Index only sees a method call to &ldquo;some unknown method named <code>attr_reader</code>.&rdquo; Index doesn&rsquo;t know or care whether <code>attr_reader</code> exists, yet it makes this transformation anyways. This could cause real problems,<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> but it comes with plenty of upsides (definitely the subject of another post). For now, just know that&rsquo;s the way things are done.</p>

<p>Other examples of DSLs that are handled by Index:</p>

<ul>
<li><code>A = Class.new do; end</code> is rewritten to <code>class A; end</code></li>
<li><code>A = Struct.new(:foo)</code> becomes <code>class A; def foo; @foo; end; end</code></li>
<li>Sorbet&rsquo;s <a href="https://sorbet.org/docs/tstruct">typed structs</a> (i.e., <code>T::Struct</code>) get rewritten significantly</li>
</ul>


<p>To wrap it all up: Index is in charge of syntactic rewrites that have to work without any global information. The goal is to vastly simplify future phases and to provide best-effort support for DSLs and metaprogramming.</p>

<p>Next up is Resolve, which is charged with sorting out and recording all that global information. Before we can understand Resolve, let&rsquo;s take a quick look at the data structure responsible for holding it all, conveniently called <code>GlobalState</code>.</p>

<h2>GlobalState</h2>

<p><a href="/images/sorbet-pipeline-overview/04-global-state.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/04-global-state.png">
</a></p>

<p>There&rsquo;s a lot of stuff in <code>GlobalState</code>, but the two most important parts are the name table and the symbol table.</p>

<p>The <strong>name table</strong> is for interning strings. Strings take up lots of space and are slow to compare for equality. Instead of storing strings within parts of the Sorbet&rsquo;s AST, Sorbet interns a copy of the string into a massive array, and stores pointers to that interned string in the AST instead. The implementation is slightly more complicated to save space and present a clean API, but the mental model is the same. Comparing pointers for equality is super fast, and following the pointer recovers the underlying string.</p>

<p>The <strong>symbol table</strong> stores information about Ruby-level definitions in a program. For each class, method, constant, instance variable, type parameter, and generic type member, there&rsquo;s a <code>Symbol</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> in the symbol table. A <code>Symbol</code> tracks a definition&rsquo;s name, the line(s) where it was defined, its owner (usually: the class it&rsquo;s defined in), its type (if can have one), its parent class &amp; ancestors if it&rsquo;s a class, etc. With the symbol table in hand, we can answer any question we need to.</p>

<p>By default these tables are immutable, but within specific passes they can be made mutable. Knowing what&rsquo;s mutable when is key to reasoning about what each phase does, so let&rsquo;s go back and annotate our previous picture of the pipeline:</p>

<p><a href="/images/sorbet-pipeline-overview/05-pipeline-global-state.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/05-pipeline-global-state.png">
</a></p>

<p>For the case of Index, we see that the symbol table is locked, but the name table is mutable. That&rsquo;s another way of thinking about what &ldquo;entirely syntax driven&rdquo; means: Index can intern strings (purely local), but it can&rsquo;t create <code>Symbol</code>s, which represent global definitions in a program (and since they can&rsquo;t have been created yet, it certainly can&rsquo;t reliably look them up).</p>

<p>This diagram also shows that inspite of its name, <code>GlobalState</code> is threaded as an argument through each individual pass, not stored in a global variable. (This is critical for making Sorbet parallel).</p>

<p>Armed with that knowledge, let&rsquo;s take a look at how Resolve works.</p>

<h2>Resolve</h2>

<p><a href="/images/sorbet-pipeline-overview/06-resolve.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/06-resolve.png">
</a></p>

<p>Resolve&rsquo;s job is to <em>populate the symbol table</em>: it&rsquo;s the only time in the entire pipeline that the symbol table can be mutated. Since the symbol table has an entry for every definition in a Ruby project, Resolve does these kinds of things:</p>

<ul>
<li><p>It creates a <code>Symbol</code> for every class or module definition, and registers what its ancestors (superclass &amp; mixins) are.</p></li>
<li><p>It creates a <code>Symbol</code> for every instance variable, and records its type if it was given a type annotation (<code>@x = T.let(..., A)</code>).</p></li>
<li><p>It creates a <code>Symbol</code> for every method definition, registers which class that method was defined in, and records that method&rsquo;s argument and return types using the corresponding signature.</p></li>
</ul>


<p>But the most notable job Resolve has is updating every constant literal in the AST (like the <code>A</code> in <code>A.new</code>) with a reference to the <code>Symbol</code> that constant literal resolves to. This super important; for example, until constant literals are resolved Sorbet can&rsquo;t create or manipulate types. Constant resolution is a pre-requisite to nearly everything further down the pipeline.</p>

<p>The problem is that resolving constants in Ruby is complicated. Ruby resolves constant literals by looking for a definition with that name in the current <em>nesting scope</em> and in <em>any ancestor</em>. But declaring a class&rsquo;s ancestors is done with constant literals, which themselves need to be resolved! To model Ruby, Sorbet is forced to interleave resolving constant literals and populating ancestor information.</p>

<p>Let&rsquo;s consider an example:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Parent</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Mixin1</span>
</span><span class='line'>    <span class="k">module</span> <span class="nn">Mixin2</span><span class="p">;</span> <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Child</span> <span class="o">&lt;</span> <span class="no">Parent</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Mixin1</span>
</span><span class='line'>  <span class="kp">include</span> <span class="no">Mixin2</span>
</span><span class='line'><span class="k">end</span></span></code></pre></td></tr></table></div></figure>


<p>Sorbet builds up two to-do lists: one list for every part of the AST that could involve updating a class&rsquo;s ancestor information, and one for every constant literal to try to resolve. Then, it alternates processing these two lists.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class=''><span class='line'>│ Ancestor resolution items │ Constant resolution items │
</span><span class='line'>├───────────────────────────┼───────────────────────────┤
</span><span class='line'>│ - class Child &lt; Parent    │ - class Child &lt; Parent    │
</span><span class='line'>│               ^^^^^^^^    │                 ^^^^^^    │
</span><span class='line'>│ - include Mixin1          │ - include Mixin1          │
</span><span class='line'>│   ^^^^^^^^^^^^^^          │           ^^^^^^          │
</span><span class='line'>│ - include Mixin2          │ - include Mixin2          │
</span><span class='line'>│   ^^^^^^^^^^^^^^          │           ^^^^^^          │</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>First, loop through all the ancestor items. If the constant literal at that part of the AST at that point became resolved, update the ancestor information of the corresponding class.</p></li>
<li><p>Next, loop through all the constant literals. Updating ancestor information from the previous step might have tipped the scales, allowing Sorbet to resolve some of these. Resolving a constant literal means updating the AST to store a reference to the corresponding <code>Symbol</code> directly.</p></li>
<li><p>Repeat. Update ancestors again, resolve literals again, etc.</p></li>
</ol>


<p>The loop ends when there&rsquo;s nothing left to do, or when neither list gets smaller (the to-do lists never grow after creation, so we know that this loop terminates).</p>

<p>Resolve also simplifies the AST, but not by nearly as much as Index does:</p>

<p><a href="/images/sorbet-pipeline-overview/08-resolve-node-types.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/08-resolve-node-types.png">
</a></p>

<p>All the argument-related things are gone, because all the arguments have been entered into the Symbol table anyways; no need to also have them in the AST. The <code>UnresolvedConstantLit</code> node type is gone, because they&rsquo;ve all been converted to <code>ConstantLit</code> nodes via constant resolution.</p>

<p>To recap, that&rsquo;s Resolve: a handful of algorithms (tree traversals and fixed point loops) that understand how Ruby definitions work and how to create <code>Symbol</code> entries in the symbol table for them. When Resolve is done, it&rsquo;s like having the answer key to a test: there&rsquo;s not a question in sight we can&rsquo;t look up the answer for. So let&rsquo;s look at Typecheck to close out the pipeline.</p>

<h2>Typecheck</h2>

<p><a href="/images/sorbet-pipeline-overview/10-typecheck.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/10-typecheck.png">
</a></p>

<p>With <code>GlobalState</code> entirely populated, we can lock it: no more mutation.
All methods are type checked one-by-one, which is easy to parallelize since since <code>GlobalState</code> is frozen.</p>

<p>and they&rsquo;re all type checked in parallel, we have this really nice property that the result of type checking one method <em>never</em> affects how another method type checks.</p>

<p>Since <code>GlobalState</code> has been populated and we know it can&rsquo;t change, the type inference algorithm can be pretty straight forward. Since all methods are type checked independently, there&rsquo;s no reason to attempt to infer types for a method&rsquo;s arguments: other methods wouldn&rsquo;t be able to use that information. If an arg isn&rsquo;t given a type explicitly, we&rsquo;ll assume the arg is <a href="https://sorbet.org/docs/untyped">untyped</a>. Sorbet takes the types it was given for arguments and flows that knowledge forward, inferring types for local variables along the way.</p>

<p>After all the simplification and resolution that other passes have done, type checking Ruby code is pretty much 4 kinds of operations:</p>

<ul>
<li>Knowing the types of Ruby literals (e.g., the string literal <code>"hello"</code> has type <code>String</code>)</li>
<li>Looking up the types of Symbols (e.g., knowing that <code>Parent::A</code> has type <code>Integer</code>)</li>
<li>Modeling the effect of control flow on the types of variables</li>
<li>Type checking method calls (very complicated)</li>
</ul>


<p>Modeling control flow sensitivity in Sorbet is really cool, but I don&rsquo;t really think of it as an &ldquo;architectural&rdquo; or &ldquo;pipeline&rdquo; component of Sorbet, so I&rsquo;ll save it for another article.</p>

<p>Type checking method calls is the hardest of the four things in that list for a whole lot of reasons, and unfortunately I probably won&rsquo;t write an article on it. There&rsquo;s a 2k LOC file in Sorbet just for handling method calls. Meanwhile, all of Typecheck takes up 8k. That&rsquo;s 25% just for one Ruby construct.</p>

<p>In Typecheck there&rsquo;s also the implementation of the type system itself. For Sorbet, &ldquo;implementing the type system&rdquo; is mostly a matter of writing a funciton which will say whether one type is a subtype of another. But again, given <code>GlobalState</code> (and a heaping dose of type theory), that&rsquo;s a tractable problem to solve, especially because as Sorbet&rsquo;s type system goes, it&rsquo;s not trying to rock the boat. Most type level constructs have plenty of precedent in other systems.</p>

<h2>Wrap up</h2>

<p><a href="/images/sorbet-pipeline-overview/11-pipeline-final.png">
  <img class="fullwidth" src="/images/sorbet-pipeline-overview/11-pipeline-final.png">
</a></p>

<p>&hellip; And that&rsquo;s it! For real this time. It&rsquo;s a lot to take in, and the goal wasn&rsquo;t to cover things with the hopes of being productive contributing to the Sorbet codebase. But hopefully it outlines enough of the moving parts that it&rsquo;s possible to start diving into some interesting implications of design decisions.</p>

<p>Again, I haven&rsquo;t written too many such posts, but I&rsquo;m definitely planning on writing more in the future. For now:</p>

<ul>
<li><a href="/ruby-mutation/">What makes type checking Ruby hard?</a></li>
<li>&hellip; more coming soon!</li>
</ul>


<!-- TODO(jez) Potential forward reference -->


<p>I promise: this post was long so that those don&rsquo;t have to be!</p>

<p>Again, if you have any questions or suggestions after having read this, I&rsquo;m happy to answer them. The best place to reach me is on the Sorbet Slack:</p>

<p><a href="https://sorbet.org/slack">→ Sorbet Slack community</a></p>

<p>Come find me in the <code>#internals</code> channel. Thanks!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>As an exercise, try to come up with a Ruby program which raises a <code>NoMethodError</code> when run, but which Sorbet doesn&rsquo;t report an error on. Similarly, try to write one in which Sorbet reports a &ldquo;method doesn&rsquo;t exist&rdquo; error, but which runs just fine.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Sorbet&rsquo;s <code>Symbol</code> data structure (what&rsquo;s stored in the symbol table) is completely different from Ruby&rsquo;s <code>Symbol</code> (like <code>:foo</code>). Hopefully the distinction is always clear from context.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>


    <footer class="entry-meta">
      <span class="entry-tags">
        <ul class="Tags">
          
            <li class="Tag">
              <a href="/categories/#sorbet" title="Pages tagged sorbet">sorbet</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#compilers" title="Pages tagged compilers">compilers</a>
            </li>
          
        </ul>
      </span>
      <span class="entry-date date published updated"><time datetime="2020-01-01T14:51:50-06:00">January 1, 2020</time></span>
      
    </footer>
  </div>
  
  <div class="read-more">
    
      <div class="read-more-header">
        <a href="/ruby-mutation/" class="Button">Read More</a>
      </div><!-- /.read-more-header -->
      <div class="read-more-content">
        <h3><a href="/ruby-mutation/" title="What makes type checking Ruby hard?">What makes type checking Ruby hard?</a></h3>
      <p>Mutation makes typechecking Ruby harder than many other programming languages. Most people will immediately think I mean mutation in the sense of `x += 1` or something—that&#8217;s not what I&#8217;m referring to. In fact, that&#8217;s the easy kind of mutation to model in a type system.
 <a href="/ruby-mutation/"> Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/surgery-on-code/" title="Surgery on Code from the Command Line">Surgery on Code from the Command Line</a></h4>
            <span>Published on July 30, 2019</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/on-language-choice/" title="On Programming Language Choice">On Programming Language Choice</a></h4>
            <span>Published on June 21, 2019</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
  </div><!-- /.read-more -->


</div>

<div class="footer-wrapper">
  Blog source on <a href="https://github.com/jez/blog">GitHub</a>.

</div>

</body>
</html>
