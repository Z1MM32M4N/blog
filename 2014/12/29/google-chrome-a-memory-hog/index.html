
<!DOCTYPE html>

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Google Chrome: A Memory Hog - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="A bash oneliner to determine how much memory Chrome is using.">

<meta name="keywords" content="unix bash ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog">
<meta property="og:title" content="Google Chrome: A Memory Hog">
<meta property="og:description" content="A bash oneliner to determine how much memory Chrome is using.">
<meta property="og:image" content="">
<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog">
<link href="/favicon.png" rel="icon">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">




</head>

<body id="post" class="">

<nav class="Navigation">
  <ul class="Tags">
    
      <li class="Tag">
        
          <a href="/">Home</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="/categories/">Categories</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="https://jez.io">About</a>
        
      </li>
    
  </ul>
</nav>





<div class="EntryHeader">
  <h1 class="EntryHeader-title">Google Chrome: A Memory Hog</h1>
  <h2 class="EntryHeader-subtitle">December 29, 2014</h2>

  <ul class="Tags">
    
  </ul>
</div>



<div id="main" role="main">
  <article class="Post-content">
    <p>Whenever someone complains about a slow computer, the first thing I check is
how many Chrome tabs they have open. Chrome hogs memory like no other. For
users, this means Chrome is snappy and responsive, but oftentimes it comes at
the expense of crowding out other programs. To get an idea of how much memory
Chrome is really using, I wrote a quick bash oneliner.</p>

<!-- more -->


<h2>Why does Chrome Hog Memory?</h2>

<p><a href="http://mobile.extremetech.com/latest/221392-iframe-irony-adblock-plus-is-probably-the-reason-firefox-and-chrome-are-such-memory-hogs">An article posted to Hacker News</a> recently brought some light to
the question of why Chrome and Firefox suck up so much memory: Adblock Plus. The
general idea is that the excessive use of iframes in most websites today ramps
up the amount of processing that Adblock Plus has to do, driving memory usage
through the roof. For more specifics, check out the rest of of the article.</p>

<h2>The Oneliner</h2>

<p>For the impatient, here&rsquo;s the code. It uses standard Unix tools:</p>

<figure class='code'><figcaption><span>Chrome Memory Usage</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>ps -ev | grep -i chrome | awk <span class="s1">'{print $12}'</span> | awk <span class="s1">'{for(i=1;i&lt;=NF;i++)s+=$i}END{print s}'</span></span></code></pre></td></tr></table></div></figure>


<p>Pretty isn&rsquo;t it? If you want to save this as an alias for handy use, add this
line to your ~/.bashrc (or appropriate configuration file):</p>

<figure class='code'><figcaption><span>Add as an alias</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">alias </span><span class="nv">chromemem</span><span class="o">=</span><span class="s2">"ps -ev | grep -i chrome | awk '{print </span><span class="se">\$</span><span class="s2">12}' | awk '{for(i=1;i&lt;=NF;i++)s+=</span><span class="se">\$</span><span class="s2">i}END{print s}'"</span></span></code></pre></td></tr></table></div></figure>


<p>It outputs a percentage. Here&rsquo;s the alias in action:</p>

<figure class='code'><figcaption><span>Usage</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>chromemem
</span><span class='line'>60</span></code></pre></td></tr></table></div></figure>


<h2>Explanation</h2>

<p>There&rsquo;s a lot of good stuff going on here, so let&rsquo;s take it step-by-step.</p>

<p>First, we&rsquo;ll need a program that tells us memory usage. I&rsquo;m sure there are many,
but I&rsquo;m familiar with <code>ps</code>. After checking out the man page for a few options, I
came up with <code>ps -ev</code>, to show all information about all processes. Maybe
wasteful, but it works.</p>

<figure class='code'><figcaption><span>ps -ev</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>ps -ev
</span><span class='line'>  PID STAT      TIME  SL  RE PAGEIN      VSZ    RSS   LIM     TSIZ  %CPU %MEM COMMAND
</span><span class='line'> 3473 S      0:54.92   0   0      0  3579092 301244     -        0   6.7  7.2 /Applications/Google C
</span><span class='line'>  365 S      3:03.17   0   0      0  3920732 206808     -        0   0.3  4.9 /Applications/Google C
</span><span class='line'>  983 S      1:29.23   0   0      0  3560272 193860     -        0   0.1  4.6 /Applications/Google C
</span><span class='line'>  395 S      0:13.11   0   0      0  2824936 141644     -        0   0.0  3.4 /Applications/Google C
</span><span class='line'>  422 S      0:27.22   0   0      0  3345796 130796     -        0   0.0  3.1 /Applications/Google C
</span><span class='line'>  ...</span></code></pre></td></tr></table></div></figure>


<p>Notice that there&rsquo;s a convenient column describing memory usage as a percentage
of total available memory, as well as what command is being run in that
process. Let&rsquo;s make sure that we&rsquo;re looking at only the processes running
some sort of Chrome service before totaling up the memory. We can find these
lines with <code>ps -ev | grep -i chrome</code> (the -i means case-insensitive). Due to the
way I clipped the previous sample output, nothing changes in the first five
lines, but rest assured: we&rsquo;re only looking at Chrome processes now.</p>

<p>Now it&rsquo;s time to get rid of all the other nonsense that we included with <code>ps
-ev</code>. Luckily, there&rsquo;s a handy tool called <code>awk</code> that makes parsing text by
column easy. If we want to print the 12th column (which just so happens to
contain the memory consumption!) we can do <code>awk '{print $12}'</code>:</p>

<figure class='code'><figcaption><span>ps -ev | grep -i chrome | awk &#8216;{print $12}&#8217;</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>ps -ev | grep -i chrome | awk <span class="s1">'{print $12}'</span>
</span><span class='line'>7.2
</span><span class='line'>5.1
</span><span class='line'>4.6
</span><span class='line'>3.4
</span><span class='line'>3.2
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>Finally, I found myself needing a way to add up a column of numbers. A quick
Google search led me to <a href="http://stackoverflow.com/questions/2572495/read-from-file-and-add-numbers">this StackOverflow question</a>, and I picked the
<code>awk</code> solution because I knew I could just pipe the input to awk (as opposed to
having to do weird hacks to get it to work with a bash for loop):</p>

<figure class='code'><figcaption><span>Final Solution</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>ps -emv | grep -i chrome | awk <span class="s1">'{print $12}'</span> | awk <span class="s1">'{for(i=1;i&lt;=NF;i++)s+=$i}END{print s}'</span>
</span><span class='line'>60.4</span></code></pre></td></tr></table></div></figure>


<p>Of course, you could change the last <code>awk</code> command to print out something
fancier like</p>

<figure class='code'><figcaption><span>Final Solution</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="gp">$ </span>ps -emv | grep -i chrome | awk <span class="s1">'{print $12}'</span> | awk <span class="s1">'{for(i=1;i&lt;=NF;i++)s+=$i}END{print "Chrome is using "s"% of total memory."}'</span>
</span><span class='line'>Chrome is using 60.4% of total memory.</span></code></pre></td></tr></table></div></figure>


<p>There you have it! Bash oneliners save the day yet again.</p>

<h2>Update</h2>

<p>After writing this article, I stopped using Ad Block Plus, and I noticed a
significant drop in Chrome&rsquo;s memory usage. Obviously, though, that came at the
cost of not blocking ads! Also, from time to time I would encounter a site that
seemed sluggish, presumably because of all the ads attempting to be loaded. My
simple solution to this was just to disable JavaScript on that page (I use an
extension called Quick JavaScript Switcher), but this wasn&rsquo;t an automated
solution.</p>

<p>Then I discovered <a href="https://github.com/gorhill/uBlock">Î¼Block</a>, an &ldquo;efficient blocker for Chromium and
Firefox.&rdquo; The fancy graphs on it&rsquo;s homepage convinced me to give it a shot, and
from what I can tell so far it&rsquo;s responsive and effective.</p>

    <footer class="entry-meta">
      <span class="entry-tags">
        <ul class="Tags">
          
            <li class="Tag">
              <a href="/categories/#unix" title="Pages tagged unix">unix</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#bash" title="Pages tagged bash">bash</a>
            </li>
          
        </ul>
      </span>
      <span class="entry-date date published updated"><time datetime="2014-12-29T18:00:00-05:00">December 29, 2014</time></span>
      
    </footer>
  </div>
  
  <div class="read-more">
    
      <div class="read-more-header">
        <a href="/profiling-in-haskell/" class="Button">Read More</a>
      </div><!-- /.read-more-header -->
      <div class="read-more-content">
        <h3><a href="/profiling-in-haskell/" title="Profiling in Haskell for a 10x Speedup">Profiling in Haskell for a 10x Speedup</a></h3>
      <p>I wrote up a toy project in Haskell and profiled it to learn about Haskell&#8217;s profiling tools and about profiling code in general. Profiling in Haskell with Stack is super easy&#8230;
 <a href="/profiling-in-haskell/"> Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/cpml-race/" title="Concurrent Programming in ML: A Race">Concurrent Programming in ML: A Race</a></h4>
            <span>Published on July 18, 2018</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/prefer-then-over-catch/" title="Prefer .then() over .catch()">Prefer .then() over .catch()</a></h4>
            <span>Published on May 31, 2018</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
  </div><!-- /.read-more -->


</div>

<div class="footer-wrapper">
  Blog source on <a href="https://github.com/jez/blog">GitHub</a>.

</div>

</body>
</html>
